<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Elasticsearch,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="本文介绍了一些 Elasticsearch 的入门知识，由于笔者的本意是使用 Elasticsearch 搭建一个博客站内搜索工具，所以很多没有使用到的内容就没有进行深入。如果有需要的读者，可以点击下面的《Elasticsearch: 权威指南》链接，或者购买该书籍进行深入的学习。 本文参考的资料有：  Elasticsearch: 权威指南 使用 Elasticsearch 实现博客站内搜索">
<meta name="keywords" content="Elasticsearch">
<meta property="og:type" content="article">
<meta property="og:title" content="Elasticsearch 入门">
<meta property="og:url" content="https://shiningdan.github.io/2017/05/09/Elasticsearch-入门/index.html">
<meta property="og:site_name" content="ShiningDan的博客">
<meta property="og:description" content="本文介绍了一些 Elasticsearch 的入门知识，由于笔者的本意是使用 Elasticsearch 搭建一个博客站内搜索工具，所以很多没有使用到的内容就没有进行深入。如果有需要的读者，可以点击下面的《Elasticsearch: 权威指南》链接，或者购买该书籍进行深入的学习。 本文参考的资料有：  Elasticsearch: 权威指南 使用 Elasticsearch 实现博客站内搜索">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-05-14T14:45:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Elasticsearch 入门">
<meta name="twitter:description" content="本文介绍了一些 Elasticsearch 的入门知识，由于笔者的本意是使用 Elasticsearch 搭建一个博客站内搜索工具，所以很多没有使用到的内容就没有进行深入。如果有需要的读者，可以点击下面的《Elasticsearch: 权威指南》链接，或者购买该书籍进行深入的学习。 本文参考的资料有：  Elasticsearch: 权威指南 使用 Elasticsearch 实现博客站内搜索">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6345612185049236000',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://shiningdan.github.io/2017/05/09/Elasticsearch-入门/">





  <title> Elasticsearch 入门 | ShiningDan的博客 </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?65f098889042a1740b5cfede967d34b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ShiningDan的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description"></h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photography">
          <a href="/categories/photography" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            摄影
          </a>
        </li>
      
        
        <li class="menu-item menu-item-coding">
          <a href="/categories/coding" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            编程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://shiningdan.github.io/2017/05/09/Elasticsearch-入门/">

  <span style="display:none" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ShiningDan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ShiningDan的博客">
    <span style="display:none" itemprop="logo" itemscope="" itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ShiningDan的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                Elasticsearch 入门
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-09T16:22:24+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/coding/" itemprop="url" rel="index">
                    <span itemprop="name">coding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/09/Elasticsearch-入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/09/Elasticsearch-入门/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/05/09/Elasticsearch-入门/" class="leancloud_visitors" data-flag-title="Elasticsearch 入门">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文介绍了一些 Elasticsearch 的入门知识，由于笔者的本意是使用 Elasticsearch 搭建一个博客站内搜索工具，所以很多没有使用到的内容就没有进行深入。如果有需要的读者，可以点击下面的《Elasticsearch: 权威指南》链接，或者购买该书籍进行深入的学习。</p>
<p>本文参考的资料有：</p>
<ul>
<li><a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/" target="_blank" rel="noopener">Elasticsearch: 权威指南</a></li>
<li><a href="https://imququ.com/post/elasticsearch.html" target="_blank" rel="noopener">使用 Elasticsearch 实现博客站内搜索</a></li>
</ul>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。</p>
<p>Elasticsearch 不仅仅可以提供全文搜索，还可以提供结构化搜索、数据分析、复杂的语言处理、地理位置和对象间关联关系等。 我们还将探讨如何给数据建模来充分利用 Elasticsearch 的水平伸缩性，以及在生产环境中如何配置和监视你的集群。</p>
<h2 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h2><p>Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 <a href="https://lucene.apache.org/core/" target="_blank" rel="noopener">Apache Lucene™</a> 基础之上。 Lucene 可能是目前存在的，不论开源还是私有的，拥有最先进，高性能和全功能搜索引擎功能的库。</p>
<p>但是 Lucene 仅仅只是一个库。为了利用它，你需要编写 java 程序，并在你的 java 程序里面直接集成 Lucene 包。 Elasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目标是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。</p>
<h3 id="安装并运行-Elasticsearch"><a href="#安装并运行-Elasticsearch" class="headerlink" title="安装并运行 Elasticsearch"></a>安装并运行 Elasticsearch</h3><p>安装 Elasticsearch 之前，你需要先安装一个较新的版本的 Java</p>
<p>之后，你可以从 <a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">elastic 的官网</a> 获取最新版本的 Elasticsearch。在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/_installation.html" target="_blank" rel="noopener"> Docs Installation</a>部分可以查看官方的安装介绍。</p>
<p>在安装并运行完 Elasticsearch 之后，测试 Elasticsearch 是否启动成功，可以打开另一个终端，执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd elasticsearch-&lt;version&gt;</span><br><span class="line">./bin/elasticsearch</span><br><span class="line"></span><br><span class="line">// 等待运行成功以后</span><br><span class="line">curl &apos;http://localhost:9200/?pretty&apos;</span><br></pre></td></tr></table></figure>
<p>你应该得到和下面类似的响应(response)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;Tom Foster&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;2.1.0&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;72cd1f1a3eee09505e036106146dc1949dc5dc87&quot;,</span><br><span class="line">    &quot;build_timestamp&quot; : &quot;2015-11-18T22:40:03Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;5.3.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单个<strong>节点</strong>可以作为一个运行中的 Elasticsearch 的实例。 而一个<strong>集群</strong>是一组拥有相同 cluster.name 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。</p>
<h4 id="安装-Sense"><a href="#安装-Sense" class="headerlink" title="安装 Sense"></a>安装 Sense</h4><p>Sense 是一个 Kibana（一个开源的分析与可视化平台） 应用 它提供交互式的控制台，通过你的浏览器直接向 Elasticsearch 提交请求。</p>
<p>安装与运行 Sense：</p>
<p>在 Kibana 目录下运行下面的命令，下载并安装 Sense app：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kibana plugin --install elastic/sense</span><br></pre></td></tr></table></figure>
<p>启动 Kibana.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kibana</span><br></pre></td></tr></table></figure>
<h3 id="和-Elasticsearch-交互"><a href="#和-Elasticsearch-交互" class="headerlink" title="和 Elasticsearch 交互"></a>和 Elasticsearch 交互</h3><h3 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h3><h4 id="节点客户端（Node-client）"><a href="#节点客户端（Node-client）" class="headerlink" title="节点客户端（Node client）"></a>节点客户端（Node client）</h4><p>节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。</p>
<h4 id="传输客户端（Transport-client）"><a href="#传输客户端（Transport-client）" class="headerlink" title="传输客户端（Transport client）"></a>传输客户端（Transport client）</h4><p>轻量级的传输客户端可以可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。</p>
<h3 id="RESTful-API-with-JSON-over-HTTP"><a href="#RESTful-API-with-JSON-over-HTTP" class="headerlink" title="RESTful API with JSON over HTTP"></a>RESTful API with JSON over HTTP</h3><p>所有其他语言可以使用 RESTful API 通过端口 9200 和 Elasticsearch 进行通信</p>
<p>一个 Elasticsearch 请求和任何 HTTP 请求一样由若干相同的部件组成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos;</span><br></pre></td></tr></table></figure>
<p>被 <code>&lt; &gt;</code> 标记的部件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">VERB</span><br><span class="line"></span><br><span class="line">适当的 HTTP 方法 或 谓词 : GET`、 `POST`、 `PUT`、 `HEAD 或者 `DELETE`。</span><br><span class="line"></span><br><span class="line">PROTOCOL</span><br><span class="line"></span><br><span class="line">http 或者 https`（如果你在 Elasticsearch 前面有一个 `https 代理）</span><br><span class="line"></span><br><span class="line">HOST</span><br><span class="line"></span><br><span class="line">Elasticsearch 集群中任意节点的主机名，或者用 localhost 代表本地机器上的节点。</span><br><span class="line"></span><br><span class="line">PORT</span><br><span class="line"></span><br><span class="line">运行 Elasticsearch HTTP 服务的端口号，默认是 9200 。</span><br><span class="line"></span><br><span class="line">PATH</span><br><span class="line"></span><br><span class="line">API 的终端路径（例如 _count 将返回集群中文档数量）。Path 可能包含多个组件，例如：_cluster/stats 和 _nodes/stats/jvm 。</span><br><span class="line"></span><br><span class="line">QUERY_STRING</span><br><span class="line"></span><br><span class="line">任意可选的查询字符串参数 (例如 ?pretty 将格式化地输出 JSON 返回值，使其更容易阅读)</span><br><span class="line"></span><br><span class="line">BODY</span><br><span class="line"></span><br><span class="line">一个 JSON 格式的请求体 (如果请求需要的话)</span><br></pre></td></tr></table></figure>
<p>例如，计算集群中文档的数量，我们可以用这个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/_count?pretty&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Elasticsearch 返回一个 HTTP 状态码（例如：200 OK<code>）和（除</code>HEAD<code>请求）一个 JSON 格式的返回值。前面的</code>curl 请求将返回一个像下面一样的 JSON 体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;count&quot; : 0,</span><br><span class="line">    &quot;_shards&quot; : &#123;</span><br><span class="line">        &quot;total&quot; : 5,</span><br><span class="line">        &quot;successful&quot; : 5,</span><br><span class="line">        &quot;failed&quot; : 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面向文档"><a href="#面向文档" class="headerlink" title="面向文档"></a>面向文档</h3><p>Elasticsearch 是<strong>面向文档</strong>的，意味着它<strong>存储整个对象或 文档</strong>。Elasticsearch 不仅存储文档，而且每个文档的内容使之可以被检索。在 Elasticsearch 中，你 <strong>对文档进行索引、检索、排序和过滤</strong>–而不是对行列数据。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因。</p>
<p><strong>Elasticsearch 使用 JavaScript Object Notation 或者 JSON 作为文档的序列化格式</strong> </p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><strong>索引</strong>这个词在 Elasticsearch 语境中包含多重意思</p>
<h4 id="索引（名词）："><a href="#索引（名词）：" class="headerlink" title="索引（名词）："></a>索引（名词）：</h4><p>如前所述，一个<strong>索引</strong>类似于传统关系数据库中的一个<strong>数据库</strong> ，是一个存储关系型文档的地方。 索引 (index) 的复数词为 indices 或 indexes 。</p>
<h4 id="索引（动词）："><a href="#索引（动词）：" class="headerlink" title="索引（动词）："></a>索引（动词）：</h4><p>索引一个文档 就是存储一个文档到一个 索引 （名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 INSERT 关键词，除了文档已存在时新文档会替换就文档情况之外。</p>
<h4 id="倒排索引："><a href="#倒排索引：" class="headerlink" title="倒排索引："></a>倒排索引：</h4><p>关系型数据库通过增加一个 索引 比如一个 B树（B-tree）索引 到指定的列上，以便提升数据检索速度。Elasticsearch 和 Lucene 使用了一个叫做 倒排索引 的结构来达到相同的目的。</p>
<h4 id="索引雇员文档"><a href="#索引雇员文档" class="headerlink" title="索引雇员文档"></a>索引雇员文档</h4><p>对于雇员目录，我们将做如下操作：</p>
<ul>
<li>每个雇员索引一个文档，包含该雇员的所有信息。</li>
<li>每个文档都将是 employee 类型 。</li>
<li>该类型位于 索引 megacorp 内。</li>
<li>该索引保存在我们的 Elasticsearch 集群中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT &apos;http://localhost:9200/megacorp/employee/1&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;first_name&quot; : &quot;John&quot;,</span><br><span class="line">    &quot;last_name&quot; :  &quot;Smith&quot;,</span><br><span class="line">    &quot;age&quot; :        25,</span><br><span class="line">    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,</span><br><span class="line">    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">&#125;&apos;</span><br><span class="line">curl -XPUT &apos;http://localhost:9200/megacorp/employee/2&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;first_name&quot; :  &quot;Jane&quot;,</span><br><span class="line">    &quot;last_name&quot; :   &quot;Smith&quot;,</span><br><span class="line">    &quot;age&quot; :         32,</span><br><span class="line">    &quot;about&quot; :       &quot;I like to collect rock albums&quot;,</span><br><span class="line">    &quot;interests&quot;:  [ &quot;music&quot; ]</span><br><span class="line">&#125;&apos;</span><br><span class="line">curl -XPUT &apos;http://localhost:9200/megacorp/employee/3&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;first_name&quot; :  &quot;Douglas&quot;,</span><br><span class="line">    &quot;last_name&quot; :   &quot;Fir&quot;,</span><br><span class="line">    &quot;age&quot; :         35,</span><br><span class="line">    &quot;about&quot;:        &quot;I like to build cabinets&quot;,</span><br><span class="line">    &quot;interests&quot;:  [ &quot;forestry&quot; ]</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>注意，路径 <code>/megacorp/employee/1</code> 包含了三部分的信息：</p>
<p><code>megacorp</code>：索引名称<br><code>employee</code>：类型名称<br><code>1</code>：特定雇员的ID</p>
<h4 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/megacorp/employee/1&apos;</span><br></pre></td></tr></table></figure>
<p>返回结果包含了文档的一些元数据，以及 <code>_source</code> 属性，<code>_source</code> 属性中包含了原有存入的数据，内容是 John Smith 雇员的原始 JSON 文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; :   &quot;megacorp&quot;,</span><br><span class="line">  &quot;_type&quot; :    &quot;employee&quot;,</span><br><span class="line">  &quot;_id&quot; :      &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;found&quot; :    true,</span><br><span class="line">  &quot;_source&quot; :  &#123;</span><br><span class="line">      &quot;first_name&quot; :  &quot;John&quot;,</span><br><span class="line">      &quot;last_name&quot; :   &quot;Smith&quot;,</span><br><span class="line">      &quot;age&quot; :         25,</span><br><span class="line">      &quot;about&quot; :       &quot;I love to go rock climbing&quot;,</span><br><span class="line">      &quot;interests&quot;:  [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将 HTTP 命令由 PUT 改为 GET 可以用来检索文档，同样的，可以使用 DELETE 命令来删除文档，以及使用 HEAD 指令来检查文档是否存在。如果想更新已存在的文档，只需再次 PUT 。</strong></p>
<h4 id="轻量搜索"><a href="#轻量搜索" class="headerlink" title="轻量搜索"></a>轻量搜索</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/megacorp/employee/_search&apos;</span><br></pre></td></tr></table></figure>
<p>这个返回值是所有的数据。其检索返回的数据都存在 <code>_source</code> 中，其他的数据都是一些元数据。<br>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;took&quot;:      6,</span><br><span class="line">   &quot;timed_out&quot;: false,</span><br><span class="line">   &quot;_shards&quot;: &#123; ... &#125;,</span><br><span class="line">   &quot;hits&quot;: &#123;</span><br><span class="line">      &quot;total&quot;:      3,</span><br><span class="line">      &quot;max_score&quot;:  1,</span><br><span class="line">      &quot;hits&quot;: [</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;_index&quot;:         &quot;megacorp&quot;,</span><br><span class="line">            &quot;_type&quot;:          &quot;employee&quot;,</span><br><span class="line">            &quot;_id&quot;:            &quot;3&quot;,</span><br><span class="line">            &quot;_score&quot;:         1,</span><br><span class="line">            &quot;_source&quot;: &#123;</span><br><span class="line">               &quot;first_name&quot;:  &quot;Douglas&quot;,</span><br><span class="line">               &quot;last_name&quot;:   &quot;Fir&quot;,</span><br><span class="line">               &quot;age&quot;:         35,</span><br><span class="line">               &quot;about&quot;:       &quot;I like to build cabinets&quot;,</span><br><span class="line">               &quot;interests&quot;: [ &quot;forestry&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;_index&quot;:         &quot;megacorp&quot;,</span><br><span class="line">            &quot;_type&quot;:          &quot;employee&quot;,</span><br><span class="line">            &quot;_id&quot;:            &quot;1&quot;,</span><br><span class="line">            &quot;_score&quot;:         1,</span><br><span class="line">            &quot;_source&quot;: &#123;</span><br><span class="line">               &quot;first_name&quot;:  &quot;John&quot;,</span><br><span class="line">               &quot;last_name&quot;:   &quot;Smith&quot;,</span><br><span class="line">               &quot;age&quot;:         25,</span><br><span class="line">               &quot;about&quot;:       &quot;I love to go rock climbing&quot;,</span><br><span class="line">               &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;_index&quot;:         &quot;megacorp&quot;,</span><br><span class="line">            &quot;_type&quot;:          &quot;employee&quot;,</span><br><span class="line">            &quot;_id&quot;:            &quot;2&quot;,</span><br><span class="line">            &quot;_score&quot;:         1,</span><br><span class="line">            &quot;_source&quot;: &#123;</span><br><span class="line">               &quot;first_name&quot;:  &quot;Jane&quot;,</span><br><span class="line">               &quot;last_name&quot;:   &quot;Smith&quot;,</span><br><span class="line">               &quot;age&quot;:         32,</span><br><span class="line">               &quot;about&quot;:       &quot;I like to collect rock albums&quot;,</span><br><span class="line">               &quot;interests&quot;: [ &quot;music&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以通过指定属性来进行搜索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/megacorp/employee/_search?q=last_name:Smith&apos;</span><br></pre></td></tr></table></figure>
<h4 id="使用查询表达式搜索"><a href="#使用查询表达式搜索" class="headerlink" title="使用查询表达式搜索"></a>使用查询表达式搜索</h4><p>Query-string 搜索通过命令非常方便地进行临时性的即席搜索 ，但它有自身的局限性）。Elasticsearch 提供一个丰富灵活的查询语言叫做<strong>查询表达式</strong>， 它支持构建更加复杂和健壮的查询。</p>
<p>领域特定语言 （DSL）， 指定了使用一个 JSON 请求。我们可以像这样重写之前的查询所有 Smith 的搜索 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/megacorp/employee/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;last_name&quot; : &quot;Smith&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>返回结果与之前的查询一样，但还是可以看到有一些变化。其中之一是，不再使用 <code>query-string</code> 参数，而是一个请求体替代。这个请求使用 JSON 构造，并使用了一个 <code>match</code> 查询（属于查询类型之一，后续将会了解）。</p>
<h4 id="更复杂的搜索"><a href="#更复杂的搜索" class="headerlink" title="更复杂的搜索"></a>更复杂的搜索</h4><p>现在尝试下更复杂的搜索。 同样搜索姓氏为 Smith 的雇员，但这次我们只需要年龄大于 <code>30</code> 的。查询需要稍作调整，使用过滤器 <code>filter</code> ，它支持高效地执行一个结构化查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/megacorp/employee/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot; : &#123;</span><br><span class="line">                    &quot;last_name&quot; : &quot;smith&quot; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;range&quot; : &#123;</span><br><span class="line">                    &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h4 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h4><p>搜索下所有喜欢攀岩（<code>rock climbing</code>）的雇员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/megacorp/employee/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>Elasticsearch 默认按照相关性得分排序，即每个文档跟查询的匹配程度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   &quot;hits&quot;: &#123;</span><br><span class="line">      &quot;total&quot;:      2,</span><br><span class="line">      &quot;max_score&quot;:  0.16273327,</span><br><span class="line">      &quot;hits&quot;: [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            &quot;_score&quot;:         0.16273327, </span><br><span class="line">            &quot;_source&quot;: &#123;</span><br><span class="line">               &quot;first_name&quot;:  &quot;John&quot;,</span><br><span class="line">               &quot;last_name&quot;:   &quot;Smith&quot;,</span><br><span class="line">               &quot;age&quot;:         25,</span><br><span class="line">               &quot;about&quot;:       &quot;I love to go rock climbing&quot;,</span><br><span class="line">               &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            &quot;_score&quot;:         0.016878016, </span><br><span class="line">            &quot;_source&quot;: &#123;</span><br><span class="line">               &quot;first_name&quot;:  &quot;Jane&quot;,</span><br><span class="line">               &quot;last_name&quot;:   &quot;Smith&quot;,</span><br><span class="line">               &quot;age&quot;:         32,</span><br><span class="line">               &quot;about&quot;:       &quot;I like to collect rock albums&quot;,</span><br><span class="line">               &quot;interests&quot;: [ &quot;music&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到结果中，只有第一个结果出现了 <code>rock climbing</code>，第二个结果中只出现了 <code>rock</code>。</p>
<h4 id="短语搜索"><a href="#短语搜索" class="headerlink" title="短语搜索"></a>短语搜索</h4><p>找出一个属性中的独立单词是没有问题的，但有时候想要精确匹配一系列单词或者短语 。 比如， 我们想执行这样一个查询，仅匹配同时包含 “rock” 和 “climbing” ，并且 二者以短语 “rock climbing” 的形式紧挨着的雇员记录。</p>
<p>为此对 match 查询稍作调整，使用一个叫做 <code>match_phrase</code> 的查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/megacorp/employee/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match_phrase&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock limbing&quot; // 其中空格的数量不会影响查询的结果</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h4 id="高亮搜索"><a href="#高亮搜索" class="headerlink" title="高亮搜索"></a>高亮搜索</h4><p>许多应用都倾向于在每个搜索结果中 高亮 部分文本片段，以便让用户知道为何该文档符合查询条件。在 Elasticsearch 中检索出高亮片段也很容易。</p>
<p>再次执行前面的查询，并增加一个新的 <code>highlight</code> 参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/megacorp/employee/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match_phrase&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;highlight&quot;: &#123;</span><br><span class="line">        &quot;fields&quot; : &#123;</span><br><span class="line">            &quot;about&quot; : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>当执行该查询时，返回结果与之前一样，与此同时结果中还多了一个叫做 <code>highlight</code> 的部分。这个部分包含了 <code>about</code> 属性匹配的文本片段，并以 HTML 标签 <code>&lt;em&gt;&lt;/em&gt;</code> 封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   &quot;hits&quot;: &#123;</span><br><span class="line">      &quot;total&quot;:      1,</span><br><span class="line">      &quot;max_score&quot;:  0.23013961,</span><br><span class="line">      &quot;hits&quot;: [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            &quot;_score&quot;:         0.23013961,</span><br><span class="line">            &quot;_source&quot;: &#123;</span><br><span class="line">               &quot;first_name&quot;:  &quot;John&quot;,</span><br><span class="line">               &quot;last_name&quot;:   &quot;Smith&quot;,</span><br><span class="line">               &quot;age&quot;:         25,</span><br><span class="line">               &quot;about&quot;:       &quot;I love to go rock climbing&quot;,</span><br><span class="line">               &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;highlight&quot;: &#123;</span><br><span class="line">               &quot;about&quot;: [</span><br><span class="line">                  &quot;I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;&quot; </span><br><span class="line">               ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>终于到了最后一个业务需求：支持管理者对雇员目录做分析。 Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 <code>GROUP BY</code> 类似但更强大。也就是对一个分组中的数据进行分析，比如统计次数，求平均值等。</p>
<p>举个例子，统计雇员中兴趣爱好的次数排名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/megacorp/employee/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;all_interests&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123; &quot;field&quot;: &quot;interests&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>还可以求平均值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/megacorp/employee/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;all_interests&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123; &quot;field&quot; : &quot;interests&quot; &#125;,</span><br><span class="line">            &quot;aggs&quot; : &#123;</span><br><span class="line">                &quot;avg_age&quot; : &#123;</span><br><span class="line">                    &quot;avg&quot; : &#123; &quot;field&quot; : &quot;age&quot; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深入搜索"><a href="#深入搜索" class="headerlink" title="深入搜索"></a>深入搜索</h2><h3 id="结构化搜索"><a href="#结构化搜索" class="headerlink" title="结构化搜索"></a>结构化搜索</h3><p><strong>结构化搜索（Structured search）</strong>是指有关探询那些具有内在结构数据的过程。比如日期、时间和数字都是结构化的：它们有精确的格式，我们可以对这些格式进行逻辑操作。比较常见的操作包括比较数字或时间的范围，或判定两个值的大小。</p>
<p>在结构化查询中，我们得到的结果 总是 非是即否，要么存于集合之中，要么存在集合之外。结构化查询不关心文件的相关度或评分；它简单的对文档包括或排除处理。</p>
<h4 id="精确值查找"><a href="#精确值查找" class="headerlink" title="精确值查找"></a>精确值查找</h4><p>当进行精确值查找时， 我们会使用过滤器（filters）。过滤器很重要，因为它们执行速度非常快，不会计算相关度（直接跳过了整个评分阶段）而且很容易被缓存。现在只要记住：请尽可能多的使用过滤式查询。</p>
<h5 id="term-查询"><a href="#term-查询" class="headerlink" title="term 查询"></a>term 查询</h5><p>类似于 <code>SQL</code> 语句中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT document</span><br><span class="line">FROM   products</span><br><span class="line">WHERE  price = 20</span><br></pre></td></tr></table></figure>
<p>最为常用的 <code>term</code> 查询， 可以用它处理数字（numbers）、布尔值（Booleans）、日期（dates）以及文本（text）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT &apos;http://localhost:9200/my_store/products/_bulk&apos; -d &apos;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 10, &quot;productID&quot; : &quot;XHDK-A-1293-#fJ3&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 20, &quot;productID&quot; : &quot;KDKE-B-9947-#kL5&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 3 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 30, &quot;productID&quot; : &quot;JODL-X-1937-#pV7&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 4 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 30, &quot;productID&quot; : &quot;QQPX-R-3956-#aD8&quot; &#125;&apos;</span><br></pre></td></tr></table></figure>
<p>这是通过 <code>_bulk</code> 添加数据的另一种方法</p>
<p>在 Elasticsearch 的查询表达式（query DSL）中，我们可以使用 term 查询达到相同的目的。 term 查询会查找我们指定的精确值。作为其本身， term 查询是简单的。它接受一个字段名以及我们希望查找的数值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_store/products/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;term&quot; : &#123; </span><br><span class="line">            &quot;price&quot; : 20</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>通常当查找一个精确值的时候，我们不希望对查询进行评分计算。只希望对文档进行包括或排除的计算，所以我们会使用 <code>constant_score</code> 将 term 查询转化成为过滤器。查询以非评分模式来执行 <code>term</code> 查询并以一作为统一评分。</p>
<p>最终组合的结果是一个 <code>constant_score</code> 查询，它包含一个 <code>term</code> 查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_store/products/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;constant_score&quot;: &#123;</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;term&quot; : &#123; </span><br><span class="line">                    &quot;price&quot; : 20</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p><strong>term 查询文本</strong></p>
<p>使用如下的查询表达式（query DSL）不会获得查询结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_store/products/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;constant_score&quot;: &#123;</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;term&quot; : &#123; </span><br><span class="line">                    &quot;productID&quot; : &quot;XHDK-A-1293-#fJ3&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>问题不在 <code>term</code> 查询，而在于索引数据的方式。 如果我们使用 <code>analyze</code> API (<a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/analysis-intro.html#analyze-api" target="_blank" rel="noopener">分析 API</a>)，我们可以看到这里的 UPC（Universal Product Code） 码被拆分成多个更小的 token ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_store/_analyze&apos; -d &apos;&#123;</span><br><span class="line">  &quot;field&quot;: &quot;productID&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;XHDK-A-1293-#fJ3&quot;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>得到如下的返回，可以看到 <code>XHDK-A-1293-#fJ3</code> 被分解成了 <code>xhdk</code>、<code>a</code>、<code>1293</code>、<code>fj3</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [ &#123;</span><br><span class="line">    &quot;token&quot; :        &quot;xhdk&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 0,</span><br><span class="line">    &quot;end_offset&quot; :   4,</span><br><span class="line">    &quot;type&quot; :         &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">    &quot;position&quot; :     1</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; :        &quot;a&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 5,</span><br><span class="line">    &quot;end_offset&quot; :   6,</span><br><span class="line">    &quot;type&quot; :         &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">    &quot;position&quot; :     2</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; :        &quot;1293&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 7,</span><br><span class="line">    &quot;end_offset&quot; :   11,</span><br><span class="line">    &quot;type&quot; :         &quot;&lt;NUM&gt;&quot;,</span><br><span class="line">    &quot;position&quot; :     3</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;token&quot; :        &quot;fj3&quot;,</span><br><span class="line">    &quot;start_offset&quot; : 13,</span><br><span class="line">    &quot;end_offset&quot; :   16,</span><br><span class="line">    &quot;type&quot; :         &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">    &quot;position&quot; :     4</span><br><span class="line">  &#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Elasticsearch 用 4 个不同的 token 而不是单个 token 来表示这个 UPC 。</li>
<li>所有字母都是小写的。</li>
<li>丢失了连字符（<code>-</code>）和哈希符（<code>#</code>）。</li>
</ul>
<p>所以当我们用 term 查询查找精确值 <code>XHDK-A-1293-#fJ3</code> 的时候，找不到任何文档，因为它并不在我们的倒排索引中</p>
<p>为了避免这种问题，我们需要告诉 Elasticsearch 该字段具有精确值，要将其设置成 <code>not_analyzed</code> 无需分析的。为了修正搜索结果，我们需要首先删除旧索引（因为它的映射不再正确）然后创建一个能正确映射的新索引:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE &apos;http://localhost:9200/my_store&apos;</span><br><span class="line"></span><br><span class="line">curl -XPUT &apos;http://localhost:9200/my_store&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mappings&quot; : &#123;</span><br><span class="line">        &quot;products&quot; : &#123;</span><br><span class="line">            &quot;properties&quot; : &#123;</span><br><span class="line">                &quot;productID&quot; : &#123;</span><br><span class="line">                    &quot;type&quot; : &quot;string&quot;,</span><br><span class="line">                    &quot;index&quot; : &quot;not_analyzed&quot; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>然后为文档重建索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT &apos;http://localhost:9200/my_store/products/_bulk&apos; -d &apos;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 10, &quot;productID&quot; : &quot;XHDK-A-1293-#fJ3&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 20, &quot;productID&quot; : &quot;KDKE-B-9947-#kL5&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 3 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 30, &quot;productID&quot; : &quot;JODL-X-1937-#pV7&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 4 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 30, &quot;productID&quot; : &quot;QQPX-R-3956-#aD8&quot; &#125;&apos;</span><br></pre></td></tr></table></figure>
<p>此时就可以精确查询到我们需要的结果。</p>
<h4 id="组合过滤器"><a href="#组合过滤器" class="headerlink" title="组合过滤器"></a>组合过滤器</h4><p>类似于 SQL 语句中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT product</span><br><span class="line">FROM   products</span><br><span class="line">WHERE  (price = 20 OR productID = &quot;XHDK-A-1293-#fJ3&quot;)</span><br><span class="line">  AND  (price != 30)</span><br></pre></td></tr></table></figure>
<p>这种情况下，我们需要 <code>bool</code> （布尔）过滤器。</p>
<h5 id="布尔过滤器"><a href="#布尔过滤器" class="headerlink" title="布尔过滤器"></a>布尔过滤器</h5><p>一个 <code>bool</code> 过滤器由三部分组成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;bool&quot; : &#123;</span><br><span class="line">      &quot;must&quot; :     [],</span><br><span class="line">      &quot;should&quot; :   [],</span><br><span class="line">      &quot;must_not&quot; : [],</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>must</code>：所有的语句都 必须（must） 匹配，与 <code>AND</code> 等价。<br><code>must_not</code>：所有的语句都 不能（must not） 匹配，与 <code>NOT</code> 等价。<br><code>should</code>：至少有一个语句要匹配，与 <code>OR</code> 等价。</p>
<p>上面的 SQL 语句解释出来如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_store/products/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">   &quot;query&quot; : &#123;</span><br><span class="line">        &quot;bool&quot; : &#123;</span><br><span class="line">          &quot;should&quot; : [</span><br><span class="line">             &#123; &quot;term&quot; : &#123;&quot;price&quot; : 20&#125;&#125;, </span><br><span class="line">             &#123; &quot;term&quot; : &#123;&quot;productID&quot; : &quot;XHDK-A-1293-#fJ3&quot;&#125;&#125; </span><br><span class="line">          ],</span><br><span class="line">          &quot;must_not&quot; : &#123;</span><br><span class="line">             &quot;term&quot; : &#123;&quot;price&quot; : 30&#125; </span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<p>在 <code>should</code> 语句块里面的两个 <code>term</code> 过滤器与 <code>bool</code> 过滤器是父子关系，两个 <code>term</code> 条件需要匹配其一。</p>
<h5 id="嵌套布尔过滤器"><a href="#嵌套布尔过滤器" class="headerlink" title="嵌套布尔过滤器"></a>嵌套布尔过滤器</h5><p>尽管 <code>bool</code> 是一个复合的过滤器，可以接受多个子过滤器，需要注意的是<code>bool</code> 过滤器本身仍然还只是一个过滤器。 这意味着我们可以将一个 <code>bool</code> 过滤器置于其他 <code>bool</code> 过滤器内部，这为我们提供了对任意复杂布尔逻辑进行处理的能力。</p>
<p>对于以下这个 SQL 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT document</span><br><span class="line">FROM   products</span><br><span class="line">WHERE  productID = &quot;KDKE-B-9947-#kL5&quot;</span><br><span class="line">  OR ( productID = &quot;JODL-X-1937-#pV7&quot; AND price = 30 )</span><br></pre></td></tr></table></figure>
<p>我们将其转换成一组嵌套的 <code>bool</code> 过滤器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_store/products/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">   &quot;query&quot; : &#123;</span><br><span class="line">        &quot;bool&quot; : &#123;</span><br><span class="line">              &quot;should&quot; : [</span><br><span class="line">                &#123; &quot;term&quot; : &#123;&quot;productID&quot; : &quot;KDKE-B-9947-#kL5&quot;&#125;&#125;, </span><br><span class="line">                &#123; &quot;bool&quot; : &#123; </span><br><span class="line">                  &quot;must&quot; : [</span><br><span class="line">                    &#123; &quot;term&quot; : &#123;&quot;productID&quot; : &quot;JODL-X-1937-#pV7&quot;&#125;&#125;, </span><br><span class="line">                    &#123; &quot;term&quot; : &#123;&quot;price&quot; : 30&#125;&#125; </span><br><span class="line">                  ]</span><br><span class="line">                &#125;&#125;</span><br><span class="line">              ]</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h4 id="查找多个精确值"><a href="#查找多个精确值" class="headerlink" title="查找多个精确值"></a>查找多个精确值</h4><p>不需要使用多个 <code>term</code> 查询，我们只要用单个 <code>terms</code> 查询（注意末尾的 s ）， <code>terms</code> 查询好比是 <code>term</code> 查询的复数形式（以英语名词的单复数做比）</p>
<p>与 <code>term</code> 查询一样，也需要将其置入 <code>filter</code> 语句的常量评分查询中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_store/products/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;constant_score&quot; : &#123;</span><br><span class="line">            &quot;filter&quot; : &#123;</span><br><span class="line">                &quot;terms&quot; : &#123; </span><br><span class="line">                    &quot;price&quot; : [20, 30]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>本章到目前为止，对于数字，只介绍如何处理精确值查询。 实际上，对数字范围进行过滤有时会更有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT document</span><br><span class="line">FROM   products</span><br><span class="line">WHERE  price BETWEEN 20 AND 40</span><br></pre></td></tr></table></figure>
<p>range 查询可同时提供包含（inclusive）和不包含（exclusive）这两种范围表达式，可供组合的选项如下：</p>
<p><code>gt</code>: &gt; 大于（greater than）<br><code>lt</code>: &lt; 小于（less than）<br><code>gte</code>: &gt;= 大于或等于（greater than or equal to）<br><code>lte</code>: &lt;= 小于或等于（less than or equal to）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_store/products/_search&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;constant_score&quot; : &#123;</span><br><span class="line">            &quot;filter&quot; : &#123;</span><br><span class="line">                &quot;range&quot; : &#123;</span><br><span class="line">                    &quot;price&quot; : &#123;</span><br><span class="line">                        &quot;gte&quot; : 20,</span><br><span class="line">                        &quot;lte&quot;  : 40</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure>
<h5 id="日期范围"><a href="#日期范围" class="headerlink" title="日期范围"></a>日期范围</h5><p>range 查询同样可以应用在日期字段上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;range&quot; : &#123;</span><br><span class="line">    &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;gt&quot; : &quot;2014-01-01 00:00:00&quot;,</span><br><span class="line">        &quot;lt&quot; : &quot;2014-01-07 00:00:00&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> range 查询支持对 <strong>日期计算（date math）</strong> 进行操作，比方说，如果我们想查找时间戳在过去一小时内的所有文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;range&quot; : &#123;</span><br><span class="line">    &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;gt&quot; : &quot;now-1h&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日期计算还可以被应用到某个具体的时间，并非只能是一个像 <code>now</code> 这样的占位符。只要在某个日期后加上一个双管符号 (<code>||</code>) 并紧跟一个日期数学表达式就能做到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;range&quot; : &#123;</span><br><span class="line">    &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;gt&quot; : &quot;2014-01-01 00:00:00&quot;,</span><br><span class="line">        &quot;lt&quot; : &quot;2014-01-01 00:00:00||+1M&quot; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理-Null-值"><a href="#处理-Null-值" class="headerlink" title="处理 Null 值"></a>处理 Null 值</h4><p>回想在之前例子中，有的文档有名为 tags （标签）的字段，它是个多值字段， 一个文档可能有一个或多个标签，也可能根本就没有标签。<strong>如果一个字段没有值，那么如何将它存入倒排索引</strong>中的呢？</p>
<p>答案是：什么都不存。</p>
<p>一个倒排索引只是一个 token 列表和与之相关的文档信息，如果字段不存在，那么它也不会持有任何 token，也就无法在倒排索引结构中表现。</p>
<p>最终，这也就意味着 ，<strong><code>null</code>, <code>[]</code> （空数组）和 <code>[null]</code> 所有这些都是等价的，它们无法存于倒排索引中。</strong></p>
<p>Elasticsearch 提供了一些工具来处理空或缺失值</p>
<h5 id="存在查询"><a href="#存在查询" class="headerlink" title="存在查询"></a>存在查询</h5><p><code>exists</code> 可以实现存在查询。</p>
<p>在 SQL 语句中，如下的查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT tags</span><br><span class="line">FROM   posts</span><br><span class="line">WHERE  tags IS NOT NULL</span><br></pre></td></tr></table></figure>
<p>可以用 <code>exists</code> 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/posts/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;constant_score&quot; : &#123;</span><br><span class="line">            &quot;filter&quot; : &#123;</span><br><span class="line">                &quot;exists&quot; : &#123; &quot;field&quot; : &quot;tags&quot; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>missing</code> 查询本质上与 <code>exists</code> 恰好相反： 它返回某个特定 <strong>无</strong>值字段的文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT tags</span><br><span class="line">FROM   posts</span><br><span class="line">WHERE  tags IS NULL</span><br></pre></td></tr></table></figure>
<p>的实现方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/posts/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;constant_score&quot; : &#123;</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;missing&quot; : &#123; &quot;field&quot; : &quot;tags&quot; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对象上的存在于缺失"><a href="#对象上的存在于缺失" class="headerlink" title="对象上的存在于缺失"></a>对象上的存在于缺失</h5><p>我们不仅可以检查 <code>name.first</code> 和 <code>name.last</code> 的存在性，也可以检查 <code>name</code> ，不过在 映射 中，如上对象的内部是个扁平的字段与值（field-value）的简单键值结构，类似下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;name.first&quot; : &quot;John&quot;,</span><br><span class="line">   &quot;name.last&quot;  : &quot;Smith&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>name</code> 字段并不真实存在于倒排索引中。</p>
<p>原因是当我们执行下面这个过滤的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;exists&quot; : &#123; &quot;field&quot; : &quot;name&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际执行的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">        &quot;should&quot;: [</span><br><span class="line">            &#123; &quot;exists&quot;: &#123; &quot;field&quot;: &quot;name.first&quot; &#125;&#125;,</span><br><span class="line">            &#123; &quot;exists&quot;: &#123; &quot;field&quot;: &quot;name.last&quot; &#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也就意味着，如果 <code>first</code> 和 <code>last</code> 都是空，那么 <code>name</code> 这个命名空间才会被认为不存在。</p>
<h4 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h4><p>过滤器是如何计算的： 其核心实际是采用一个 bitset 记录与过滤器匹配的文档。Elasticsearch 积极地把这些 bitset 缓存起来以备随后使用。一旦缓存成功，bitset 可以复用<strong>任何 已使用过的相同过滤器，而无需再次计算整个过滤器</strong>。</p>
<p>开发者难以区分有良好表现的缓存以及无用缓存。</p>
<p>为了解决问题，Elasticsearch 会基于使用频次自动缓存查询。如果一个非评分查询在最近的 256 词查询中被使用过（次数取决于查询类型），那么这个查询就会作为缓存的候选。</p>
<h3 id="全文搜索-1"><a href="#全文搜索-1" class="headerlink" title="全文搜索"></a>全文搜索</h3><p>怎样在全文字段中搜索到最相关的文档。</p>
<p>全文搜索两个最重要的方面是：</p>
<p><strong>相关性（Relevance）</strong>：它是评价查询与其结果间的相关程度，并根据这种相关程度对结果排名的一种能力，这种计算方式可以是 TF/IDF 方法、地理位置邻近、模糊相似，或其他的某些算法。</p>
<p><strong>分析（Analysis）</strong>：它是将文本块转换为有区别的、规范化的 token 的一个过程，目的是为了（a）创建倒排索引以及（b）查询倒排索引。</p>
<p>一旦谈论相关性或分析这两个方面的问题时，我们所处的语境是关于<strong>查询（<code>match</code>）</strong>的而不是<strong>过滤（<code>filter</code>）</strong>。</p>
<h4 id="基于词项与基于全文"><a href="#基于词项与基于全文" class="headerlink" title="基于词项与基于全文"></a>基于词项与基于全文</h4><p>文本查询可以划分成两大家族：</p>
<h5 id="基于词项的查询"><a href="#基于词项的查询" class="headerlink" title="基于词项的查询"></a>基于词项的查询</h5><p>如 <code>term</code> 或 <code>fuzzy</code> 这样的底层查询不需要分析阶段，它们对单个词项进行操作。用 <code>term</code> 查询词项 <code>Foo</code> 只要在倒排索引中查找 准确词项 ，并且用 TF/IDF 算法为每个包含该词项的文档计算相关度评分 <code>_score</code> 。</p>
<p>记住 <code>term</code> 查询只对倒排索引的词项精确匹配，这点很重要，它不会对词的多样性进行处理（如， <code>foo</code> 或 <code>FOO</code> ）。</p>
<h5 id="基于全文的查询"><a href="#基于全文的查询" class="headerlink" title="基于全文的查询"></a>基于全文的查询</h5><p>像 <code>match</code> 或 <code>query_string</code> 这样的查询是高层查询，它们了解字段映射的信息：</p>
<ul>
<li>如果查询 日期（date） 或 整数（integer） 字段，它们会将查询字符串分别作为日期或整数对待。</li>
<li>如果查询一个（ not_analyzed ）未分析的精确值字符串字段， 它们会将整个查询字符串作为单个词项对待。</li>
<li>但如果要查询一个（ analyzed ）已分析的全文字段， 它们会先将查询字符串传递到一个合适的分析器，然后生成一个供查询的词项列表。</li>
</ul>
<p><strong>一旦组成了词项列表，这个查询会对每个词项逐一执行底层的查询，再将结果合并，然后为每个文档生成一个最终的相关度评分。</strong></p>
<p>我们很少直接使用基于词项的搜索，通常情况下都是对全文进行查询</p>
<h4 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h4><p>匹配查询 <code>match</code> 是个<strong>核心</strong>查询。无论需要查询什么字段， <code>match</code> 查询都应该会是首选的查询方式。 它是一个高级<strong>全文查询</strong>，这表示它<strong>既能处理全文字段，又能处理精确字段</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//删除已有的索引。</span><br><span class="line">curl -XDELETE &apos;http://localhost:9200/my_index&apos;</span><br><span class="line"></span><br><span class="line">//只为这个索引分配一个主分片</span><br><span class="line">curl -XPUT &apos;http://localhost:9200/my_index&apos; -d &apos;&#123; &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 1 &#125;&#125;&apos;</span><br><span class="line"></span><br><span class="line">curl -XPOST &apos;http://localhost:9200/my_index/my_type/_bulk&apos; -d &apos;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;The quick brown fox&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;The quick brown fox jumps over the lazy dog&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 3 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;The quick brown fox jumps over the quick dog&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 4 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;Brown fox brown dog&quot; &#125;</span><br><span class="line">&apos;</span><br></pre></td></tr></table></figure>
<h5 id="单个词查询"><a href="#单个词查询" class="headerlink" title="单个词查询"></a>单个词查询</h5><p>我们用第一个示例来解释使用 <code>match</code> 查询搜索全文字段中的单个词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_index/my_type/_search?pretty&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &quot;QUICK!&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&apos;</span><br></pre></td></tr></table></figure>
<p>Elasticsearch 执行上面这个 match 查询的步骤是：</p>
<ul>
<li>检查字段类型 ：标题 <code>title</code> 字段是一个 <code>string</code> 类型（ analyzed ）已分析的全文字段，这意味着查询字符串本身也应该被分析。</li>
<li>分析查询字符串 ：将查询的字符串 <code>QUICK!</code> 传入标准分析器中，输出的结果是单个项 <code>quick</code> 。因为只有一个单词项，所以 <code>match</code> 查询执行的是单个底层 <code>term</code> 查询。</li>
<li>查找匹配文档 ：用 <code>term</code> 查询在倒排索引中查找 <code>quick</code> 然后获取一组包含该项的文档，本例的结果是文档：<code>1</code>、<code>2</code> 和 <code>3</code> 。</li>
<li>为每个文档评分 ：用 <code>term</code> 查询计算每个文档相关度评分 <code>_score</code> ，这是种将<strong>词频</strong>（term frequency，即词 <code>quick</code> 在相关文档的 <code>title</code> 字段中出现的频率）和反向文档频率（inverse document frequency，即词 <code>quick</code> 在所有文档的 title 字段中出现的频率），以及字段的长度（即字段越短相关度越高）相结合的计算方式。</li>
</ul>
<h4 id="多词查询"><a href="#多词查询" class="headerlink" title="多词查询"></a>多词查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_index/my_type/_search?pretty&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &quot;BROWN DOG!&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&apos;</span><br></pre></td></tr></table></figure>
<p><code>match</code> 查询必须查找两个词（ <code>[&quot;brown&quot;,&quot;dog&quot;]</code> ），它在内部实际上先执行两次 <code>term</code> 查询，然后将两次查询的结果合并作为最终结果输出。为了做到这点，它将两个 <code>term</code> 查询包入一个 <code>bool</code> 查询中</p>
<h5 id="提高精度"><a href="#提高精度" class="headerlink" title="提高精度"></a>提高精度</h5><p>用 <strong>任意</strong> 查询词项匹配文档可能会导致结果中出现不相关的长尾。 这是种散弹式搜索。可能我们只想搜索包含 <strong>所有</strong> 词项的文档，也就是说，不去匹配 <code>brown OR dog</code> ，而通过匹配 <code>brown AND dog</code> 找到所有文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_index/my_type/_search?pretty&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &#123;      </span><br><span class="line">                &quot;query&quot;:    &quot;BROWN DOG!&quot;,</span><br><span class="line">                &quot;operator&quot;: &quot;and&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&apos;</span><br></pre></td></tr></table></figure>
<h5 id="控制精度"><a href="#控制精度" class="headerlink" title="控制精度"></a>控制精度</h5><p>在 <strong>所有</strong> 与 <strong>任意</strong> 间二选一有点过于非黑即白。 如果用户给定 5 个查询词项，想查找只包含其中 4 个的文档</p>
<p><code>match</code> 查询支持 <code>minimum_should_match</code> 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_index/my_type/_search?pretty&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &quot;quick brown dog&quot;,</span><br><span class="line">        &quot;minimum_should_match&quot;: &quot;75%&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&apos;</span><br></pre></td></tr></table></figure>
<p>除此以外 <code>minimum_should_match</code> 还有很多种写法，具体可以产考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/query-dsl-minimum-should-match.html#query-dsl-minimum-should-match" target="_blank" rel="noopener">Query DSL » Minimum Should Match</a></p>
<h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><p>在 组合过滤器 中，我们讨论过如何使用 <code>bool</code> 过滤器通过 <code>and</code> 、 <code>or</code> 和 <code>not</code> 逻辑组合将多个过滤器进行组合。在查询中， <code>bool</code> 查询有类似的功能，只有一个重要的区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &apos;http://localhost:9200/my_index/my_type/_search?pretty&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;:     &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;quick&quot; &#125;&#125;,</span><br><span class="line">      &quot;must_not&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;lazy&quot;  &#125;&#125;,</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">                  &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;brown&quot; &#125;&#125;,</span><br><span class="line">                  &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;dog&quot;   &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&apos;</span><br></pre></td></tr></table></figure>
<p>以上的查询结果返回 <code>title</code> 字段包含词项 <code>quick</code> 但不包含 <code>lazy</code> 的任意文档。目前为止，这与 <code>bool</code> 过滤器的工作方式非常相似。</p>
<p>区别就在于两个 <code>should</code> 语句，也就是说：一个文档不必包含 <code>brown</code> 或 <code>dog</code> 这两个词项，但如果一旦包含，我们就认为它们 更相关 </p>
<h5 id="评分计算"><a href="#评分计算" class="headerlink" title="评分计算"></a>评分计算</h5><p><code>bool</code> 查询会为每个文档计算相关度评分 <code>_score</code> ， 再将所有匹配的 <code>must</code> 和 <code>should</code> 语句的分数 <code>_score</code> 求和，最后除以 <code>must</code> 和 <code>should</code> 语句的总数。</p>
<p><code>must_not</code> 语句不会影响评分；它的作用只是将不相关的文档排除。</p>
<h5 id="控制精度-1"><a href="#控制精度-1" class="headerlink" title="控制精度"></a>控制精度</h5><p>所有 <code>must</code> 语句必须匹配，所有 <code>must_not</code> 语句都必须不匹配，但有多少 <code>should</code> 语句应该匹配呢？ 默认情况下，没有 <code>should</code> 语句是必须匹配的，只有一个例外：那就是当没有 <code>must</code> 语句的时候，至少有一个 <code>should</code> 语句必须匹配。</p>
<p>就像我们能控制 <code>match</code> 查询的精度 一样，我们可以通过 <code>minimum_should_match</code> 参数控制需要匹配的 <code>should</code> 语句的数量， 它既可以是一个绝对的数字，又可以是个百分比：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;brown&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;fox&quot;   &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;dog&quot;   &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;minimum_should_match&quot;: 2 </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询语句提升权重"><a href="#查询语句提升权重" class="headerlink" title="查询语句提升权重"></a>查询语句提升权重</h4><p><code>should</code> 语句匹配得越多表示文档的相关度越高。目前为止还挺好。</p>
<p>但是如果我们想让包含 <code>Lucene</code> 的有更高的权重，并且包含 <code>Elasticsearch</code> 的语句比 <code>Lucene</code> 的权重更高，该如何处理?</p>
<p>我们可以通过指定 <code>boost</code> 来控制任何查询语句的相对的权重， <code>boost</code> 的默认值为 1 ，大于 1 会提升一个语句的相对权重。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot;: &#123;  </span><br><span class="line">                    &quot;content&quot;: &#123;</span><br><span class="line">                        &quot;query&quot;:    &quot;full text search&quot;,</span><br><span class="line">                        &quot;operator&quot;: &quot;and&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;should&quot;: [</span><br><span class="line">                &#123; &quot;match&quot;: &#123;</span><br><span class="line">                    &quot;content&quot;: &#123;</span><br><span class="line">                        &quot;query&quot;: &quot;Elasticsearch&quot;,</span><br><span class="line">                        &quot;boost&quot;: 3 </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;,</span><br><span class="line">                &#123; &quot;match&quot;: &#123;</span><br><span class="line">                    &quot;content&quot;: &#123;</span><br><span class="line">                        &quot;query&quot;: &quot;Lucene&quot;,</span><br><span class="line">                        &quot;boost&quot;: 2 </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多字段搜索"><a href="#多字段搜索" class="headerlink" title="多字段搜索"></a>多字段搜索</h3><p>查询很少是简单一句话的 <code>match</code> 匹配查询。通常我们需要用相同或不同的字符串查询一个或多个字段，也就是说，需要对多个查询语句以及它们相关度评分进行合理的合并。</p>
<h4 id="多字符串查询"><a href="#多字符串查询" class="headerlink" title="多字符串查询"></a>多字符串查询</h4><p>最简单的多字段查询可以将搜索项映射到具体的字段。 如果我们知道 War and Peace 是标题，Leo Tolstoy 是作者，很容易就能把两个条件用 match 语句表示， 并将它们用 <code>bool</code> 查询 组合起来，当然，并不是只能使用 match 语句：可以用 bool 查询来包裹组合任意其他类型的查询， 甚至包括其他的 bool 查询。我们可以添加一条语句来指定译者版本的偏好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;:  &quot;War and Peace&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;author&quot;: &quot;Leo Tolstoy&quot;   &#125;&#125;,</span><br><span class="line">        &#123; &quot;bool&quot;:  &#123;</span><br><span class="line">          &quot;should&quot;: [</span><br><span class="line">            &#123; &quot;match&quot;: &#123; &quot;translator&quot;: &quot;Constance Garnett&quot; &#125;&#125;,</span><br><span class="line">            &#123; &quot;match&quot;: &#123; &quot;translator&quot;: &quot;Louise Maude&quot;      &#125;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么将译者条件语句放入另一个独立的 bool 查询中呢？所有的四个 match 查询都是 should 语句，所以为什么不将 translator 语句与其他如 title 、 author 这样的语句放在同一层呢？</p>
<p>答案在于评分的计算方式。含 <code>translator</code> 语句的 <code>bool</code> 查询，只占总评分的三分之一。如果将 <code>translator</code> 语句与 <code>title</code> 和 <code>author</code> 两条语句放入同一层，那么 <code>title</code> 和 <code>author</code> 语句只贡献四分之一评分。</p>
<h5 id="语句的优先级"><a href="#语句的优先级" class="headerlink" title="语句的优先级"></a>语句的优先级</h5><p>为了提升 <code>title</code> 和 <code>author</code> 字段的权重， 为它们分配的 <code>boost</code> 值大于 1 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; </span><br><span class="line">            &quot;title&quot;:  &#123;</span><br><span class="line">              &quot;query&quot;: &quot;War and Peace&quot;,</span><br><span class="line">              &quot;boost&quot;: 2</span><br><span class="line">        &#125;&#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; </span><br><span class="line">            &quot;author&quot;:  &#123;</span><br><span class="line">              &quot;query&quot;: &quot;Leo Tolstoy&quot;,</span><br><span class="line">              &quot;boost&quot;: 2</span><br><span class="line">        &#125;&#125;&#125;,</span><br><span class="line">        &#123; &quot;bool&quot;:  &#123; </span><br><span class="line">            &quot;should&quot;: [</span><br><span class="line">              &#123; &quot;match&quot;: &#123; &quot;translator&quot;: &quot;Constance Garnett&quot; &#125;&#125;,</span><br><span class="line">              &#123; &quot;match&quot;: &#123; &quot;translator&quot;: &quot;Louise Maude&quot;      &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单字符串查询"><a href="#单字符串查询" class="headerlink" title="单字符串查询"></a>单字符串查询</h4><p>有些用户期望将所有的搜索项堆积到单个字段中，并期望应用程序能为他们提供正确的结果。</p>
<p>对于<strong>多词（multiword）、多字段（multifield）查询来说，不存在简单的 万能 方案。为了获得最好结果，需要 了解我们的数据 ，并了解如何使用合适的工具。</strong></p>
<h4 id="最佳字段"><a href="#最佳字段" class="headerlink" title="最佳字段"></a>最佳字段</h4><p>下面两篇博客内容文档为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;: &quot;Quick brown rabbits&quot;,</span><br><span class="line">    &quot;body&quot;:  &quot;Brown rabbits are commonly seen.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;: &quot;Keeping pets healthy&quot;,</span><br><span class="line">    &quot;body&quot;:  &quot;My quick brown fox eats rabbits on a regular basis.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在运行以下 <code>bool</code> 查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;should&quot;: [</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Brown fox&quot; &#125;&#125;,</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;body&quot;:  &quot;Brown fox&quot; &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用肉眼判断，文档 2 的匹配度更高</p>
<p>我们发现查询的结果是文档 1 的评分更高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  &quot;hits&quot;: [</span><br><span class="line">     &#123;</span><br><span class="line">        &quot;_id&quot;:      &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;:   0.14809652,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">           &quot;title&quot;: &quot;Quick brown rabbits&quot;,</span><br><span class="line">           &quot;body&quot;:  &quot;Brown rabbits are commonly seen.&quot;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">        &quot;_id&quot;:      &quot;2&quot;,</span><br><span class="line">        &quot;_score&quot;:   0.09256032,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">           &quot;title&quot;: &quot;Keeping pets healthy&quot;,</span><br><span class="line">           &quot;body&quot;:  &quot;My quick brown fox eats rabbits on a regular basis.&quot;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回想一下 bool 是如何计算评分的：</p>
<ol>
<li>它会执行 should 语句中的两个查询。</li>
<li>加和两个查询的评分。</li>
<li>乘以匹配语句的总数。</li>
<li>除以所有语句总数（这里为：2）。</li>
</ol>
<p>在本例中， <code>title</code> 和 <code>body</code> 字段是相互竞争的关系，所以就需要找到单个 <strong>最佳匹配</strong> 的字段</p>
<h5 id="dis-max-查询"><a href="#dis-max-查询" class="headerlink" title="dis_max 查询"></a>dis_max 查询</h5><p>将任何与任一查询匹配的文档作为结果返回，但只将<strong>最佳匹配的评分作为查询的评分结果</strong>返回 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;dis_max&quot;: &#123;</span><br><span class="line">            &quot;queries&quot;: [</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Brown fox&quot; &#125;&#125;,</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;body&quot;:  &quot;Brown fox&quot; &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="最佳字段查询调优"><a href="#最佳字段查询调优" class="headerlink" title="最佳字段查询调优"></a>最佳字段查询调优</h5><p>因为使用 <code>dis_max</code> 的时候，只会将其中最佳匹配的份数作为总体的分数，但是在如下的情况下：两个文档中都不具有同时包含 <strong>两个词</strong> 的 <strong>相同字段</strong> 。则分数一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;dis_max&quot;: &#123;</span><br><span class="line">            &quot;queries&quot;: [</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Quick pets&quot; &#125;&#125;,</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;body&quot;:  &quot;Quick pets&quot; &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;hits&quot;: [</span><br><span class="line">     &#123;</span><br><span class="line">        &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot;: 0.12713557, </span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">           &quot;title&quot;: &quot;Quick brown rabbits&quot;,</span><br><span class="line">           &quot;body&quot;: &quot;Brown rabbits are commonly seen.&quot;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">        &quot;_id&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;_score&quot;: 0.12713557, </span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">           &quot;title&quot;: &quot;Keeping pets healthy&quot;,</span><br><span class="line">           &quot;body&quot;: &quot;My quick brown fox eats rabbits on a regular basis.&quot;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是肉眼观察，第二个的分数应该比第一个高。</p>
<h5 id="tie-breaker-参数"><a href="#tie-breaker-参数" class="headerlink" title="tie_breaker 参数"></a>tie_breaker 参数</h5><p>可以通过指定 <code>tie_breaker</code> 这个参数将其他匹配语句的评分也考虑其中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;dis_max&quot;: &#123;</span><br><span class="line">            &quot;queries&quot;: [</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Quick pets&quot; &#125;&#125;,</span><br><span class="line">                &#123; &quot;match&quot;: &#123; &quot;body&quot;:  &quot;Quick pets&quot; &#125;&#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;tie_breaker&quot;: 0.3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tie_breaker`</code> 参数提供了一种 <code>dis_max</code> 和 <code>bool</code> 之间的折中选择，它的评分方式如下：</p>
<ol>
<li>获得最佳匹配语句的评分 _score 。</li>
<li>将其他匹配语句的评分结果与 tie_breaker 相乘。</li>
<li>对以上评分求和并规范化。</li>
</ol>
<p>有了 <code>tie_breaker</code> ，会考虑所有匹配语句，但<strong>最佳匹配语句依然占最终结果里的很大</strong>一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tie_breaker 可以是 0 到 1 之间的浮点数，其中 0 代表使用 dis_max 最佳匹配语句的普通逻辑， 1 表示所有匹配语句同等重要。最佳的精确值需要根据数据与查询调试得出，但是合理值应该与零接近（处于 0.1 - 0.4 之间），这样就不会颠覆 dis_max 最佳匹配性质的根本。</span><br></pre></td></tr></table></figure>
<h4 id="multi-match-查询"><a href="#multi-match-查询" class="headerlink" title="multi_match 查询"></a>multi_match 查询</h4><p><code>multi_match</code> 查询为能在多个字段上反复执行相同查询提供了一种便捷方式。</p>
<p><code>multi_match</code> 多匹配查询的类型有多种，其中的三种恰巧与 了解我们的数据 中介绍的三个场景对应，即： <code>best_fields</code> 、 <code>most_fields</code> 和 <code>cross_fields</code> （最佳字段、多数字段、跨字段）。</p>
<p>默认情况下，查询的类型是 <code>best_fields</code> ，它会为每个字段生成一个 <code>match</code> 查询，然后将它们组合到 <code>dis_max</code> 查询的内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">        &quot;query&quot;:                &quot;Quick brown fox&quot;,</span><br><span class="line">        &quot;type&quot;:                 &quot;best_fields&quot;, </span><br><span class="line">        &quot;fields&quot;:               [ &quot;title&quot;, &quot;body&quot; ],</span><br><span class="line">        &quot;tie_breaker&quot;:          0.3,</span><br><span class="line">        &quot;minimum_should_match&quot;: &quot;30%&quot; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  &quot;dis_max&quot;: &#123;</span><br><span class="line">    &quot;queries&quot;:  [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &quot;Quick brown fox&quot;,</span><br><span class="line">            &quot;minimum_should_match&quot;: &quot;30%&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;body&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &quot;Quick brown fox&quot;,</span><br><span class="line">            &quot;minimum_should_match&quot;: &quot;30%&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    &quot;tie_breaker&quot;: 0.3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="查询字段名称的模糊匹配"><a href="#查询字段名称的模糊匹配" class="headerlink" title="查询字段名称的模糊匹配"></a>查询字段名称的模糊匹配</h5><p>匹配结尾为 <code>_title</code> 的字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">        &quot;query&quot;:  &quot;Quick brown fox&quot;,</span><br><span class="line">        &quot;fields&quot;: &quot;*_title&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="提升单个字段的权重"><a href="#提升单个字段的权重" class="headerlink" title="提升单个字段的权重"></a>提升单个字段的权重</h5><p>可以使用<code>^</code> 字符语法为单个字段提升权重，在字段名称的末尾添加 <code>^boost</code> ， 其中 <code>boost</code> 是一个浮点数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">        &quot;query&quot;:  &quot;Quick brown fox&quot;,</span><br><span class="line">        &quot;fields&quot;: [ &quot;*_title&quot;, &quot;chapter_title^2&quot; ] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多数字段"><a href="#多数字段" class="headerlink" title="多数字段"></a>多数字段</h4><p>召回率（返回结果中的所有文档都是相关的）：扩大搜索范围 ——不仅返回与用户搜索词精确匹配的文档，还会返回我们认为与查询相关的所有文档。如果一个用户搜索 <code>quick brown fox</code> ，一个包含词语 <code>fast foxes</code> 的文档被认为是非常合理的返回结果。</p>
<h5 id="多字段映射"><a href="#多字段映射" class="headerlink" title="多字段映射"></a>多字段映射</h5><p>首先要做的事情就是对我们的字段索引两次： 一次使用词干模式以及一次非词干模式。</p>
<p><code>title</code> 字段使用 <code>english</code> 英语分析器来提取词干。用来扩大匹配的范围。</p>
<p><code>title.std</code> 字段使用 <code>standard</code> 标准分析器，所以没有词干提取。用来进行精确匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DELETE /my_index</span><br><span class="line"></span><br><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 1 &#125;, </span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;my_type&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">                &quot;title&quot;: &#123; </span><br><span class="line">                    &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">                    &quot;analyzer&quot;: &quot;english&quot;,</span><br><span class="line">                    &quot;fields&quot;: &#123;</span><br><span class="line">                        &quot;std&quot;:   &#123; </span><br><span class="line">                            &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">                            &quot;analyzer&quot;: &quot;standard&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123; &quot;title&quot;: &quot;My rabbit jumps&quot; &#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/2</span><br><span class="line">&#123; &quot;title&quot;: &quot;Jumping jack rabbits&quot; &#125;</span><br></pre></td></tr></table></figure>
<p>我们希望将所有匹配字段的评分合并起来，所以使用 <code>most_fields</code> 类型。这让 <code>multi_match</code> 查询用 <code>bool</code> 查询将两个字段语句包在里面，而不是使用 <code>dis_max</code> 查询。</p>
<p>每个字段对于最终评分的贡献可以通过自定义值 <code>boost</code> 来控制。比如，使 <code>title</code> 字段更为重要，这样同时也降低了其他信号字段的作用：</p>
<p>用广度匹配字段 <code>title</code> 包括尽可能多的文档——以提升召回率——同时又使用字段 <code>title.std</code> 作为<strong>信号</strong>将相关度更高的文档置于结果顶部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;query&quot;: &#123;</span><br><span class="line">        &quot;multi_match&quot;: &#123;</span><br><span class="line">            &quot;query&quot;:       &quot;jumping rabbits&quot;,</span><br><span class="line">            &quot;type&quot;:        &quot;most_fields&quot;,</span><br><span class="line">            &quot;fields&quot;:      [ &quot;title^10&quot;, &quot;title.std&quot; ] </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="跨字段实体搜索"><a href="#跨字段实体搜索" class="headerlink" title="跨字段实体搜索"></a>跨字段实体搜索</h4><p>采用 <code>multi_match</code> 查询， 将 <code>type</code>设置成<code>most_fields</code> 然后告诉 Elasticsearch 合并所有匹配字段的评分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;:       &quot;Poland Street W1V&quot;,</span><br><span class="line">      &quot;type&quot;:        &quot;most_fields&quot;,</span><br><span class="line">      &quot;fields&quot;:      [ &quot;street&quot;, &quot;city&quot;, &quot;country&quot;, &quot;postcode&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="most-fields-方式的问题"><a href="#most-fields-方式的问题" class="headerlink" title="most_fields 方式的问题"></a>most_fields 方式的问题</h5><p>用<code>most_fields</code> 这种方式搜索也存在某些问题，这些问题并不会马上显现：</p>
<ol>
<li>它是为多数字段匹配 任意 词设计的，而不是在 所有字段 中找到最匹配的。</li>
<li>它不能使用 <code>operator</code> 或 <code>minimum_should_match</code> 参数来降低次相关结果造成的长尾效应。</li>
<li>词频对于每个字段是不一样的，而且它们之间的相互影响会导致不好的排序结果。</li>
</ol>
<h5 id="字段中心式查询"><a href="#字段中心式查询" class="headerlink" title="字段中心式查询"></a>字段中心式查询</h5><p><code>most_fields</code> 和 <code>best_fields</code> 两个被查询字段都与一个 field 匹配的文档要比一个字段同时匹配两个field 文档的评分高。</p>
<h4 id="cross-fields-跨字段查询"><a href="#cross-fields-跨字段查询" class="headerlink" title="cross-fields 跨字段查询"></a>cross-fields 跨字段查询</h4><p>使用 <code>cross_fields</code> 类型进行 <code>multi_match</code>查询。 <code>cross_fields</code> 使用词中心式（<code>term-centric</code>）的查询方式，这与 <code>best_fields</code> 和 <code>most_fields</code> 使用字段中心式（<code>field-centric</code>）的查询方式非常不同，它将所有字段当成一个大字段，并在 <strong>每个字段</strong> 中查找 <strong>每个词</strong> 。</p>
<p><strong>字段中心式 </strong>会使用以下逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(+first_name:peter +first_name:smith)</span><br><span class="line">(+last_name:peter  +last_name:smith)</span><br></pre></td></tr></table></figure>
<p><strong>词中心式 </strong>会使用以下逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+(first_name:peter last_name:peter)</span><br><span class="line">+(first_name:smith last_name:smith)</span><br></pre></td></tr></table></figure>
<p>换句话说，词 peter 和 smith 都必须出现，但是可以出现在任意字段中。</p>
<h3 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h3><p><code>match</code> 查询可以告知我们这大袋子中是否包含查询的词条，但却无法告知词语之间的关系。不能确定这词是否只来自于一种语境，甚至都不能确定是否来自于同一个段落。</p>
<p>我们可能会希望得到尽可能包含这词的文档，但我们也同样需要这些<strong>文档与分词有很高的相关度</strong>。</p>
<p>这就是短语匹配或者近似匹配的所属领域。</p>
<h4 id="短语匹配"><a href="#短语匹配" class="headerlink" title="短语匹配"></a>短语匹配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_phrase&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &quot;quick brown fox&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个被认定为和短语 quick brown fox 匹配的文档，必须满足以下这些要求：</p>
<ol>
<li>quick 、 brown 和 fox 需要全部出现在域中。</li>
<li>brown 的位置应该比 quick 的位置大 1 。</li>
<li>fox 的位置应该比 quick 的位置大 2 。</li>
</ol>
<p>如果以上任何一个选项不成立，则该文档不能认定为匹配</p>
<h4 id="混合起来"><a href="#混合起来" class="headerlink" title="混合起来"></a>混合起来</h4><p>精确短语匹配 或许是过于严格了。也许我们想要包含 “quick brown fox” 的文档也能够匹配 “quick fox,” ， 尽管情形不完全相同。</p>
<p>我们能够通过使用 <code>slop</code> 参数将灵活度引入短语匹配中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_phrase&quot;: &#123;</span><br><span class="line">            &quot;title&quot;: &#123;</span><br><span class="line">                &quot;query&quot;: &quot;quick fox&quot;,</span><br><span class="line">                &quot;slop&quot;:  1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>slop</code> 参数告诉 <code>match_phrase</code> 查询词条相隔多远时仍然能将文档视为匹配 。<strong>如果找到了多条匹配结构，则匹配结果的评分中，如果两个词的距离越近，则评分越高。</strong></p>
<h4 id="多值字段"><a href="#多值字段" class="headerlink" title="多值字段"></a>多值字段</h4><p>对多值字段使用短语匹配时会发生奇怪的事。 想象一下你索引这个文档:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/groups/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;names&quot;: [ &quot;John Abraham&quot;, &quot;Lincoln Smith&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行一个对 Abraham Lincoln 的短语查询:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/groups/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match_phrase&quot;: &#123;</span><br><span class="line">            &quot;names&quot;: &quot;Abraham Lincoln&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>令人惊讶的是， 即使 Abraham 和 Lincoln 在 names 数组里属于两个不同的人名， 我们的文档也匹配了查询。</p>
<p>幸运的是， 在这样的情况下有一种叫做 <code>position_increment_gap</code> 的简单的解决方案， 它在字段映射中配置 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//首先删除映射 groups 以及这个类型内的所有文档。</span><br><span class="line">DELETE /my_index/groups/ </span><br><span class="line">//然后创建一个有正确值的新的映射 groups 。</span><br><span class="line">PUT /my_index/_mapping/groups </span><br><span class="line">&#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;names&quot;: &#123;</span><br><span class="line">            &quot;type&quot;:                &quot;string&quot;,</span><br><span class="line">            &quot;position_increment_gap&quot;: 100</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会产生如下的结果：</p>
<ol>
<li>Position 1: john</li>
<li>Position 2: abraham</li>
<li>Position 103: lincoln</li>
<li>Position 104: smith</li>
</ol>
<p>现在我们的短语查询可能无法匹配该文档因为 abraham 和 lincoln 之间的距离为 100 。 为了匹配这个文档你必须添加值为 100 的 <code>slop</code> 。</p>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>短语查询和邻近查询都比简单的 <code>query</code> 查询代价更高 。 一个 <code>match</code> 查询仅仅是看词条是否存在于倒排索引中，而一个 <code>match_phrase</code> 查询是必须计算并比较多个可能重复词项的位置。</p>
<h5 id="结果集重新评分"><a href="#结果集重新评分" class="headerlink" title="结果集重新评分"></a>结果集重新评分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;  </span><br><span class="line">            &quot;title&quot;: &#123;</span><br><span class="line">                &quot;query&quot;:                &quot;quick brown fox&quot;,</span><br><span class="line">                &quot;minimum_should_match&quot;: &quot;30%&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 先进行一次搜索排序，把所有包含词的文档都提取出来，然后对前 50 个结果进行评分排序。来减少 match_phrase 的操作时间。</span><br><span class="line">    &quot;rescore&quot;: &#123;</span><br><span class="line">        &quot;window_size&quot;: 50, </span><br><span class="line">        &quot;query&quot;: &#123;         </span><br><span class="line">            &quot;rescore_query&quot;: &#123;</span><br><span class="line">                &quot;match_phrase&quot;: &#123;</span><br><span class="line">                    &quot;title&quot;: &#123;</span><br><span class="line">                        &quot;query&quot;: &quot;quick brown fox&quot;,</span><br><span class="line">                        &quot;slop&quot;:  50</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="寻找相关词"><a href="#寻找相关词" class="headerlink" title="寻找相关词"></a>寻找相关词</h4><p>两个子句 <code>I’m not happy I’m working</code> 和 <code>I’m happy I’m not working</code> 包含相同 的单词，也拥有相同的邻近度，但含义截然不同。</p>
<p>如果索引单词对而不是索引独立的单词，就能对这些单词的上下文尽可能多的保留。</p>
<p>对句子 <code>Sue ate the alligator</code> ，不仅要将每一个单词（或者 unigram ）作为词项索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;sue&quot;, &quot;ate&quot;, &quot;the&quot;, &quot;alligator&quot;]</span><br></pre></td></tr></table></figure>
<p>也要将每个单词 以及它的邻近词 作为单个词项索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;sue ate&quot;, &quot;ate the&quot;, &quot;the alligator&quot;]</span><br></pre></td></tr></table></figure>
<p>这些单词对（或者 bigrams ）被称为 <code>shingles</code> 。</p>
<p>查看<a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/shingles.html" target="_blank" rel="noopener">寻找相关词</a>来学习如何创建 <code>shingles</code> 以及如何使用。</p>
<p><code>shingles</code>不仅比短语查询更灵活， 而且性能也更好。 <code>shingles</code> 查询跟一个简单的 <code>match</code> 查询一样高效，而不用每次搜索花费短语查询的代价。只是在索引期间因为更多词项需要被索引会付出一些小的代价， 这也意味着有 <code>shingles</code>的字段会占用更多的磁盘空间。 然而，大多数应用写入一次而读取多次，所以在索引期间优化我们的查询速度是有意义的。</p>
<h3 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h3><p>但如果想匹配部分而不是全部的词该怎么办？ <strong>部分匹配</strong> 允许用户指定查找词的一部分并找出所有包含这部分片段的词。</p>
<h4 id="prefix-前缀查询"><a href="#prefix-前缀查询" class="headerlink" title="prefix 前缀查询"></a>prefix 前缀查询</h4><p>为了找到所有以 <code>W1</code> 开始的邮编，可以使用简单的 <code>prefix</code> 查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/address/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;prefix&quot;: &#123;</span><br><span class="line">            &quot;postcode&quot;: &quot;W1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>prefix</code> 查询是一个词级别的底层的查询，它不会在搜索之前分析查询字符串，它假定传入前缀就正是要查找的前缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认状态下， prefix 查询不做相关度评分计算，它只是将所有匹配的文档返回，并为每条结果赋予评分值 1 。它的行为更像是过滤器而不是查询。 prefix 查询和 prefix 过滤器这两者实际的区别就是过滤器是可以被缓存的，而查询不行。</span><br></pre></td></tr></table></figure>
<p>为了支持前缀匹配，查询会做以下事情：</p>
<ol>
<li>扫描词列表并查找到第一个以 <code>W1</code> 开始的词。</li>
<li>搜集关联的文档 ID 。</li>
<li>移动到下一个词。</li>
<li>如果这个词也是以 <code>W1</code> 开头，查询跳回到第二步再重复执行，直到下一个词不以<code>W1</code> 为止。</li>
</ol>
<p>也就是顺序匹配，非常耗时。</p>
<h4 id="通配符与正则表达式查询"><a href="#通配符与正则表达式查询" class="headerlink" title="通配符与正则表达式查询"></a>通配符与正则表达式查询</h4><p> <code>wildcard</code> 通配符查询也是一种底层基于词的查询， 与前缀查询不同的是它允许指定匹配的正则式。它使用标准的 shell 通配符查询： <code>?</code> 匹配任意字符， <code>*</code> 匹配 0 或多个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/address/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;wildcard&quot;: &#123;</span><br><span class="line">            &quot;postcode&quot;: &quot;W?F*HW&quot; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>regexp 正则式查询允许写出更复杂的模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/address/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;regexp&quot;: &#123;</span><br><span class="line">            &quot;postcode&quot;: &quot;W[0-9].+&quot; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>wildcard</code> 和 <code>regexp</code> 查询的工作方式与 <code>prefix</code> 查询完全一样，它们也需要扫描倒排索引中的词列表才能找到所有匹配的词，然后依次获取每个词相关的文档 ID ，与 <code>prefix</code> 查询的唯一不同是：它们能支持更为复杂的匹配模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefix 、 wildcard 和 regexp 查询是基于词操作的，如果用它们来查询 analyzed 字段，它们会检查字段里面的每个词，而不是将字段作为整体来处理。</span><br></pre></td></tr></table></figure>
<h4 id="查询时输入即搜索"><a href="#查询时输入即搜索" class="headerlink" title="查询时输入即搜索"></a>查询时输入即搜索</h4><p>用户已经渐渐习惯在输完查询内容之前，就能为他们展现搜索结果，这就是所谓的 即时搜索（instant search） 或 输入即搜索（search-as-you-type） 。不仅用户能在更短的时间内得到搜索结果，我们也能引导用户搜索索引中真实存在的结果。</p>
<p>例如，如果用户输入 <code>johnnie walker bl</code> ，我们希望在它们完成输入搜索条件前就能得到：Johnnie Walker Black Label 和 Johnnie Walker Blue Label 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;match_phrase_prefix&quot; : &#123;</span><br><span class="line">        &quot;brand&quot; : &quot;johnnie walker bl&quot;,</span><br><span class="line">        &quot;slop&quot;:  10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种查询的行为与 <code>match_phrase</code> 查询一致，不同的是它将查询字符串的最后一个词作为前缀使用，换句话说，可以将之前的例子看成如下这样：</p>
<ol>
<li>johnnie</li>
<li>跟着 walker</li>
<li>跟着以 bl 开始的词</li>
</ol>
<p>可以通过设置 max_expansions 参数来限制前缀扩展的影响， 一个合理的值是可能是 50 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;match_phrase_prefix&quot; : &#123;</span><br><span class="line">        &quot;brand&quot; : &#123;</span><br><span class="line">            &quot;query&quot;:          &quot;johnnie walker bl&quot;,</span><br><span class="line">            &quot;max_expansions&quot;: 50</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数 <code>max_expansions</code> 控制着可以与前缀匹配的词的数量，它会先查找第一个与前缀 <code>bl</code> 匹配的词，然后依次查找搜集与之匹配的词（按字母顺序），直到没有更多可匹配的词或当数量超过 <code>max_expansions</code> 时结束。</p>
<p>不要忘记，当用户每多输入一个字符时，这个查询又会执行一遍，所以查询需要快，如果第一个结果集不是用户想要的，他们会继续输入直到能搜出满意的结果为止。</p>
<h4 id="Ngrams-在部分匹配的应用"><a href="#Ngrams-在部分匹配的应用" class="headerlink" title="Ngrams 在部分匹配的应用"></a>Ngrams 在部分匹配的应用</h4><p>但单个词的查找 确实 要比在词列表中盲目挨个查找的效率要高得多。 在搜索之前准备好供部分匹配的数据可以提高搜索的性能。但是会消耗存储的空间。</p>
<p>在索引时准备数据意味着要选择合适的分析链，这里部分匹配使用的工具是 <code>n-gram</code> 。可以将 <code>n-gram</code> 看成一个在词语上 滑动窗口 ， n 代表这个 “窗口” 的长度。如果我们要 <code>n-gram</code> quick 这个词 —— 它的结果取决于 n 的选择长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">长度 1（unigram）： [ q, u, i, c, k ]</span><br><span class="line">长度 2（bigram）： [ qu, ui, ic, ck ]</span><br><span class="line">长度 3（trigram）： [ qui, uic, ick ]</span><br><span class="line">长度 4（four-gram）： [ quic, uick ]</span><br><span class="line">长度 5（five-gram）： [ quick ]</span><br></pre></td></tr></table></figure>
<p>朴素的 <code>n-gram</code> 对 词语内部的匹配 非常有用，即在 Ngram 匹配复合词 介绍的那样。但对于输入即搜索（search-as-you-type）这种应用场景，我们会使用一种特殊的 <code>n-gram</code> 称为 <code>边界 n-grams （edge n-grams）</code>。所谓的<code>边界 n-gram</code> 是说它会固定词语开始的一边，以单词 <code>quick</code>为例，它的边界 n-gram 的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q</span><br><span class="line">qu</span><br><span class="line">qui</span><br><span class="line">quic</span><br><span class="line">quick</span><br></pre></td></tr></table></figure>
<h5 id="索引时输入即搜索"><a href="#索引时输入即搜索" class="headerlink" title="索引时输入即搜索"></a>索引时输入即搜索</h5><p>如何使用 <code>-gram</code> 可以参考<a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/_index_time_search_as_you_type.html" target="_blank" rel="noopener"><br>索引时输入即搜索</a></p>
<h3 id="处理人类语言"><a href="#处理人类语言" class="headerlink" title="处理人类语言"></a>处理人类语言</h3><h4 id="使用语言分析器"><a href="#使用语言分析器" class="headerlink" title="使用语言分析器"></a>使用语言分析器</h4><p>可以在字段映射中将语言分析器直接指定在某字段上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;blog&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;title&quot;: &#123;</span><br><span class="line">          &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;english&quot; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以每一份文档，每一个域一种语言，或者使用混合语言。</p>
<h4 id="词汇识别"><a href="#词汇识别" class="headerlink" title="词汇识别"></a>词汇识别</h4><p>需要把合并词拆成词组。</p>
<h4 id="归一化词元"><a href="#归一化词元" class="headerlink" title="归一化词元"></a>归一化词元</h4><p>我们还需要去掉有意义的差别, 让 <code>esta</code>、<code>ésta</code> 和 <code>está</code> 都能用同一个词元(token)来搜索。</p>
<h4 id="同义词"><a href="#同义词" class="headerlink" title="同义词"></a>同义词</h4><p>同义词扩大了一个匹配文件的范围。正如 词干提取 或者 部分匹配 ，同义词的字段不应该被单独使用，而应该与一个针对主字段的查询操作一起使用，这个主字段应该包含纯净格式的原始文本。 在使用同义词时，参阅 多数字段 的解释来维护相关性。</p>
<h4 id="拼写错误"><a href="#拼写错误" class="headerlink" title="拼写错误"></a>拼写错误</h4><p><code>Fuzzy matching</code> 允许查询时匹配错误拼写的单词，而语音语汇单元过滤器可以在索引时用来进行 近似读音 匹配</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Elasticsearch/" rel="tag"># Elasticsearch</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/22/Gulp-笔记/" rel="next" title="Gulp 笔记">
                <i class="fa fa-chevron-left"></i> Gulp 笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/09/CSS-字体总结/" rel="prev" title="CSS 字体总结">
                CSS 字体总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/05/09/Elasticsearch-入门/" data-title="Elasticsearch 入门" data-url="https://shiningdan.github.io/2017/05/09/Elasticsearch-入门/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg" alt="ShiningDan">
          <p class="site-author-name" itemprop="name">ShiningDan</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">119</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">103</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基础入门"><span class="nav-number">2.</span> <span class="nav-text">基础入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装并运行-Elasticsearch"><span class="nav-number">2.1.</span> <span class="nav-text">安装并运行 Elasticsearch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安装-Sense"><span class="nav-number">2.1.1.</span> <span class="nav-text">安装 Sense</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和-Elasticsearch-交互"><span class="nav-number">2.2.</span> <span class="nav-text">和 Elasticsearch 交互</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-API"><span class="nav-number">2.3.</span> <span class="nav-text">Java API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#节点客户端（Node-client）"><span class="nav-number">2.3.1.</span> <span class="nav-text">节点客户端（Node client）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传输客户端（Transport-client）"><span class="nav-number">2.3.2.</span> <span class="nav-text">传输客户端（Transport client）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RESTful-API-with-JSON-over-HTTP"><span class="nav-number">2.4.</span> <span class="nav-text">RESTful API with JSON over HTTP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向文档"><span class="nav-number">2.5.</span> <span class="nav-text">面向文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引"><span class="nav-number">2.6.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#索引（名词）："><span class="nav-number">2.6.1.</span> <span class="nav-text">索引（名词）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引（动词）："><span class="nav-number">2.6.2.</span> <span class="nav-text">索引（动词）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#倒排索引："><span class="nav-number">2.6.3.</span> <span class="nav-text">倒排索引：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引雇员文档"><span class="nav-number">2.6.4.</span> <span class="nav-text">索引雇员文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检索文档"><span class="nav-number">2.6.5.</span> <span class="nav-text">检索文档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量搜索"><span class="nav-number">2.6.6.</span> <span class="nav-text">轻量搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用查询表达式搜索"><span class="nav-number">2.6.7.</span> <span class="nav-text">使用查询表达式搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更复杂的搜索"><span class="nav-number">2.6.8.</span> <span class="nav-text">更复杂的搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全文搜索"><span class="nav-number">2.6.9.</span> <span class="nav-text">全文搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#短语搜索"><span class="nav-number">2.6.10.</span> <span class="nav-text">短语搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高亮搜索"><span class="nav-number">2.6.11.</span> <span class="nav-text">高亮搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析"><span class="nav-number">2.6.12.</span> <span class="nav-text">分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入搜索"><span class="nav-number">3.</span> <span class="nav-text">深入搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构化搜索"><span class="nav-number">3.1.</span> <span class="nav-text">结构化搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#精确值查找"><span class="nav-number">3.1.1.</span> <span class="nav-text">精确值查找</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#term-查询"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">term 查询</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合过滤器"><span class="nav-number">3.1.2.</span> <span class="nav-text">组合过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#布尔过滤器"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">布尔过滤器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#嵌套布尔过滤器"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">嵌套布尔过滤器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找多个精确值"><span class="nav-number">3.1.3.</span> <span class="nav-text">查找多个精确值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#范围"><span class="nav-number">3.1.4.</span> <span class="nav-text">范围</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#日期范围"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">日期范围</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理-Null-值"><span class="nav-number">3.1.5.</span> <span class="nav-text">处理 Null 值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#存在查询"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">存在查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对象上的存在于缺失"><span class="nav-number">3.1.5.2.</span> <span class="nav-text">对象上的存在于缺失</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关于缓存"><span class="nav-number">3.1.6.</span> <span class="nav-text">关于缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全文搜索-1"><span class="nav-number">3.2.</span> <span class="nav-text">全文搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于词项与基于全文"><span class="nav-number">3.2.1.</span> <span class="nav-text">基于词项与基于全文</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基于词项的查询"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">基于词项的查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于全文的查询"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">基于全文的查询</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匹配查询"><span class="nav-number">3.2.2.</span> <span class="nav-text">匹配查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#单个词查询"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">单个词查询</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多词查询"><span class="nav-number">3.2.3.</span> <span class="nav-text">多词查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#提高精度"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">提高精度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#控制精度"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">控制精度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合查询"><span class="nav-number">3.2.4.</span> <span class="nav-text">组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#评分计算"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">评分计算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#控制精度-1"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">控制精度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询语句提升权重"><span class="nav-number">3.2.5.</span> <span class="nav-text">查询语句提升权重</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多字段搜索"><span class="nav-number">3.3.</span> <span class="nav-text">多字段搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多字符串查询"><span class="nav-number">3.3.1.</span> <span class="nav-text">多字符串查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#语句的优先级"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">语句的优先级</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单字符串查询"><span class="nav-number">3.3.2.</span> <span class="nav-text">单字符串查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最佳字段"><span class="nav-number">3.3.3.</span> <span class="nav-text">最佳字段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dis-max-查询"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">dis_max 查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最佳字段查询调优"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">最佳字段查询调优</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tie-breaker-参数"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">tie_breaker 参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#multi-match-查询"><span class="nav-number">3.3.4.</span> <span class="nav-text">multi_match 查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查询字段名称的模糊匹配"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">查询字段名称的模糊匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#提升单个字段的权重"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">提升单个字段的权重</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多数字段"><span class="nav-number">3.3.5.</span> <span class="nav-text">多数字段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#多字段映射"><span class="nav-number">3.3.5.1.</span> <span class="nav-text">多字段映射</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跨字段实体搜索"><span class="nav-number">3.3.6.</span> <span class="nav-text">跨字段实体搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#most-fields-方式的问题"><span class="nav-number">3.3.6.1.</span> <span class="nav-text">most_fields 方式的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字段中心式查询"><span class="nav-number">3.3.6.2.</span> <span class="nav-text">字段中心式查询</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cross-fields-跨字段查询"><span class="nav-number">3.3.7.</span> <span class="nav-text">cross-fields 跨字段查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#近似匹配"><span class="nav-number">3.4.</span> <span class="nav-text">近似匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#短语匹配"><span class="nav-number">3.4.1.</span> <span class="nav-text">短语匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#混合起来"><span class="nav-number">3.4.2.</span> <span class="nav-text">混合起来</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多值字段"><span class="nav-number">3.4.3.</span> <span class="nav-text">多值字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能优化"><span class="nav-number">3.4.4.</span> <span class="nav-text">性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#结果集重新评分"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">结果集重新评分</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寻找相关词"><span class="nav-number">3.4.5.</span> <span class="nav-text">寻找相关词</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部分匹配"><span class="nav-number">3.5.</span> <span class="nav-text">部分匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#prefix-前缀查询"><span class="nav-number">3.5.1.</span> <span class="nav-text">prefix 前缀查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通配符与正则表达式查询"><span class="nav-number">3.5.2.</span> <span class="nav-text">通配符与正则表达式查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询时输入即搜索"><span class="nav-number">3.5.3.</span> <span class="nav-text">查询时输入即搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ngrams-在部分匹配的应用"><span class="nav-number">3.5.4.</span> <span class="nav-text">Ngrams 在部分匹配的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#索引时输入即搜索"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">索引时输入即搜索</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理人类语言"><span class="nav-number">3.6.</span> <span class="nav-text">处理人类语言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用语言分析器"><span class="nav-number">3.6.1.</span> <span class="nav-text">使用语言分析器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词汇识别"><span class="nav-number">3.6.2.</span> <span class="nav-text">词汇识别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归一化词元"><span class="nav-number">3.6.3.</span> <span class="nav-text">归一化词元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同义词"><span class="nav-number">3.6.4.</span> <span class="nav-text">同义词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拼写错误"><span class="nav-number">3.6.5.</span> <span class="nav-text">拼写错误</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShiningDan</span>
</div>



        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"shiningdan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js?v=5.1.0"></script>
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("nr3cyUXVpbTxQQRcqfMp5cHa-gzGzoHsz", "B1SG80mnbseYxv4C0vAjig8s");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
