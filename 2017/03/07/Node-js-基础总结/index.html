<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Node.js," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="本笔记是学习七天学会NodeJS 的个人总结。
NodeJS基础JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。
每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作DOM，浏">
<meta property="og:type" content="article">
<meta property="og:title" content="Node.js 基础总结">
<meta property="og:url" content="https://shiningdan.github.io/2017/03/07/Node-js-基础总结/index.html">
<meta property="og:site_name" content="ShiningDan的博客">
<meta property="og:description" content="本笔记是学习七天学会NodeJS 的个人总结。
NodeJS基础JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。
每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作DOM，浏">
<meta property="og:updated_time" content="2017-03-11T05:41:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Node.js 基础总结">
<meta name="twitter:description" content="本笔记是学习七天学会NodeJS 的个人总结。
NodeJS基础JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。
每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作DOM，浏">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6345612185049236000',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://shiningdan.github.io/2017/03/07/Node-js-基础总结/"/>





  <title> Node.js 基础总结 | ShiningDan的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?65f098889042a1740b5cfede967d34b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ShiningDan的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description"></h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photography">
          <a href="/categories/photography" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            摄影
          </a>
        </li>
      
        
        <li class="menu-item menu-item-coding">
          <a href="/categories/coding" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            编程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://shiningdan.github.io/2017/03/07/Node-js-基础总结/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ShiningDan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ShiningDan的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ShiningDan的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                Node.js 基础总结
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-07T21:47:54+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coding/" itemprop="url" rel="index">
                    <span itemprop="name">coding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/07/Node-js-基础总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/07/Node-js-基础总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/03/07/Node-js-基础总结/" class="leancloud_visitors" data-flag-title="Node.js 基础总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本笔记是学习<a href="http://nqdeng.github.io/7-days-nodejs/#1" target="_blank" rel="external">七天学会NodeJS</a> 的个人总结。</p>
<h2 id="NodeJS基础"><a href="#NodeJS基础" class="headerlink" title="NodeJS基础"></a>NodeJS基础</h2><p>JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。</p>
<p>每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作DOM，浏览器就提供了<code>document</code>之类的内置对象。而运行在NodeJS中的JS的用途是操作磁盘文件或搭建HTTP服务器，NodeJS就相应提供了<code>fs</code>、<code>http</code>等内置对象。</p>
<p>NodeJS最大的卖点——事件机制和异步IO</p>
<a id="more"></a>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>编写稍大一点的程序时一般都会将代码模块化。在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。</p>
<p>在编写每个模块时，都有<code>require</code>、<code>exports</code>、<code>module</code>三个预先定义好的变量可供使用。</p>
<h4 id="require"><a href="#require" class="headerlink" title="require"></a>require</h4><p><code>require</code>函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出<strong>对象</strong>。模块名可使用相对路径（以<code>./</code>开头），或者是绝对路径（以<code>/</code>或<code>C:</code>之类的盘符开头）。另外，模块名中的.js扩展名可以省略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo1 = require(&apos;./foo&apos;);</div><div class="line">var foo2 = require(&apos;./foo.js&apos;);</div><div class="line">var foo3 = require(&apos;/home/user/foo&apos;);</div><div class="line">var foo4 = require(&apos;/home/user/foo.js&apos;);</div></pre></td></tr></table></figure>
<p>可以使用以下方式加载和使用一个<code>JSON</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var data = require(&apos;./data.json&apos;);</div></pre></td></tr></table></figure>
<h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><p><code>exports</code>对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过<code>require</code>函数使用当前模块时得到的就是当前模块的<code>exports</code>对象。以下例子中导出了一个公有方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exports.hello = function () &#123;</div><div class="line">    console.log(&apos;Hello World!&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>通过<code>module</code>对象可以访问到当前模块的一些相关信息，但最多的用途是<strong>替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数</strong>的话，可以使用以下方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports = function () &#123;</div><div class="line">    console.log(&apos;Hello World!&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以上代码中，模块默认导出对象被替换为一个函数。</p>
<h3 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h3><p>一个模块中的JS代码仅在模块<strong>第一次被使用时执行一次</strong>，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。</p>
<p><strong>模块提供的对象不会因为被 <code>require</code> 了两次而初始化两次</strong></p>
<h3 id="二进制模块"><a href="#二进制模块" class="headerlink" title="二进制模块"></a>二进制模块</h3><p>虽然一般我们使用JS编写模块，但NodeJS也支持使用C/C++编写二进制模块。编译好的二进制模块除了文件扩展名是<code>.node</code>外，和JS模块的使用方式相同。</p>
<h2 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h2><h3 id="模块路径解析规则"><a href="#模块路径解析规则" class="headerlink" title="模块路径解析规则"></a>模块路径解析规则</h3><p>我们已经知道，<code>require</code>函数支持斜杠（<code>/</code>）或盘符（<code>C:</code>）开头的绝对路径，也支持<code>./</code>开头的相对路径。但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。因此，require函数支持第三种形式的路径，写法类似于<code>foo/bar</code>，并依次按照以下规则解析路径，直到找到模块位置。</p>
<h4 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h4><p>如果传递给<code>require</code>函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如<code>require(&#39;fs&#39;)</code>。</p>
<h4 id="node-modules目录"><a href="#node-modules目录" class="headerlink" title="node_modules目录"></a>node_modules目录</h4><p>NodeJS定义了一个特殊的<code>node_modules</code>目录用于存放模块。例如某个模块的绝对路径是<code>/home/user/hello.js</code>，在该模块中使用<code>require(&#39;foo/bar&#39;)</code>方式加载模块时，则NodeJS依次尝试使用以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/home/user/node_modules/foo/bar</div><div class="line">/home/node_modules/foo/bar</div><div class="line">/node_modules/foo/bar</div></pre></td></tr></table></figure>
<h4 id="NODE-PATH环境变量"><a href="#NODE-PATH环境变量" class="headerlink" title="NODE_PATH环境变量"></a>NODE_PATH环境变量</h4><p>与PATH环境变量类似，NodeJS允许通过<code>NODE_PATH</code>环境变量来指定额外的模块搜索路径。<code>NODE_PATH</code>环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。例如定义了以下<code>NODE_PATH</code>环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NODE_PATH=/home/user/lib:/home/lib</div></pre></td></tr></table></figure>
<p>当使用<code>require(&#39;foo/bar&#39;)</code>的方式加载模块时，则NodeJS依次尝试以下路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/home/user/lib/foo/bar</div><div class="line">/home/lib/foo/bar</div></pre></td></tr></table></figure>
<h3 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h3><p>我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。</p>
<p>在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- /home/user/lib/</div><div class="line">    - cat/</div><div class="line">        head.js</div><div class="line">        body.js</div><div class="line">        main.js</div></pre></td></tr></table></figure>
<p>其中cat目录定义了一个包，其中包含了3个子模块。main.js作为入口模块，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var head = require(&apos;./head&apos;);</div><div class="line">var body = require(&apos;./body&apos;);</div><div class="line"></div><div class="line">exports.create = function (name) &#123;</div><div class="line">    return &#123;</div><div class="line">        name: name,</div><div class="line">        head: head.create(),</div><div class="line">        body: body.create()</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在其它模块里使用包的时候，需要加载包的入口模块。接着上例，使用<code>require(&#39;/home/user/lib/cat/main&#39;)</code>能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。</p>
<h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><p>当模块的文件名是index.js，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var cat = require(&apos;/home/user/lib/cat&apos;);</div><div class="line">var cat = require(&apos;/home/user/lib/cat/index&apos;);</div></pre></td></tr></table></figure>
<p>这样处理后，就只需要把包目录路径传递给<code>require</code>函数，感觉上整个目录被当作单个模块使用，更有整体感。</p>
<h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个package.json文件，并在其中指定入口模块的路径。上例中的cat模块可以重构如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- /home/user/lib/</div><div class="line">    - cat/</div><div class="line">        + doc/</div><div class="line">        - lib/</div><div class="line">            head.js</div><div class="line">            body.js</div><div class="line">            main.js</div><div class="line">        + tests/</div><div class="line">        package.json</div></pre></td></tr></table></figure>
<p>其中package.json内容如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;cat&quot;,</div><div class="line">    &quot;main&quot;: &quot;./lib/main.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此一来，就同样可以使用<code>require(&#39;/home/user/lib/cat&#39;)</code>的方式加载模块。NodeJS会根据包目录下的package.json找到入口模块所在位置。</p>
<h3 id="命令行程序"><a href="#命令行程序" class="headerlink" title="命令行程序"></a>命令行程序</h3><p>使用NodeJS编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>在Linux系统下，我们可以把JS文件当作shell脚本来运行，从而达到上述目的，具体步骤如下：</p>
<p>在shell脚本中，可以通过<code>#!</code>注释来指定当前脚本使用的解析器。所以我们首先在node-echo.js文件顶部增加以下一行注释，表明当前脚本使用NodeJS解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#! /usr/bin/env node</div></pre></td></tr></table></figure>
<p>NodeJS会忽略掉位于JS模块首行的#!注释，不必担心这行注释是非法语句。</p>
<p>然后，我们使用以下命令赋予node-echo.js文件执行权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod +x /home/user/bin/node-echo.js</div></pre></td></tr></table></figure>
<p>最后，我们在<code>PATH</code>环境变量中指定的某个目录下，例如在/usr/local/bin下边创建一个软链文件，文件名与我们希望使用的终端命令同名，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo</div></pre></td></tr></table></figure>
<p>这样处理后，我们就可以在任何目录下使用node-echo命令了。</p>
<h3 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h3><p>了解了以上知识后，现在我们可以来完整地规划一个工程目录了。以编写一个命令行程序为例，一般我们会同时提供命令行模式和API模式两种使用方式，并且我们会借助三方包来编写代码。除了代码外，一个完整的程序也应该有自己的文档和测试用例。因此，一个标准的工程目录都看起来像下边这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- /home/user/workspace/node-echo/   # 工程目录</div><div class="line">    - bin/                          # 存放命令行相关代码</div><div class="line">        node-echo</div><div class="line">    + doc/                          # 存放文档</div><div class="line">    - lib/                          # 存放API相关代码</div><div class="line">        echo.js</div><div class="line">    - node_modules/                 # 存放三方包</div><div class="line">        + argv/</div><div class="line">    + tests/                        # 存放测试用例</div><div class="line">    package.json                    # 元数据文件</div><div class="line">    README.md                       # 说明文件</div></pre></td></tr></table></figure>
<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><h4 id="发布代码"><a href="#发布代码" class="headerlink" title="发布代码"></a>发布代码</h4><p>第一次使用NPM发布代码前需要注册一个账号。终端下运行<code>npm adduser</code>，之后按照提示做即可。账号搞定后，接着我们需要编辑package.json文件，加入NPM必需的字段。接着上边node-echo的例子，package.json里必要的字段如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;node-echo&quot;,           # 包名，在NPM服务器上须要保持唯一</div><div class="line">    &quot;version&quot;: &quot;1.0.0&quot;,            # 当前版本号</div><div class="line">    &quot;dependencies&quot;: &#123;              # 三方包依赖，需要指定包名和版本号</div><div class="line">        &quot;argv&quot;: &quot;0.0.2&quot;</div><div class="line">      &#125;,</div><div class="line">    &quot;main&quot;: &quot;./lib/echo.js&quot;,       # 入口模块位置</div><div class="line">    &quot;bin&quot; : &#123;</div><div class="line">        &quot;node-echo&quot;: &quot;./bin/node-echo&quot;      # 命令行程序名和主模块位置</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p>
<p>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ 如果只是修复bug，需要更新Z位。</div><div class="line"></div><div class="line">+ 如果是新增了功能，但是向下兼容，需要更新Y位。</div><div class="line"></div><div class="line">+ 如果有大变动，向下不兼容，需要更新X位。</div></pre></td></tr></table></figure>
<h4 id="npm-常用命令"><a href="#npm-常用命令" class="headerlink" title="npm 常用命令"></a>npm 常用命令</h4><p>除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。除了可以在npmjs.org/doc/查看官方文档外，这里再介绍一些NPM常用命令。</p>
<p>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</p>
<p>使用<code>npm help &lt;command&gt;</code>可查看某条命令的详细帮助，例如npm help install。</p>
<p>在package.json所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
<p>使用<code>npm update &lt;package&gt;</code>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</p>
<p>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p>
<p>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p>
<p>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="小文件拷贝"><a href="#小文件拷贝" class="headerlink" title="小文件拷贝"></a>小文件拷贝</h3><p>我们使用NodeJS内置的fs模块简单实现这个程序如下。</p>
<p>以上程序使用<code>fs.readFileSync</code>从源路径读取文件内容，并使用<code>fs.writeFileSync</code>将文件内容写入目标路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">function copy(src, dst) &#123;</div><div class="line">    fs.writeFileSync(dst, fs.readFileSync(src));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">    copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p><code>process</code>是一个全局变量，可通过<code>process.argv</code>获得命令行参数。由于<code>argv[0]</code>固定等于NodeJS执行程序的绝对路径，<code>argv[1]</code>固定等于主模块的绝对路径，因此第一个命令行参数从<code>argv[2]</code>这个位置开始。</p>
<p><code>process.argv</code> 的值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ &apos;/usr/local/Cellar/node/7.3.0/bin/node&apos;,</div><div class="line">  &apos;/Users/yuchenzhang/Documents/web/test/test.js&apos;,</div><div class="line">  &apos;./test.js&apos;,</div><div class="line">  &apos;./test1.js&apos; ]</div></pre></td></tr></table></figure>
<p><strong>如果文件的大小过大，则这个方法会报错：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">buffer.js:11</div><div class="line">    super(arg1, arg2, arg3);</div><div class="line">    ^</div><div class="line"></div><div class="line">RangeError: Invalid typed array length</div><div class="line">    at Buffer.Uint8Array (native)</div><div class="line">    at FastBuffer (buffer.js:11:5)</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>如果是使用异步的文件传输方法 <code>writeFile</code> 和 <code>readFile</code>，也会因为文件大小过大而报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let fs = require(&quot;fs&quot;);</div><div class="line"></div><div class="line">function copy(src, dst) &#123;</div><div class="line">	fs.writeFile(dst, fs.readFile(src), function(err, data)&#123;</div><div class="line">	  if (err) throw err;</div><div class="line">	  console.log(data);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">	copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p>报错为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RangeError: File size is greater than possible Buffer: 0x7fffffff bytes</div><div class="line">    at FSReqWrap.readFileAfterStat [as oncomplete] (fs.js:362:11)</div></pre></td></tr></table></figure>
<h3 id="大文件拷贝"><a href="#大文件拷贝" class="headerlink" title="大文件拷贝"></a>大文件拷贝</h3><p>上边的程序拷贝一些小文件没啥问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。对于大文件，我们只能读一点写一点，直到完成拷贝。因此上边的程序需要改造如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">function copy(src, dst) &#123;</div><div class="line">    fs.createReadStream(src).pipe(fs.createWriteStream(dst));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">    copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p>以上程序使用<code>fs.createReadStream</code>创建了一个源文件的只读数据流，并使用<code>fs.createWriteStream</code>创建了一个目标文件的只写数据流，并且用<code>pipe</code>方法把两个数据流连接了起来。连接起来后发生的事情，说得抽象点的话，水顺着水管从一个桶流到了另一个桶。</p>
<p>使用 stream 的方法传输文件是异步传输。</p>
<h3 id="Buffer（数据块）"><a href="#Buffer（数据块）" class="headerlink" title="Buffer（数据块）"></a>Buffer（数据块）</h3><p>JS语言自身只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与<code>String</code>对等的全局构造函数<code>Buffer</code>来提供对二进制数据的操作。除了可以读取文件得到<code>Buffer</code>的实例外，还能够直接构造，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div></pre></td></tr></table></figure>
<p><code>Buffer</code>与字符串类似，除了可以用<code>.length</code>属性得到字节长度外，还可以用<code>[index]</code>方式读取指定位置的字节，例如：</p>
<p><code>Buffer</code>将JS的数据处理能力从字符串扩展到了任意二进制数据。</p>
<h3 id="Stream（数据流）"><a href="#Stream（数据流）" class="headerlink" title="Stream（数据流）"></a>Stream（数据流）</h3><p>当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种<code>Stream</code>来提供对数据流的操作。</p>
<p>以上边的大文件拷贝程序为例，我们可以为数据来源创建一个只读数据流，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(pathname);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    doSomething(chunk);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">    cleanUp();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>Stream</code>基于事件机制工作，所有<code>Stream</code>的实例都继承于NodeJS提供的<code>EventEmitter</code>。</p>
<p>上边的代码中<code>data</code>事件会源源不断地被触发，不管<code>doSomething</code>函数是否处理得过来。代码可以继续做如下改造，以解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    rs.pause();</div><div class="line">    doSomething(chunk, function () &#123;</div><div class="line">        rs.resume();</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">    cleanUp();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上代码给<code>doSomething</code>函数加上了回调，因此我们可以在处理数据前暂停数据读取，并在处理数据后继续读取数据。</p>
<p>此外，我们也可以为数据目标创建一个只写数据流，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(src);</div><div class="line">var ws = fs.createWriteStream(dst);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    ws.write(chunk);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">    ws.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们把<code>doSomething</code>换成了往只写数据流里写入数据后，以上代码看起来就像是一个文件拷贝程序了。但是以上代码存在上边提到的问题，如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆仓。我们可以根据<code>.write</code>方法的返回值来判断传入的数据是写入目标了，还是临时放在了缓存了，并根据<code>drain</code>事件来判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了。因此代码可以改造如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var rs = fs.createReadStream(src);</div><div class="line">var ws = fs.createWriteStream(dst);</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">    if (ws.write(chunk) === false) &#123;</div><div class="line">        rs.pause();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">    ws.end();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ws.on(&apos;drain&apos;, function () &#123;</div><div class="line">    rs.resume();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="File-System（文件系统）"><a href="#File-System（文件系统）" class="headerlink" title="File System（文件系统）"></a>File System（文件系统）</h3><p>NodeJS通过<code>fs</code>内置模块提供对文件的操作。fs模块提供的API基本上可以分为以下三类：</p>
<ul>
<li>文件属性读写。</li>
</ul>
<p>其中常用的有<code>fs.stat</code>、<code>fs.chmod</code>、<code>fs.chown</code>等等。</p>
<ul>
<li>文件内容读写。</li>
</ul>
<p>其中常用的有<code>fs.readFile</code>、<code>fs.readdir</code>、<code>fs.writeFile</code>、<code>fs.mkdir</code>等等。</p>
<ul>
<li>底层文件操作。</li>
</ul>
<p>其中常用的有<code>fs.open</code>、<code>fs.read</code>、<code>fs.write</code>、<code>fs.close</code>等等。</p>
<p>NodeJS最精华的异步IO模型在<code>fs</code>模块里有着充分的体现，例如上边提到的这些API都通过回调函数传递结果。以<code>fs.readFile</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fs.readFile(pathname, function (err, data) &#123;</div><div class="line">    if (err) &#123;</div><div class="line">        // Deal with error.</div><div class="line">    &#125; else &#123;</div><div class="line">        // Deal with data.</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Path（路径）"><a href="#Path（路径）" class="headerlink" title="Path（路径）"></a>Path（路径）</h3><p>操作文件时难免不与文件路径打交道。NodeJS提供了<code>path</code>内置模块来简化路径相关操作，并提升代码可读性。以下分别介绍几个常用的API。</p>
<h4 id="path-normalize"><a href="#path-normalize" class="headerlink" title="path.normalize"></a>path.normalize</h4><p>将传入的路径转换为标准路径，具体讲的话，除了解析路径中的<code>.</code>与<code>..</code>外，还能去掉多余的斜杠。如果有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的唯一性。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var cache = &#123;&#125;;</div><div class="line"></div><div class="line">function store(key, value) &#123;</div><div class="line">    cache[path.normalize(key)] = value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">store(&apos;foo/bar&apos;, 1);</div><div class="line">store(&apos;foo//baz//../bar&apos;, 2);</div><div class="line">console.log(cache);  // =&gt; &#123; &quot;foo/bar&quot;: 2 &#125;</div></pre></td></tr></table></figure>
<p><strong>标准化之后的路径里的斜杠在Windows系统下是<code>\</code>，而在Linux系统下是<code>/</code>。如果想保证任何系统下都使用<code>/</code>作为路径分隔符的话，需要用<code>.replace(/\\/g, &#39;/&#39;)</code>再替换一下标准路径。</strong></p>
<h4 id="path-join"><a href="#path-join" class="headerlink" title="path.join"></a>path.join</h4><p>将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.join(&apos;foo/&apos;, &apos;baz/&apos;, &apos;../bar&apos;); // =&gt; &quot;foo/bar&quot;</div></pre></td></tr></table></figure>
<h4 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname"></a>path.extname</h4><p>当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。以下是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path.extname(&apos;foo/bar.js&apos;); // =&gt; &quot;.js&quot;</div></pre></td></tr></table></figure>
<h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><p>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。</p>
<h4 id="同步遍历"><a href="#同步遍历" class="headerlink" title="同步遍历"></a>同步遍历</h4><p>总结：</p>
<ul>
<li>使用 <code>fs.readdirSync(path)</code> 同步获得一个文件目录下所有的文件夹和文件</li>
<li>使用 <code>path</code> 对象构造新的文件夹目录</li>
<li>使用 <code>fs.statSync(path)</code> 同步得到关于一个文件或者文件夹的信息，判断该路径是文件还是文件夹等</li>
<li></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let fs = require(&apos;fs&apos;);</div><div class="line">let path = require(&apos;path&apos;);</div><div class="line"></div><div class="line">function travel(dir, callback) &#123;</div><div class="line">	fs.readdirSync(dir).forEach( function(element, index) &#123;</div><div class="line">		let pathname = path.join(dir, element);</div><div class="line">		if(fs.statSync(pathname).isDirectory())&#123;</div><div class="line">			callback(pathname, true);</div><div class="line">			travel(pathname, callback);</div><div class="line">		&#125; else &#123;</div><div class="line">			callback(pathname, false);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function travelCallback(path, isDirectory) &#123;</div><div class="line">	if (isDirectory) &#123;</div><div class="line">		console.log(&apos;\n---------- &apos; + path + &apos; ---------\n&apos;);</div><div class="line">	&#125; else &#123;</div><div class="line">		console.log(path);</div><div class="line">	&#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">travel(&quot;/Users/yuchenzhang/Documents/web/test&quot;, travelCallback);</div></pre></td></tr></table></figure>
<h4 id="异步遍历"><a href="#异步遍历" class="headerlink" title="异步遍历"></a>异步遍历</h4><p>如果读取目录或读取文件状态时使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同。<code>travel</code>函数的异步版本如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function travel(dir, callback, finish) &#123;</div><div class="line">    fs.readdir(dir, function (err, files) &#123;</div><div class="line">        (function next(i) &#123;</div><div class="line">            if (i &lt; files.length) &#123;</div><div class="line">                var pathname = path.join(dir, files[i]);</div><div class="line"></div><div class="line">                fs.stat(pathname, function (err, stats) &#123;</div><div class="line">                    if (stats.isDirectory()) &#123;</div><div class="line">                        travel(pathname, callback, function () &#123;</div><div class="line">                            next(i + 1);</div><div class="line">                        &#125;);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        callback(pathname, function () &#123;</div><div class="line">                            next(i + 1);</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125; else &#123;</div><div class="line">                finish &amp;&amp; finish();</div><div class="line">            &#125;</div><div class="line">        &#125;(0));</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="文本编码"><a href="#文本编码" class="headerlink" title="文本编码"></a>文本编码</h3><p>使用NodeJS编写前端工具时，操作得最多的是文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有<code>UTF8</code>和<code>GBK</code>两种，并且<code>UTF8</code>文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的<code>UTF8</code>编码字符串后才能正常处理。</p>
<h4 id="BOM的移除"><a href="#BOM的移除" class="headerlink" title="BOM的移除"></a>BOM的移除</h4><p>BOM用于标记一个文本文件使用Unicode编码，其本身是一个Unicode字符（”\uFEFF”），位于文本文件头部。在不同的Unicode编码下，BOM字符对应的二进制字节如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    Bytes      Encoding</div><div class="line">----------------------------</div><div class="line">    FE FF       UTF16BE</div><div class="line">    FF FE       UTF16LE</div><div class="line">    EF BB BF    UTF8</div></pre></td></tr></table></figure>
<p>因此，我们可以根据文本文件头几个字节等于啥来判断文件是否包含BOM，以及使用哪种Unicode编码。但是，BOM字符虽然起到了标记文件编码的作用，其本身却不属于文件内容的一部分，如果读取文本文件时不去掉BOM，在某些使用场景下就会有问题。例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。因此，使用NodeJS读取文本文件时，一般需要去掉BOM。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function readText(pathname) &#123;</div><div class="line">    var bin = fs.readFileSync(pathname);</div><div class="line"></div><div class="line">    if (bin[0] === 0xEF &amp;&amp; bin[1] === 0xBB &amp;&amp; bin[2] === 0xBF) &#123;</div><div class="line">        bin = bin.slice(3);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return bin.toString(&apos;utf-8&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="GBK转UTF8"><a href="#GBK转UTF8" class="headerlink" title="GBK转UTF8"></a>GBK转UTF8</h4><p>NodeJS支持在读取文本文件时，或者在<code>Buffer</code>转换为字符串时指定文本编码，但遗憾的是，GBK编码不在NodeJS自身支持范围内。因此，一般我们借助<code>iconv-lite</code>这个三方包来转换编码。使用NPM下载该包后，我们可以按下边方式编写一个读取GBK文本文件的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let iconv = require(&apos;iconv-lite&apos;);</div><div class="line">let fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">function readGBKText(pathname) &#123;</div><div class="line">    let bin = fs.readFileSync(pathname);</div><div class="line">    let result = iconv.decode(bin, &apos;gbk&apos;);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="单字节编码"><a href="#单字节编码" class="headerlink" title="单字节编码"></a>单字节编码</h4><p>有时候，我们无法预知需要读取的文件采用哪种编码，因此也就无法指定正确的编码。比如我们要处理的某些CSS文件中，有的用GBK编码，有的用UTF8编码。虽然可以一定程度可以根据文件的字节内容猜测出文本编码，但这里要介绍的是有些局限，但是要简单得多的一种技术。</p>
<p>首先我们知道，如果一个文本文件只包含英文字符，比如<code>Hello World</code>，那无论用GBK编码或是UTF8编码读取这个文件都是没问题的。这是因为在这些编码下，ASCII0~128范围内字符都使用相同的单字节编码。</p>
<p>反过来讲，即使一个文本文件中有中文等字符，如果我们需要处理的字符仅在ASCII0~128范围内，比如除了注释和字符串以外的JS代码，我们就可以统一使用单字节编码来读取文件，不用关心文件的实际编码是GBK还是UTF8。以下示例说明了这种方法。</p>
<p>这里的诀窍在于，不管大于0xEF的单个字节在单字节编码下被解析成什么乱码字符，使用同样的单字节编码保存这些乱码字符时，背后对应的字节保持不变。</p>
<p>NodeJS中自带了一种<code>binary</code>编码可以用来实现这个方法，因此在下例中，我们使用这种编码来演示上例对应的代码该怎么写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function replace(pathname) &#123;</div><div class="line">    var str = fs.readFileSync(pathname, &apos;binary&apos;);</div><div class="line">    str = str.replace(&apos;foo&apos;, &apos;bar&apos;);</div><div class="line">    fs.writeFileSync(pathname, str, &apos;binary&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><strong>在Linux系统下，监听1024以下端口需要root权限。因此，如果想监听80或443端口的话，需要使用<code>sudo</code>命令启动程序。</strong></p>
<p><code>http</code>模块提供两种使用方式：</p>
<ul>
<li>作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。</li>
<li>作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。</li>
</ul>
<h4 id="HTTP-服务器端"><a href="#HTTP-服务器端" class="headerlink" title="HTTP 服务器端"></a>HTTP 服务器端</h4><p>首先需要使用<code>.createServer</code>方法创建一个服务器，然后调用<code>.listen</code>方法监听端口。之后，每当来了一个客户端请求，创建服务器时传入的回调函数就被调用一次。可以看出，这是一种事件机制。</p>
<p>关于Server 上获得的 request 相关 API，可以去 <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage" target="_blank" rel="external">Node IncomingMessage</a> 查询</p>
<p>HTTP请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而<code>http</code>模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数。在回调函数中，除了可以使用<code>request</code>对象访问请求头数据外，还能把<code>request</code>对象当作一个只读数据流来访问请求体数据。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">    var body = [];</div><div class="line"></div><div class="line">    console.log(request.method);</div><div class="line">    console.log(request.headers);</div><div class="line"></div><div class="line">    request.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">        body.push(chunk);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    request.on(&apos;end&apos;, function () &#123;</div><div class="line">        body = Buffer.concat(body);</div><div class="line">        console.log(body.toString());</div><div class="line">    &#125;);</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>在回调函数中，除了可以使用<code>response</code>对象来写入响应头数据外，还能把<code>response</code>对象当作一个只写数据流来写入响应体数据。例如在以下例子中，服务端原样将客户端请求的请求体数据返回给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">    response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;);</div><div class="line"></div><div class="line">    request.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">        response.write(chunk);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    request.on(&apos;end&apos;, function () &#123;</div><div class="line">        response.end();</div><div class="line">    &#125;);</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<h4 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h4><p>为了发起一个客户端HTTP请求，我们需要指定目标服务器的位置并发送请求头和请求体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">        hostname: &apos;www.example.com&apos;,</div><div class="line">        port: 80,</div><div class="line">        path: &apos;/upload&apos;,</div><div class="line">        method: &apos;POST&apos;,</div><div class="line">        headers: &#123;</div><div class="line">            &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">var request = http.request(options, function (response) &#123;&#125;);</div><div class="line"></div><div class="line">request.write(&apos;Hello World&apos;);</div><div class="line">request.end();</div></pre></td></tr></table></figure>
<p>可以看到，<code>.request</code>方法创建了一个客户端，并指定请求目标和请求头数据。之后，就可以把<code>request</code>对象当作一个只写数据流来写入请求体数据和结束请求。另外，由于HTTP请求中GET请求是最常见的一种，并且不需要请求体，因此<code>http</code>模块也提供了以下便捷API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http.get(&apos;http://www.example.com/&apos;, function (response) &#123;&#125;);</div></pre></td></tr></table></figure>
<p>当客户端发送请求并接收到完整的服务端响应头时，就会调用回调函数。在回调函数中，除了可以使用<code>response</code>对象访问响应头数据外，还能把<code>response</code>对象当作一个只读数据流来访问响应体数据。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">http.get(&apos;http://www.example.com/&apos;, function (response) &#123;</div><div class="line">    var body = [];</div><div class="line"></div><div class="line">    console.log(response.statusCode);</div><div class="line">    console.log(response.headers);</div><div class="line"></div><div class="line">    response.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">        body.push(chunk);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    response.on(&apos;end&apos;, function () &#123;</div><div class="line">        body = Buffer.concat(body);</div><div class="line">        console.log(body.toString());</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><code>https</code>模块与<code>http</code>模块极为类似，区别在于<code>https</code>模块需要额外处理SSL证书。</p>
<p>在服务端模式下，创建一个HTTPS服务器的示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">        key: fs.readFileSync(&apos;./ssl/default.key&apos;),</div><div class="line">        cert: fs.readFileSync(&apos;./ssl/default.cer&apos;)</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">var server = https.createServer(options, function (request, response) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>可以看到，与创建HTTP服务器相比，多了一个<code>options</code>对象，通过<code>key</code>和<code>cert</code>字段指定了HTTPS服务器使用的私钥和公钥。</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>处理HTTP请求时<code>url</code>模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。首先我们来看看一个完整的URL的各组成部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">                           href</div><div class="line"> -----------------------------------------------------------------</div><div class="line">                            host              path</div><div class="line">                      --------------- ----------------------------</div><div class="line"> http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash</div><div class="line"> -----    ---------   --------   ---- -------- ------------- -----</div><div class="line">protocol     auth     hostname   port pathname     search     hash</div><div class="line">                                                ------------</div><div class="line">                                                   query</div></pre></td></tr></table></figure>
<p>我们可以使用<code>.parse</code>方法来将一个URL字符串转换为URL对象，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">url.parse(&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;);</div><div class="line">/* =&gt;</div><div class="line">&#123; protocol: &apos;http:&apos;,</div><div class="line">  auth: &apos;user:pass&apos;,</div><div class="line">  host: &apos;host.com:8080&apos;,</div><div class="line">  port: &apos;8080&apos;,</div><div class="line">  hostname: &apos;host.com&apos;,</div><div class="line">  hash: &apos;#hash&apos;,</div><div class="line">  search: &apos;?query=string&apos;,</div><div class="line">  query: &apos;query=string&apos;,</div><div class="line">  pathname: &apos;/p/a/t/h&apos;,</div><div class="line">  path: &apos;/p/a/t/h?query=string&apos;,</div><div class="line">  href: &apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos; &#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>传给<code>.parse</code>方法的不一定要是一个完整的URL，例如在HTTP服务器回调函数中，<code>request.url</code>不包含协议头和域名，但同样可以用<code>.parse</code>方法解析。</p>
<p>另外，<code>.resolve</code>方法可以用于拼接URL，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">url.resolve(&apos;http://www.example.com/foo/bar&apos;, &apos;../baz&apos;);</div><div class="line">/* =&gt;</div><div class="line">http://www.example.com/baz</div><div class="line">*/</div></pre></td></tr></table></figure>
<h3 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h3><p><code>querystring</code>模块用于实现URL参数字符串与参数对象的互相转换，示例如下，返回一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;);</div><div class="line">/* =&gt;</div><div class="line">&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;</div><div class="line">*/</div><div class="line"></div><div class="line">querystring.stringify(&#123; foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; &#125;);</div><div class="line">/* =&gt;</div><div class="line">&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=&apos;</div><div class="line">*/</div></pre></td></tr></table></figure>
<h3 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h3><p><code>zlib</code>模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。</p>
<p>首先我们看一个使用<code>zlib</code>模块压缩HTTP响应体数据的例子。这个例子中，判断了客户端是否支持<code>gzip</code>，并在支持的情况下使用<code>zlib</code>模块返回<code>gzip</code>之后的响应体数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123; host: &apos;localhost:8888&apos;,</div><div class="line">  &apos;upgrade-insecure-requests&apos;: &apos;1&apos;,</div><div class="line">  accept: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;,</div><div class="line">  &apos;user-agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/602.4.8 (KHTML, like Gecko) Version/10.0.3 Safari/602.4.8&apos;,</div><div class="line">  &apos;accept-language&apos;: &apos;zh-cn&apos;,</div><div class="line">  &apos;accept-encoding&apos;: &apos;gzip, deflate&apos;,</div><div class="line">  connection: &apos;keep-alive&apos; &#125;</div></pre></td></tr></table></figure>
<p>如图的测试案例中，<code>accept-encoding</code> 中包含了 <code>gzip</code> 选项，说明浏览器支持返回的数据为 gzip 格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">http.createServer(function (request, response) &#123;</div><div class="line">    var i = 1024,</div><div class="line">        data = &apos;&apos;;</div><div class="line"></div><div class="line">    while (i--) &#123;</div><div class="line">        data += &apos;.&apos;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ((request.headers[&apos;accept-encoding&apos;] || &apos;&apos;).indexOf(&apos;gzip&apos;) !== -1) &#123;</div><div class="line">        zlib.gzip(data, function (err, data) &#123;</div><div class="line">            response.writeHead(200, &#123;</div><div class="line">                &apos;Content-Type&apos;: &apos;text/plain&apos;,</div><div class="line">                &apos;Content-Encoding&apos;: &apos;gzip&apos;</div><div class="line">            &#125;);</div><div class="line">            response.end(data);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        response.writeHead(200, &#123;</div><div class="line">            &apos;Content-Type&apos;: &apos;text/plain&apos;</div><div class="line">        &#125;);</div><div class="line">        response.end(data);</div><div class="line">    &#125;</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>接着我们看一个使用<code>zlib</code>模块解压HTTP响应体数据的例子。这个例子中，判断了服务端响应是否使用<code>gzip</code>压缩，并在压缩的情况下使用<code>zlib</code>模块解压响应体数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">        hostname: &apos;www.example.com&apos;,</div><div class="line">        port: 80,</div><div class="line">        path: &apos;/&apos;,</div><div class="line">        method: &apos;GET&apos;,</div><div class="line">        headers: &#123;</div><div class="line">            &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">http.request(options, function (response) &#123;</div><div class="line">    var body = [];</div><div class="line"></div><div class="line">    response.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">        body.push(chunk);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    response.on(&apos;end&apos;, function () &#123;</div><div class="line">        body = Buffer.concat(body);</div><div class="line"></div><div class="line">        if (response.headers[&apos;content-encoding&apos;] === &apos;gzip&apos;) &#123;</div><div class="line">            zlib.gunzip(body, function (err, data) &#123;</div><div class="line">                console.log(data.toString());</div><div class="line">            &#125;);</div><div class="line">        &#125; else &#123;</div><div class="line">            console.log(data.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;).end();</div></pre></td></tr></table></figure>
<h3 id="Net"><a href="#Net" class="headerlink" title="Net"></a>Net</h3><p><code>net</code>模块可用于创建Socket服务器或Socket客户端。由于Socket在前端领域的使用范围还不是很广，这里先不涉及到WebSocket的介绍，仅仅简单演示一下如何从Socket层面来实现HTTP请求和响应。</p>
<p>首先我们来看一个使用Socket搭建一个很不严谨的HTTP服务器的例子。这个HTTP服务器不管收到啥请求，都固定返回相同的响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">net.createServer(function (conn) &#123;</div><div class="line">    conn.on(&apos;data&apos;, function (data) &#123;</div><div class="line">        conn.write([</div><div class="line">            &apos;HTTP/1.1 200 OK&apos;,</div><div class="line">            &apos;Content-Type: text/plain&apos;,</div><div class="line">            &apos;Content-Length: 11&apos;,</div><div class="line">            &apos;&apos;,</div><div class="line">            &apos;Hello World&apos;</div><div class="line">        ].join(&apos;\n&apos;));</div><div class="line">    &#125;);</div><div class="line">&#125;).listen(80);</div></pre></td></tr></table></figure>
<p>接着我们来看一个使用Socket发起HTTP客户端请求的例子。这个例子中，Socket客户端在建立连接后发送了一个HTTP GET请求，并通过<code>data</code>事件监听函数来获取服务器响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">        port: 80,</div><div class="line">        host: &apos;www.example.com&apos;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">var client = net.connect(options, function () &#123;</div><div class="line">        client.write([</div><div class="line">            &apos;GET / HTTP/1.1&apos;,</div><div class="line">            &apos;User-Agent: curl/7.26.0&apos;,</div><div class="line">            &apos;Host: www.baidu.com&apos;,</div><div class="line">            &apos;Accept: */*&apos;,</div><div class="line">            &apos;&apos;,</div><div class="line">            &apos;&apos;</div><div class="line">        ].join(&apos;\n&apos;));</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">client.on(&apos;data&apos;, function (data) &#123;</div><div class="line">    console.log(data.toString());</div><div class="line">    client.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>我们已经知道了NodeJS自带的<code>fs</code>模块比较基础，把一个目录里的所有文件和子目录都拷贝到另一个目录里需要写不少代码。另外我们也知道，终端下的cp命令比较好用，一条<code>cp -r source/* target</code>命令就能搞定目录拷贝。那我们首先看看如何使用NodeJS调用终端命令来简化目录拷贝，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var child_process = require(&apos;child_process&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line"></div><div class="line">function copy(source, target, callback) &#123;</div><div class="line">    child_process.exec(</div><div class="line">        util.format(&apos;cp -r %s/* %s&apos;, source, target), callback);</div><div class="line">&#125;</div><div class="line"></div><div class="line">copy(&apos;a&apos;, &apos;b&apos;, function (err) &#123;</div><div class="line">    // ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。在NodeJS中，可以通过<code>process</code>对象感知和控制NodeJS自身进程的方方面面。另外需要注意的是，<code>process</code>不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。</p>
<h3 id="Child-Process"><a href="#Child-Process" class="headerlink" title="Child Process"></a>Child Process</h3><p>使用<code>child_process</code>模块可以创建和控制子进程。该模块提供的API中最核心的是<code>.spawn</code>，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。</p>
<h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p><code>cluster</code>模块是对<code>child_process</code>模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="如何获取命令行参数"><a href="#如何获取命令行参数" class="headerlink" title="如何获取命令行参数"></a>如何获取命令行参数</h4><p>在NodeJS中可以通过<code>process.argv</code>获取命令行参数。但是比较意外的是，node执行程序路径和主模块文件路径固定占据了<code>argv[0]</code>和<code>argv[1]</code>两个位置，而第一个命令行参数从<code>argv[2]</code>开始。为了让<code>argv</code>使用起来更加自然，可以按照以下方式处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function main(argv) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p>例如我们运行 <code>node test1.js arg1 arg2 arg3</code>，然后打印出 <code>process.argv</code>，得到的是以下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ &apos;/usr/local/Cellar/node/7.3.0/bin/node&apos;,</div><div class="line">  &apos;/Users/yuchenzhang/Documents/web/test/test1.js&apos;,</div><div class="line">  &apos;arg1&apos;,</div><div class="line">  &apos;arg2&apos;,</div><div class="line">  &apos;arg3&apos; ]</div></pre></td></tr></table></figure>
<h4 id="如何退出程序"><a href="#如何退出程序" class="headerlink" title="如何退出程序"></a>如何退出程序</h4><p>通常一个程序做完所有事情后就正常退出了，这时程序的退出状态码为<code>0</code>。或者一个程序运行时发生了异常后就挂了，这时程序的退出状态码不等于<code>0</code>。如果我们在代码中捕获了某个异常，但是觉得程序不应该继续运行下去，需要立即退出，并且需要把退出状态码设置为指定数字，比如<code>1</code>，就可以按照以下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    // ...</div><div class="line">&#125; catch (err) &#123;</div><div class="line">    // ...</div><div class="line">    process.exit(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="如何控制输入输出"><a href="#如何控制输入输出" class="headerlink" title="如何控制输入输出"></a>如何控制输入输出</h4><p>NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应<code>process.stdin</code>、<code>process.stdout</code>和<code>process.stderr</code>，第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。例如，<code>console.log</code>可以按照以下方式实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">process.stdin.on(&apos;readable&apos;, ()=&gt;&#123;</div><div class="line">	let chunk = process.stdin.read();</div><div class="line">	if (chunk != null) &#123;</div><div class="line">		process.stdout.write(`data: $&#123;chunk&#125;`);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">process.stdin.on(&apos;end&apos;, ()=&gt;&#123;</div><div class="line">	process.stdout.write(&apos;end&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以通过 <code>Ctrl + D</code> 来触发 <code>end</code> 事件。</p>
<h4 id="如何降权"><a href="#如何降权" class="headerlink" title="如何降权"></a>如何降权</h4><p>在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。以下是这样一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">http.createServer(callback).listen(80, function () &#123;</div><div class="line">    var env = process.env,</div><div class="line">        uid = parseInt(env[&apos;SUDO_UID&apos;] || process.getuid(), 10),</div><div class="line">        gid = parseInt(env[&apos;SUDO_GID&apos;] || process.getgid(), 10);</div><div class="line"></div><div class="line">    process.setgid(gid);</div><div class="line">    process.setuid(uid);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li><p>如果是通过<code>sudo</code>获取root权限的，运行程序的用户的UID和GID保存在环境变量<code>SUDO_UID</code>和<code>SUDO_GID</code>里边。如果是通过<code>chmod +s</code>方式获取root权限的，运行程序的用户的UID和GID可直接通过<code>process.getuid</code>和<code>process.getgid</code>方法获取。</p>
</li>
<li><p><code>process.setuid</code>和<code>process.setgid</code>方法只接受<code>number</code>类型的参数。</p>
</li>
<li><p>降权时必须先降GID再降UID，否则顺序反过来的话就没权限更改程序的GID了。</p>
</li>
</ul>
<h4 id="如何创建子进程"><a href="#如何创建子进程" class="headerlink" title="如何创建子进程"></a>如何创建子进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;xxx.js&apos; ]);</div><div class="line"></div><div class="line">child.stdout.on(&apos;data&apos;, function (data) &#123;</div><div class="line">    console.log(&apos;stdout: &apos; + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.stderr.on(&apos;data&apos;, function (data) &#123;</div><div class="line">    console.log(&apos;stderr: &apos; + data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.on(&apos;close&apos;, function (code) &#123;</div><div class="line">    console.log(&apos;child process exited with code &apos; + code);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上例中使用了<code>.spawn(exec, args, options)</code>方法，该方法支持三个参数。第一个参数是执行文件路径，可以是执行文件的相对或绝对路径，也可以是根据PATH环境变量能找到的执行文件名。第二个参数中，数组中的每个成员都按顺序对应一个命令行参数。第三个参数可选，用于配置子进程的执行环境与行为。</p>
<p>另外，上例中虽然通过子进程对象的<code>.stdout</code>和<code>.stderr</code>访问子进程的输出，但通过<code>options.stdio</code>字段的不同配置，可以将子进程的输入输出重定向到任何数据流上，或者让子进程共享父进程的标准输入输出流，或者直接忽略子进程的输入输出。</p>
<h4 id="进程间如何通讯"><a href="#进程间如何通讯" class="headerlink" title="进程间如何通讯"></a>进程间如何通讯</h4><p>在Linux系统下，进程之间可以通过信号互相通信。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ]);</div><div class="line"></div><div class="line">child.kill(&apos;SIGTERM&apos;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;SIGTERM&apos;, function () &#123;</div><div class="line">    cleanUp();</div><div class="line">    process.exit(0);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上例中，父进程通过<code>.kill</code>方法向子进程发送<code>SIGTERM</code>信号，子进程监听<code>process</code>对象的<code>SIGTERM</code>事件响应信号。不要被<code>.kill</code>方法的名称迷惑了，该方法本质上是用来给进程发送信号的，进程收到信号后具体要做啥，完全取决于信号的种类和进程自身的代码。</p>
<p>另外，如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* parent.js */</div><div class="line">var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ], &#123;</div><div class="line">        stdio: [ 0, 1, 2, &apos;ipc&apos; ]</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">child.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">    console.log(msg);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">child.send(&#123; hello: &apos;hello&apos; &#125;);</div><div class="line"></div><div class="line">/* child.js */</div><div class="line">process.on(&apos;message&apos;, function (msg) &#123;</div><div class="line">    msg.hello = msg.hello.toUpperCase();</div><div class="line">    process.send(msg);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看到，父进程在创建子进程时，在<code>options.stdio</code>字段中通过<code>ipc</code>开启了一条IPC通道，之后就可以监听子进程对象的<code>message</code>事件接收来自子进程的消息，并通过<code>.send</code>方法给子进程发送消息。在子进程这边，可以在<code>process</code>对象上监听<code>message</code>事件接收来自父进程的消息，并通过<code>.send</code>方法向父进程发送消息。数据在传递过程中，会先在发送端使用<code>JSON.stringify</code>方法序列化，再在接收端使用<code>JSON.parse</code>方法反序列化。</p>
<h4 id="如何守护子进程"><a href="#如何守护子进程" class="headerlink" title="如何守护子进程"></a>如何守护子进程</h4><p>守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。以下是一种实现方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* daemon.js */</div><div class="line">function spawn(mainModule) &#123;</div><div class="line">    var worker = child_process.spawn(&apos;node&apos;, [ mainModule ]);</div><div class="line"></div><div class="line">    worker.on(&apos;exit&apos;, function (code) &#123;</div><div class="line">        if (code !== 0) &#123;</div><div class="line">            spawn(mainModule);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">spawn(&apos;worker.js&apos;);</div></pre></td></tr></table></figure>
<p>可以看到，工作进程非正常退出时，守护进程立即重启工作进程。</p>
<ul>
<li>使用<code>process</code>对象管理自身。</li>
<li>使用<code>child_process</code>模块创建和管理子进程。</li>
</ul>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>NodeJS最大的卖点——事件机制和异步IO，对开发者并不是透明的。开发者需要按异步方式编写代码才用得上这个卖点</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p>
<p>但是，如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线程，那情况又不一样了。</p>
<p>JS本身是单线程的，无法异步执行，因此我们可以认为<code>setTimeout</code>这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了<code>setTimeout</code>、<code>setInterval</code>这些常见的，这类函数还包括NodeJS提供的诸如<code>fs.readFile</code>之类的异步API。</p>
<p>另外，我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    var count = 0,</div><div class="line">        i, j;</div><div class="line"></div><div class="line">    for (i = n; i &gt; 0; --i) &#123;</div><div class="line">        for (j = n; j &gt; 0; --j) &#123;</div><div class="line">            count += 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var t = new Date();</div><div class="line"></div><div class="line">setTimeout(function () &#123;</div><div class="line">    console.log(new Date() - t);</div><div class="line">&#125;, 1000);</div><div class="line"></div><div class="line">heavyCompute(50000);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line"></div><div class="line">3039</div></pre></td></tr></table></figure>
<p>可以看到，本来应该在1秒后被调用的回调函数因为JS主线程忙于运行其它代码，实际执行时间被大幅延迟。</p>
<h3 id="代码设计模式"><a href="#代码设计模式" class="headerlink" title="代码设计模式"></a>代码设计模式</h3><p>异步编程有很多特有的代码设计模式，为了实现同样的功能，使用同步方式和异步方式编写的代码会有很大差异。以下分别介绍一些常见的模式。</p>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>使用一个函数的输出作为另一个函数的输入是很常见的需求，在同步方式下一般按以下方式编写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var output = fn1(fn2(&apos;input&apos;));</div><div class="line">// Do something.</div></pre></td></tr></table></figure>
<p>而在异步方式下，由于函数执行结果不是通过返回值，而是通过回调函数传递，因此一般按以下方式编写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fn2(&apos;input&apos;, function (output2) &#123;</div><div class="line">    fn1(output2, function (output1) &#123;</div><div class="line">        // Do something.</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p>在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。如果函数是同步执行的，一般就会写出以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var len = arr.length,</div><div class="line">    i = 0;</div><div class="line"></div><div class="line">for (; i &lt; len; ++i) &#123;</div><div class="line">    arr[i] = sync(arr[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// All array items have processed.</div></pre></td></tr></table></figure>
<p>如果函数是异步执行的，以上代码就无法保证循环结束后所有数组成员都处理完毕了。如果数组成员必须一个接一个串行处理，则一般按照以下方式编写异步代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(function next(i, len, callback) &#123;</div><div class="line">    if (i &lt; len) &#123;</div><div class="line">        async(arr[i], function (value) &#123;</div><div class="line">            arr[i] = value;</div><div class="line">            next(i + 1, len, callback);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        callback();</div><div class="line">    &#125;</div><div class="line">&#125;(0, arr.length, function () &#123;</div><div class="line">    // All array items have processed.</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>这里的 <code>callback</code> 是在所有的异步遍历执行完毕以后才会被调用。</p>
<p>可以看到，以上代码在异步函数执行一次并返回执行结果后才传入下一个数组成员并开始下一轮执行，直到所有数组成员处理完毕后，通过回调的方式触发后续代码的执行。</p>
<p>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let arr = [1, 2, 3, 4, 5];</div><div class="line"></div><div class="line">(function next(i, a, callback) &#123;</div><div class="line">	if (i &lt; a.length) &#123;</div><div class="line">		setTimeout(function() &#123;</div><div class="line">			console.log(&apos;go to loop: &apos; + a[i]);</div><div class="line">			next(i+1, a, callback)</div><div class="line">		&#125;, 1000)</div><div class="line">	&#125; else &#123;</div><div class="line">		callback();</div><div class="line">	&#125;</div><div class="line">&#125;(0, arr, function() &#123;</div><div class="line">	console.log(&apos;async method end&apos;);</div><div class="line">&#125;))</div></pre></td></tr></table></figure>
<p>如果数组成员可以并行处理，但后续代码仍然需要所有数组成员处理完毕后才能执行的话，则异步代码会调整成以下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(function (i, len, count, callback) &#123;</div><div class="line">    for (; i &lt; len; ++i) &#123;</div><div class="line">        (function (i) &#123;</div><div class="line">            async(arr[i], function (value) &#123;</div><div class="line">                arr[i] = value;</div><div class="line">                if (++count === len) &#123;</div><div class="line">                    callback();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;(i));</div><div class="line">    &#125;</div><div class="line">&#125;(0, arr.length, 0, function () &#123;</div><div class="line">    // All array items have processed.</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p>可以看到，与异步串行遍历的版本相比，以上代码并行处理所有数组成员，并通过计数器变量来判断什么时候所有数组成员都处理完毕了。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>JS自身提供的异常捕获和处理机制——<code>try..catch..</code>，只能用于同步执行的代码。</p>
<p>可以看到，异常会沿着代码执行路径一直冒泡，直到遇到第一个<code>try</code>语句时被捕获住。但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到<code>try</code>语句，就作为一个全局异常抛出。</p>
<p>因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用<code>try</code>语句把异常捕获住，并通过回调函数传递被捕获的异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function async(fn, callback) &#123;</div><div class="line">    // Code execution path breaks here.</div><div class="line">    setTimeout(function ()　&#123;</div><div class="line">        try &#123;</div><div class="line">            callback(null, fn());</div><div class="line">        &#125; catch (err) &#123;</div><div class="line">            callback(err);</div><div class="line">        &#125;</div><div class="line">    &#125;, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">async(null, function (err, data) &#123;</div><div class="line">    if (err) &#123;</div><div class="line">        console.log(&apos;Error: %s&apos;, err.message);</div><div class="line">    &#125; else &#123;</div><div class="line">        // Do something.</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">-- Console ------------------------------</div><div class="line">Error: object is not a function</div></pre></td></tr></table></figure>
<p>意思就是在回调函数 <code>callback</code> 中，如果有需要被捕获的 <code>err</code> 参数，（通常是通过 API 查询看会获得什么参数），就在 <code>callback</code> 函数中处理 <code>err</code>。</p>
<p>但是如果回调函数嵌套异步执行函数，异步执行函数又需要回调函数处理其得到的值，就会形成回调函数嵌套回调函数的情况出现，严重影响代码的可读性，我们称之为<strong>回调地狱</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function main(callback) &#123;</div><div class="line">    // Do something.</div><div class="line">    asyncA(function (err, data) &#123;</div><div class="line">        if (err) &#123;</div><div class="line">            callback(err);</div><div class="line">        &#125; else &#123;</div><div class="line">            // Do something</div><div class="line">            asyncB(function (err, data) &#123;</div><div class="line">                if (err) &#123;</div><div class="line">                    callback(err);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // Do something</div><div class="line">                    asyncC(function (err, data) &#123;</div><div class="line">                        if (err) &#123;</div><div class="line">                            callback(err);</div><div class="line">                        &#125; else &#123;</div><div class="line">                            // Do something</div><div class="line">                            callback(null);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(function (err) &#123;</div><div class="line">    if (err) &#123;</div><div class="line">        // Deal with exception.</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们可以使用 <code>domain</code> 模块来处理多重回调函数嵌套的问题，也可以使用新的异步处理方法，如：</p>
<ul>
<li><code>promise</code></li>
<li><code>Generator</code></li>
<li><code>await/async</code></li>
</ul>
<h2 id="大示例"><a href="#大示例" class="headerlink" title="大示例"></a>大示例</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>我们要开发的是一个简单的静态文件合并服务器，该服务器需要支持类似以下格式的JS或CSS文件合并请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://assets.example.com/foo/??bar.js,baz.js</div></pre></td></tr></table></figure>
<p>在以上URL中，<code>??</code>是一个分隔符，之前是需要合并的多个文件的URL的公共部分，之后是使用<code>,</code>分隔的差异部分。因此服务器处理这个URL时，返回的是以下两个文件按顺序合并后的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/foo/bar.js</div><div class="line">/foo/baz.js</div></pre></td></tr></table></figure>
<p>另外，服务器也需要能支持类似以下格式的普通的JS或CSS文件请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://assets.example.com/foo/bar.js</div></pre></td></tr></table></figure>
<h3 id="第一次迭代"><a href="#第一次迭代" class="headerlink" title="第一次迭代"></a>第一次迭代</h3><p>简单分析了需求之后，我们大致会得到以下的设计方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          +---------+  +-----------+  +----------+</div><div class="line">request--&gt;| parse  |--&gt;|  combine |--&gt;| output |--&gt; response</div><div class="line">          +---------+  +-----------+  +----------+</div></pre></td></tr></table></figure>
<p>也就是说，服务器会首先分析URL，得到请求的文件的路径和类型（MIME）。然后，服务器会读取请求的文件，并按顺序合并文件内容。最后，服务器返回响应，完成对一次请求的处理。</p>
<p>另外，服务器在读取文件时需要有个根目录，并且服务器监听的HTTP端口最好也不要写死在代码里，因此服务器需要是可配置的。</p>
<p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;),</div><div class="line">    path = require(&apos;path&apos;),</div><div class="line">    http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">var MIME = &#123;</div><div class="line">    &apos;.css&apos;: &apos;text/css&apos;,</div><div class="line">    &apos;.js&apos;: &apos;application/javascript&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function combineFiles(pathnames, callback) &#123;</div><div class="line">    var output = [];</div><div class="line"></div><div class="line">    (function next(i, len) &#123;</div><div class="line">        if (i &lt; len) &#123;</div><div class="line">            fs.readFile(pathnames[i], function (err, data) &#123;</div><div class="line">                if (err) &#123;</div><div class="line">                    callback(err);</div><div class="line">                &#125; else &#123;</div><div class="line">                    output.push(data);</div><div class="line">                    next(i + 1, len);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; else &#123;</div><div class="line">            callback(null, Buffer.concat(output));</div><div class="line">        &#125;</div><div class="line">    &#125;(0, pathnames.length));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">    var config = JSON.parse(fs.readFileSync(argv[0], &apos;utf-8&apos;)),</div><div class="line">        root = config.root || &apos;.&apos;,</div><div class="line">        port = config.port || 80;</div><div class="line"></div><div class="line">    http.createServer(function (request, response) &#123;</div><div class="line">        var urlInfo = parseURL(root, request.url);</div><div class="line"></div><div class="line">        combineFiles(urlInfo.pathnames, function (err, data) &#123;</div><div class="line">            if (err) &#123;</div><div class="line">                response.writeHead(404);</div><div class="line">                response.end(err.message);</div><div class="line">            &#125; else &#123;</div><div class="line">                response.writeHead(200, &#123;</div><div class="line">                    &apos;Content-Type&apos;: urlInfo.mime</div><div class="line">                &#125;);</div><div class="line">                response.end(data);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;).listen(port);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function parseURL(root, url) &#123;</div><div class="line">    var base, pathnames, parts;</div><div class="line"></div><div class="line">    if (url.indexOf(&apos;??&apos;) === -1) &#123;</div><div class="line">        url = url.replace(&apos;/&apos;, &apos;/??&apos;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    parts = url.split(&apos;??&apos;);</div><div class="line">    base = parts[0];</div><div class="line">    pathnames = parts[1].split(&apos;,&apos;).map(function (value) &#123;</div><div class="line">        return path.join(root, base, value);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return &#123;</div><div class="line">        mime: MIME[path.extname(pathnames[0])] || &apos;text/plain&apos;,</div><div class="line">        pathnames: pathnames</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p><code>config.js</code> 文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&quot;root&quot; : &quot;.&quot;,</div><div class="line">	&quot;port&quot; : 8888</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码完整实现了服务器所需的功能，并且有以下几点值得注意：</p>
<ol>
<li>使用命令行参数传递JSON配置文件路径，入口函数负责读取配置并创建服务器。</li>
<li>入口函数完整描述了程序的运行逻辑，其中解析URL和合并文件的具体实现封装在其它两个函数里。</li>
<li>解析URL时先将普通URL转换为了文件合并URL，使得两种URL的处理方式可以一致。</li>
<li>合并文件时使用异步API读取文件，避免服务器因等待磁盘IO而发生阻塞。</li>
</ol>
<p>我们可以把以上代码保存为<code>test.js</code>，之后就可以通过<code>node test.js config.json</code>命令启动程序，于是我们的第一版静态文件合并服务器就顺利完工了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:8888/test/??test.js,test1.js</div></pre></td></tr></table></figure>
<p>访问以上链接，可以在浏览器得到 test.js 和 test1.js 中的代码。</p>
<p>另外，以上代码存在一个不那么明显的逻辑缺陷。例如，使用以下URL请求服务器时会有惊喜。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:8888/test/test.js,test1.js</div></pre></td></tr></table></figure>
<p>经过分析之后我们会发现问题出在/被自动替换/??这个行为上，而这个问题我们可以到第二次迭代时再解决。</p>
<h3 id="第二次迭代"><a href="#第二次迭代" class="headerlink" title="第二次迭代"></a>第二次迭代</h3><p>把<code>map</code>方法换成<code>for</code>循环或许会更快一些，但第一版代码最大的性能问题存在于从读取文件到输出响应的过程当中。我们以处理<code>/??a.js,b.js,c.js</code>这个请求为例，看看整个处理过程中耗时在哪儿。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> 发送请求       等待服务端响应         接收响应</div><div class="line">---------+----------------------+-------------&gt;</div><div class="line">         --                                        解析请求</div><div class="line">           ------                                  读取a.js</div><div class="line">                 ------                            读取b.js</div><div class="line">                       ------                      读取c.js</div><div class="line">                             --                    合并数据</div><div class="line">                               --                  输出响应</div></pre></td></tr></table></figure>
<p>可以看到，第一版代码依次把请求的文件读取到内存中之后，再合并数据和输出响应。这会导致以下两个问题：</p>
<ol>
<li>当请求的文件比较多比较大时，串行读取文件会比较耗时，从而拉长了服务端响应等待时间。</li>
<li>由于每次响应输出的数据都需要先完整地缓存在内存里，当服务器请求并发数较大时，会有较大的内存开销。</li>
</ol>
<p>对于第一个问题，很容易想到把读取文件的方式从串行改为并行。但是别这样做，因为对于机械磁盘而言，因为只有一个磁头，尝试并行读取文件只会造成磁头频繁抖动，反而降低IO效率。而对于固态硬盘，虽然的确存在多个并行IO通道，但是对于服务器并行处理的多个请求而言，硬盘已经在做并行IO了，对单个请求采用并行IO无异于拆东墙补西墙。因此，正确的做法不是改用并行IO，而是一边读取文件一边输出响应，把响应输出时机提前至读取第一个文件的时刻。这样调整后，整个请求处理过程变成下边这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">发送请求 等待服务端响应 接收响应</div><div class="line">---------+----+-------------------------------&gt;</div><div class="line">         --                                        解析请求</div><div class="line">           --                                      检查文件是否存在</div><div class="line">             --                                    输出响应头</div><div class="line">               ------                              读取和输出a.js</div><div class="line">                     ------                        读取和输出b.js</div><div class="line">                           ------                  读取和输出c.js</div></pre></td></tr></table></figure>
<p>根据以上设计，第二版代码按以下方式调整了部分函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">function main(argv) &#123;</div><div class="line">    var config = JSON.parse(fs.readFileSync(argv[0], &apos;utf-8&apos;)),</div><div class="line">        root = config.root || &apos;.&apos;,</div><div class="line">        port = config.port || 80;</div><div class="line"></div><div class="line">    http.createServer(function (request, response) &#123;</div><div class="line">        var urlInfo = parseURL(root, request.url);</div><div class="line"></div><div class="line">        validateFiles(urlInfo.pathnames, function (err, pathnames) &#123;</div><div class="line">            if (err) &#123;</div><div class="line">                response.writeHead(404);</div><div class="line">                response.end(err.message);</div><div class="line">            &#125; else &#123;</div><div class="line">                response.writeHead(200, &#123;</div><div class="line">                    &apos;Content-Type&apos;: urlInfo.mime</div><div class="line">                &#125;);</div><div class="line">                outputFiles(pathnames, response);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;).listen(port);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function outputFiles(pathnames, writer) &#123;</div><div class="line">    (function next(i, len) &#123;</div><div class="line">        if (i &lt; len) &#123;</div><div class="line">            var reader = fs.createReadStream(pathnames[i]);</div><div class="line"></div><div class="line">            reader.pipe(writer, &#123; end: false &#125;);</div><div class="line">            reader.on(&apos;end&apos;, function() &#123;</div><div class="line">                next(i + 1, len);</div><div class="line">            &#125;);</div><div class="line">        &#125; else &#123;</div><div class="line">            writer.end();</div><div class="line">        &#125;</div><div class="line">    &#125;(0, pathnames.length));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function validateFiles(pathnames, callback) &#123;</div><div class="line">    (function next(i, len) &#123;</div><div class="line">        if (i &lt; len) &#123;</div><div class="line">            fs.stat(pathnames[i], function (err, stats) &#123;</div><div class="line">                if (err) &#123;</div><div class="line">                    callback(err);</div><div class="line">                &#125; else if (!stats.isFile()) &#123;</div><div class="line">                    callback(new Error());</div><div class="line">                &#125; else &#123;</div><div class="line">                    next(i + 1, len);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; else &#123;</div><div class="line">            callback(null, pathnames);</div><div class="line">        &#125;</div><div class="line">    &#125;(0, pathnames.length));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改部分有：</p>
<ol>
<li>使用 <code>fs.stat</code> 来判断路径是否存在，来判断该路径对应的是否为一个文件</li>
<li>添加 <code>outputFiles</code> 文件，使用 <code>readStream</code> 来进行对 <code>response</code> 对象的大文件异步数据流写入，并且每读取完一个文件都进行一次写入，而不是先用一个数组存在本地。</li>
</ol>
<h3 id="第三次迭代"><a href="#第三次迭代" class="headerlink" title="第三次迭代"></a>第三次迭代</h3><p>一般生产环境下的服务器程序都配有一个守护进程，在服务挂掉的时候立即重启服务。一般守护进程的代码会远比服务进程的代码简单，从概率上可以保证守护进程更难挂掉。如果再做得严谨一些，甚至守护进程自身可以在自己挂掉时重启自己，从而实现双保险。</p>
<p>因此在本次迭代时，我们先利用NodeJS的进程管理机制，将守护进程作为父进程，将服务器程序作为子进程，并让父进程监控子进程的运行状态，在其异常退出时重启子进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var cp = require(&apos;child_process&apos;);</div><div class="line"></div><div class="line">var worker;</div><div class="line"></div><div class="line">function spawn(server, config) &#123;</div><div class="line">    worker = cp.spawn(&apos;node&apos;, [ server, config ]);</div><div class="line">    worker.on(&apos;exit&apos;, function (code) &#123;</div><div class="line">        if (code !== 0) &#123;</div><div class="line">            spawn(server, config);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">    spawn(&apos;server.js&apos;, argv[0]);</div><div class="line">    process.on(&apos;SIGTERM&apos;, function () &#123;</div><div class="line">        worker.kill();</div><div class="line">        process.exit(0);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p>此外，服务器代码本身的入口函数也要做以下调整</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function main(argv) &#123;</div><div class="line">    var config = JSON.parse(fs.readFileSync(argv[0], &apos;utf-8&apos;)),</div><div class="line">        root = config.root || &apos;.&apos;,</div><div class="line">        port = config.port || 80,</div><div class="line">        server;</div><div class="line"></div><div class="line">    server = http.createServer(function (request, response) &#123;</div><div class="line">        ...</div><div class="line">    &#125;).listen(port);</div><div class="line"></div><div class="line">    process.on(&apos;SIGTERM&apos;, function () &#123;</div><div class="line">        server.close(function () &#123;</div><div class="line">            process.exit(0);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以把守护进程的代码保存为<code>daemon.js</code>，之后我们可以通过<code>node daemon.js config.json</code>启动服务，而守护进程会进一步启动和监控服务器进程。此外，为了能够正常终止服务，我们让守护进程在接收到<code>SIGTERM</code>信号时终止服务器进程。而在服务器进程这一端，同样在收到<code>SIGTERM</code>信号时先停掉HTTP服务再正常退出。至此，我们的服务器程序就靠谱很多了。</p>
<h3 id="第四次迭代"><a href="#第四次迭代" class="headerlink" title="第四次迭代"></a>第四次迭代</h3><p>在我们解决了服务器本身的功能、性能和可靠性的问题后，接着我们需要考虑一下代码部署的问题，以及服务器控制的问题。</p>
<p>一般而言，程序在服务器上有一个固定的部署目录，每次程序有更新后，都重新发布到部署目录里。而一旦完成部署后，一般也可以通过固定的服务控制脚本启动和停止服务。因此我们的服务器程序部署目录可以做如下设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- deploy/</div><div class="line">    - bin/</div><div class="line">        startws.sh</div><div class="line">        killws.sh</div><div class="line">    + conf/</div><div class="line">        config.json</div><div class="line">    + lib/</div><div class="line">        daemon.js</div><div class="line">        server.js</div></pre></td></tr></table></figure>
<p>在以上目录结构中，我们分类存放了服务控制脚本、配置文件和服务器代码。</p>
<p>按以上目录结构分别存放对应的文件之后，接下来我们看看控制脚本怎么写。首先是start.sh。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">if [ ! -f &quot;pid&quot; ]</div><div class="line">then</div><div class="line">    node ../lib/daemon.js ../conf/config.json &amp;</div><div class="line">    echo $! &gt; pid</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>然后是killws.sh。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line">if [ -f &quot;pid&quot; ]</div><div class="line">then</div><div class="line">    kill $(tr -d &apos;\r\n&apos; &lt; pid)</div><div class="line">    rm pid</div><div class="line">fi</div></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Node-js/" rel="tag"># Node.js</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/05/Node-js入门/" rel="next" title="Node.js入门">
                <i class="fa fa-chevron-left"></i> Node.js入门
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/12/Node-js-包教不会笔记/" rel="prev" title="Node.js 包教不会笔记">
                Node.js 包教不会笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/03/07/Node-js-基础总结/"
           data-title="Node.js 基础总结" data-url="https://shiningdan.github.io/2017/03/07/Node-js-基础总结/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg"
               alt="ShiningDan" />
          <p class="site-author-name" itemprop="name">ShiningDan</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">93</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">77</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#NodeJS基础"><span class="nav-number">1.</span> <span class="nav-text">NodeJS基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模块"><span class="nav-number">1.1.</span> <span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#require"><span class="nav-number">1.1.1.</span> <span class="nav-text">require</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exports"><span class="nav-number">1.2.</span> <span class="nav-text">exports</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#module"><span class="nav-number">1.3.</span> <span class="nav-text">module</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块初始化"><span class="nav-number">1.4.</span> <span class="nav-text">模块初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制模块"><span class="nav-number">1.5.</span> <span class="nav-text">二进制模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码的组织和部署"><span class="nav-number">2.</span> <span class="nav-text">代码的组织和部署</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模块路径解析规则"><span class="nav-number">2.1.</span> <span class="nav-text">模块路径解析规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内置模块"><span class="nav-number">2.1.1.</span> <span class="nav-text">内置模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#node-modules目录"><span class="nav-number">2.1.2.</span> <span class="nav-text">node_modules目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NODE-PATH环境变量"><span class="nav-number">2.1.3.</span> <span class="nav-text">NODE_PATH环境变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包（package）"><span class="nav-number">2.2.</span> <span class="nav-text">包（package）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#index-js"><span class="nav-number">2.2.1.</span> <span class="nav-text">index.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#package-json"><span class="nav-number">2.2.2.</span> <span class="nav-text">package.json</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令行程序"><span class="nav-number">2.3.</span> <span class="nav-text">命令行程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux"><span class="nav-number">2.3.1.</span> <span class="nav-text">Linux</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工程目录"><span class="nav-number">2.4.</span> <span class="nav-text">工程目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NPM"><span class="nav-number">2.5.</span> <span class="nav-text">NPM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发布代码"><span class="nav-number">2.5.1.</span> <span class="nav-text">发布代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#版本号"><span class="nav-number">2.5.2.</span> <span class="nav-text">版本号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#npm-常用命令"><span class="nav-number">2.5.3.</span> <span class="nav-text">npm 常用命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件操作"><span class="nav-number">3.</span> <span class="nav-text">文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小文件拷贝"><span class="nav-number">3.1.</span> <span class="nav-text">小文件拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大文件拷贝"><span class="nav-number">3.2.</span> <span class="nav-text">大文件拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer（数据块）"><span class="nav-number">3.3.</span> <span class="nav-text">Buffer（数据块）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream（数据流）"><span class="nav-number">3.4.</span> <span class="nav-text">Stream（数据流）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File-System（文件系统）"><span class="nav-number">3.5.</span> <span class="nav-text">File System（文件系统）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Path（路径）"><span class="nav-number">3.6.</span> <span class="nav-text">Path（路径）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#path-normalize"><span class="nav-number">3.6.1.</span> <span class="nav-text">path.normalize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#path-join"><span class="nav-number">3.6.2.</span> <span class="nav-text">path.join</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#path-extname"><span class="nav-number">3.6.3.</span> <span class="nav-text">path.extname</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历目录"><span class="nav-number">3.7.</span> <span class="nav-text">遍历目录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步遍历"><span class="nav-number">3.7.1.</span> <span class="nav-text">同步遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步遍历"><span class="nav-number">3.7.2.</span> <span class="nav-text">异步遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文本编码"><span class="nav-number">3.8.</span> <span class="nav-text">文本编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BOM的移除"><span class="nav-number">3.8.1.</span> <span class="nav-text">BOM的移除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GBK转UTF8"><span class="nav-number">3.8.2.</span> <span class="nav-text">GBK转UTF8</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单字节编码"><span class="nav-number">3.8.3.</span> <span class="nav-text">单字节编码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络操作"><span class="nav-number">4.</span> <span class="nav-text">网络操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP"><span class="nav-number">4.1.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-服务器端"><span class="nav-number">4.1.1.</span> <span class="nav-text">HTTP 服务器端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-客户端"><span class="nav-number">4.1.2.</span> <span class="nav-text">HTTP 客户端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS"><span class="nav-number">4.2.</span> <span class="nav-text">HTTPS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL"><span class="nav-number">4.3.</span> <span class="nav-text">URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#querystring"><span class="nav-number">4.4.</span> <span class="nav-text">querystring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zlib"><span class="nav-number">4.5.</span> <span class="nav-text">zlib</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Net"><span class="nav-number">4.6.</span> <span class="nav-text">Net</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程管理"><span class="nav-number">5.</span> <span class="nav-text">进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Process"><span class="nav-number">5.1.</span> <span class="nav-text">Process</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Child-Process"><span class="nav-number">5.2.</span> <span class="nav-text">Child Process</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cluster"><span class="nav-number">5.3.</span> <span class="nav-text">Cluster</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用场景"><span class="nav-number">5.4.</span> <span class="nav-text">应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何获取命令行参数"><span class="nav-number">5.4.1.</span> <span class="nav-text">如何获取命令行参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何退出程序"><span class="nav-number">5.4.2.</span> <span class="nav-text">如何退出程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何控制输入输出"><span class="nav-number">5.4.3.</span> <span class="nav-text">如何控制输入输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何降权"><span class="nav-number">5.4.4.</span> <span class="nav-text">如何降权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何创建子进程"><span class="nav-number">5.4.5.</span> <span class="nav-text">如何创建子进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程间如何通讯"><span class="nav-number">5.4.6.</span> <span class="nav-text">进程间如何通讯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何守护子进程"><span class="nav-number">5.4.7.</span> <span class="nav-text">如何守护子进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步编程"><span class="nav-number">6.</span> <span class="nav-text">异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回调"><span class="nav-number">6.1.</span> <span class="nav-text">回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码设计模式"><span class="nav-number">6.2.</span> <span class="nav-text">代码设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数返回值"><span class="nav-number">6.2.1.</span> <span class="nav-text">函数返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历数组"><span class="nav-number">6.2.2.</span> <span class="nav-text">遍历数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异常处理"><span class="nav-number">6.2.3.</span> <span class="nav-text">异常处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大示例"><span class="nav-number">7.</span> <span class="nav-text">大示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#需求"><span class="nav-number">7.1.</span> <span class="nav-text">需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一次迭代"><span class="nav-number">7.2.</span> <span class="nav-text">第一次迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二次迭代"><span class="nav-number">7.3.</span> <span class="nav-text">第二次迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三次迭代"><span class="nav-number">7.4.</span> <span class="nav-text">第三次迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四次迭代"><span class="nav-number">7.5.</span> <span class="nav-text">第四次迭代</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShiningDan</span>
</div>



        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"shiningdan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js?v=5.1.0"></script>
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("nr3cyUXVpbTxQQRcqfMp5cHa-gzGzoHsz", "B1SG80mnbseYxv4C0vAjig8s");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
