<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="JavaScript,LeetCode,Java,Tree,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="下面所记录的是我在刷 LeetCode Array 相关的题目自己的解法。 100. Same TreeGiven two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical">
<meta name="keywords" content="JavaScript,LeetCode,Java,Tree">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode Tree题集">
<meta property="og:url" content="https://shiningdan.github.io/2017/02/12/LeetCode-Tree题集/index.html">
<meta property="og:site_name" content="ShiningDan的博客">
<meta property="og:description" content="下面所记录的是我在刷 LeetCode Array 相关的题目自己的解法。 100. Same TreeGiven two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-02-22T13:10:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode Tree题集">
<meta name="twitter:description" content="下面所记录的是我在刷 LeetCode Array 相关的题目自己的解法。 100. Same TreeGiven two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6345612185049236000',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://shiningdan.github.io/2017/02/12/LeetCode-Tree题集/">





  <title> LeetCode Tree题集 | ShiningDan的博客 </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?65f098889042a1740b5cfede967d34b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ShiningDan的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description"></h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photography">
          <a href="/categories/photography" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            摄影
          </a>
        </li>
      
        
        <li class="menu-item menu-item-coding">
          <a href="/categories/coding" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            编程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://shiningdan.github.io/2017/02/12/LeetCode-Tree题集/">

  <span style="display:none" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ShiningDan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ShiningDan的博客">
    <span style="display:none" itemprop="logo" itemscope="" itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ShiningDan的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                LeetCode Tree题集
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-12T21:43:54+08:00">
                2017-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/coding/" itemprop="url" rel="index">
                    <span itemprop="name">coding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/12/LeetCode-Tree题集/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/12/LeetCode-Tree题集/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/02/12/LeetCode-Tree题集/" class="leancloud_visitors" data-flag-title="LeetCode Tree题集">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>下面所记录的是我在刷 <a href="https://leetcode.com" target="_blank" rel="noopener">LeetCode</a> Array 相关的题目自己的解法。</p>
<h4 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">100. Same Tree</a></h4><p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value</p>
<h4 id="JavaScript-Solution"><a href="#JavaScript-Solution" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; p</span><br><span class="line"> * @param &#123;TreeNode&#125; q</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isSameTree = function(p, q) &#123;</span><br><span class="line">    if (p === null &amp;&amp; q === null) return true;</span><br><span class="line">    if (p === null || q === null) return false;</span><br><span class="line">    return (p.val === q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Java-Solution"><a href="#Java-Solution" class="headerlink" title="Java Solution"></a>Java Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (p == null &amp;&amp; q == null) return true;</span><br><span class="line">        if (p == null || q == null) return false;</span><br><span class="line">        return (p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. Symmetric Tree</a></h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>Bonus points if you could solve it both recursively and iteratively.</p>
<h4 id="JavaScript-Solution-1"><a href="#JavaScript-Solution-1" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><p>使用的是递归。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isSymmetric = function(root) &#123;</span><br><span class="line">	let isSymmetricTree = function(p, q) &#123;</span><br><span class="line">    	if (p === null &amp;&amp; q === null) return true;</span><br><span class="line">    	if (p === null || q === null) return false;</span><br><span class="line">    	return (p.val === q.val &amp;&amp; isSymmetricTree(p.left, q.right) &amp;&amp; isSymmetricTree(p.right, q.left));</span><br><span class="line">    &#125;</span><br><span class="line">    if (root === null) return true;</span><br><span class="line">    return isSymmetricTree(root.left, root.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Java-Solution-1"><a href="#Java-Solution-1" class="headerlink" title="Java Solution"></a>Java Solution</h4><p>使用的是循环，利用 Stack 来存储要比较的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        if (root == null) return true;</span><br><span class="line">        stack.push(root.left);</span><br><span class="line">        stack.push(root.right);</span><br><span class="line">        while (!stack.empty()) &#123;</span><br><span class="line">            TreeNode r = stack.pop();</span><br><span class="line">            TreeNode l = stack.pop();</span><br><span class="line">            if (r == null &amp;&amp; l == null) continue;</span><br><span class="line">            if (r == null || l == null) return false;</span><br><span class="line"></span><br><span class="line">            if (r.val != l.val) return false;</span><br><span class="line">            stack.push(l.left);</span><br><span class="line">            stack.push(r.right);</span><br><span class="line">            stack.push(l.right);</span><br><span class="line">            stack.push(r.left);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree</a></h3><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<h4 id="JavaScript-Solution-2"><a href="#JavaScript-Solution-2" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><p>深度优先搜索算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var maxDepth = function(root) &#123;</span><br><span class="line">    if (root === null) return 0;</span><br><span class="line">    return (1 + Math.max(maxDepth(root.left), maxDepth(root.right)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Java-Solution-2"><a href="#Java-Solution-2" class="headerlink" title="Java Solution"></a>Java Solution</h4><p>广度优先搜索算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if (root ==  null) return 0;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">        int deep = 0;</span><br><span class="line">        q.add(root);</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            int len = q.size();</span><br><span class="line">            deep ++;</span><br><span class="line">            for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">                TreeNode t = q.poll();</span><br><span class="line">                if (t.left != null) q.add(t.left);</span><br><span class="line">                if (t.right != null) q.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return deep;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107. Binary Tree Level Order Traversal II</a></h3><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="JavaScript-Solution-3"><a href="#JavaScript-Solution-3" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><p>使用广度优先遍历该树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> */</span><br><span class="line">var levelOrderBottom = function(root) &#123;</span><br><span class="line">    if (root === null) return [];</span><br><span class="line">    let result = [];</span><br><span class="line">    let a = [root];</span><br><span class="line">    while (a.length &gt; 0) &#123;</span><br><span class="line">    	let len = a.length;</span><br><span class="line">    	let rtmp = []</span><br><span class="line">    	for (let i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">    		let node = a.shift();</span><br><span class="line">    		rtmp.push(node.val);</span><br><span class="line">    		if (node.left !== null) a.push(node.left);</span><br><span class="line">    		if (node.right !== null) a.push(node.right);</span><br><span class="line">    	&#125;</span><br><span class="line">    	result.unshift(rtmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. Convert Sorted Array to Binary Search Tree</a></h3><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<h4 id="JavaScript-Solution-4"><a href="#JavaScript-Solution-4" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><p>通过一个排好序的数组，生成平衡二叉查找树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> */</span><br><span class="line">var sortedArrayToBST = function(nums) &#123;</span><br><span class="line">    if (nums.length === 0) return null;</span><br><span class="line"></span><br><span class="line">	let getMid = function(nums, low, high) &#123;</span><br><span class="line">		if (low &gt; high) return null;</span><br><span class="line">		let mid = Math.floor((low + high)/2);</span><br><span class="line">		let t = new TreeNode(nums[mid]);</span><br><span class="line">		t.left = getMid(nums, low, mid-1);</span><br><span class="line">		t.right = getMid(nums, mid+1, high);</span><br><span class="line">		return t;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	return getMid(nums, 0, nums.length-1);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. Balanced Binary Tree</a></h3><p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<h4 id="JavaScript-Solution-5"><a href="#JavaScript-Solution-5" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><p>1.The first method checks whether the tree is balanced strictly according to the definition of balanced binary tree: the difference between the heights of the two sub trees are not bigger than 1, and both the left sub tree and right sub tree are also balanced. With the helper function depth(), we could easily write the code;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isBalanced = function(root) &#123;</span><br><span class="line">	if (root === null) return true;</span><br><span class="line">    </span><br><span class="line">    let depth = function(node) &#123;</span><br><span class="line">    	if (node === null) return 0;</span><br><span class="line">    	return 1 + Math.max(depth(node.left), depth(node.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let leftDep = depth(root.left);</span><br><span class="line">    let rightDep = depth(root.right);</span><br><span class="line">    return Math.abs(leftDep - rightDep) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>For the current node root, calling depth() for its left and right children actually has to access all of its children, thus the complexity is O(N). We do this for each node in the tree, so the overall complexity of isBalanced will be O(N^2). This is a top down approach.</p>
<h4 id="Java-Solution-3"><a href="#Java-Solution-3" class="headerlink" title="Java Solution"></a>Java Solution</h4><p>2.The second method is based on DFS. Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the leftHeight and rightHeight of the two children, the parent node could check if the sub tree is balanced, and decides its return value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        int height = dfsHeight(root);</span><br><span class="line">        if (height == -1) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public int dfsHeight(TreeNode node) &#123;</span><br><span class="line">        if (node == null) return 0;</span><br><span class="line"></span><br><span class="line">        int leftDep = dfsHeight(node.left);</span><br><span class="line">        int rightDep = dfsHeight(node.right);</span><br><span class="line"></span><br><span class="line">        if (leftDep == -1 || rightDep == -1) return -1;</span><br><span class="line">        if (Math.abs(leftDep - rightDep) &gt; 1) return -1;</span><br><span class="line">        return 1 + Math.max(leftDep, rightDep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution.</p>
<h3 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. Minimum Depth of Binary Tree</a></h3><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<h4 id="JavaScript-Solution-6"><a href="#JavaScript-Solution-6" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var minDepth = function(root) &#123;</span><br><span class="line">    if (root === null) return 0;</span><br><span class="line"></span><br><span class="line">    let leftDep = minDepth(root.left);</span><br><span class="line">    let rightDep = minDepth(root.right);</span><br><span class="line">    return (leftDep === 0 || rightDep === 0) ?  leftDep + rightDep +1: 1 + Math.min(leftDep, rightDep);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum</a></h3><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure>
<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<h4 id="JavaScript-Solution-7"><a href="#JavaScript-Solution-7" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @param &#123;number&#125; sum</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var hasPathSum = function(root, sum) &#123;</span><br><span class="line">    if (root === null) return false;</span><br><span class="line">    </span><br><span class="line">    let calPath = function(node, _s, sum) &#123;</span><br><span class="line">    	if (node === null) return false;</span><br><span class="line">    	let s = _s + node.val;</span><br><span class="line">    	if (s === sum &amp;&amp; node.left === null &amp;&amp; node.right === null) return true;</span><br><span class="line">    	return calPath(node.left, s, sum) || calPath(node.right, s, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return calPath(root, 0, sum);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Best-Solution"><a href="#Best-Solution" class="headerlink" title="Best Solution"></a>Best Solution</h4><p>最优解和我的想法大致相同，但是在递归函数的参数设计上比我的要好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasPathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        if(root == null) return false;</span><br><span class="line">    </span><br><span class="line">        if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum - root.val == 0) return true;</span><br><span class="line">    </span><br><span class="line">        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. Invert Binary Tree</a></h3><p>Invert a binary tree.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<h4 id="JavaScript-Solution-8"><a href="#JavaScript-Solution-8" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><p>DFS</p>
<p>The below solution is correct, but it is also bound to the application stack, which means that it’s no so much scalable - (you can find the problem size that will overflow the stack and crash your application), so more robust solution would be to use stack data structure.</p>
<p>大意是，因为使用递归，并且没有使用尾递归，所以会导致栈溢出，最好不要这样写。可以使用队列，进行广度优先搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> */</span><br><span class="line">var invertTree = function(root) &#123;</span><br><span class="line">    if (root === null) return null;</span><br><span class="line">    [root.left, root.right] = [root.right, root.left];</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    return root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Java-Solution-4"><a href="#Java-Solution-4" class="headerlink" title="Java Solution"></a>Java Solution</h4><p>BFS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">        if (root == null) return root;</span><br><span class="line">        q.add(root);</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode n = q.poll();</span><br><span class="line">            TreeNode tmp = n.left;</span><br><span class="line">            n.left = n.right;</span><br><span class="line">            n.right = tmp;</span><br><span class="line">            if (n.left != null) q.add(n.left);</span><br><span class="line">            if (n.right != null) q.add(n.right);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. Lowest Common Ancestor of a Binary Search Tree</a></h4><p>Given a binary search tree (BST), find the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">lowest common ancestor (LCA)</a> of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    /              \</span><br><span class="line"> ___2__          ___8__</span><br><span class="line">/      \        /      \</span><br><span class="line">0      _4       7       9</span><br><span class="line">      /  \</span><br><span class="line">      3   5</span><br></pre></td></tr></table></figure>
<p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
<h4 id="JavaScript-Solution-9"><a href="#JavaScript-Solution-9" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><p>递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @param &#123;TreeNode&#125; p</span><br><span class="line"> * @param &#123;TreeNode&#125; q</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> */</span><br><span class="line">var lowestCommonAncestor = function(root, p, q) &#123;</span><br><span class="line">    if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    return root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Best-Solution-1"><a href="#Best-Solution-1" class="headerlink" title="Best Solution"></a>Best Solution</h4><p>非递归</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        while ((p.val - root.val) * (q.val - root.val) &gt; 0) &#123;</span><br><span class="line">            root = (p.val - root.val) &lt; 0 ? root.left: root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a><a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">257. Binary Tree Paths</a></h3><p>Given a binary tree, return all root-to-leaf paths.</p>
<p>For example, given the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></table></figure>
<p>All root-to-leaf paths are:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="JavaScript-Solution-10"><a href="#JavaScript-Solution-10" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;string[]&#125;</span><br><span class="line"> */</span><br><span class="line">var binaryTreePaths = function(root) &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    let getTreePath = function(node, path) &#123;</span><br><span class="line">    	if (node === null) return ;</span><br><span class="line">    	if (path !== &quot;&quot;) &#123;path = path + &quot;-&gt;&quot; + node.val;&#125;</span><br><span class="line">    	else path = path + node.val;</span><br><span class="line">    	if (node.left === null &amp;&amp; node.right === null) </span><br><span class="line">    		result.push(path);</span><br><span class="line">    	if (node.left !== null) </span><br><span class="line">    		getTreePath(node.left, path);</span><br><span class="line">    	if (node.right !== null) </span><br><span class="line">    		getTreePath(node.right, path);</span><br><span class="line">    &#125;</span><br><span class="line">    getTreePath(root, &quot;&quot;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Best-Solution-2"><a href="#Best-Solution-2" class="headerlink" title="Best Solution"></a>Best Solution</h4><p>最优解在递归的参数上进行 path 的修改，比我的解法上减少了更多的初始条件判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">    List&lt;String&gt; answer = new ArrayList&lt;String&gt;();</span><br><span class="line">    if (root != null) searchBT(root, &quot;&quot;, answer);</span><br><span class="line">    return answer;</span><br><span class="line">&#125;</span><br><span class="line">private void searchBT(TreeNode root, String path, List&lt;String&gt; answer) &#123;</span><br><span class="line">    if (root.left == null &amp;&amp; root.right == null) answer.add(path + root.val);</span><br><span class="line">    if (root.left != null) searchBT(root.left, path + root.val + &quot;-&gt;&quot;, answer);</span><br><span class="line">    if (root.right != null) searchBT(root.right, path + root.val + &quot;-&gt;&quot;, answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a><a href="https://leetcode.com/problems/sum-of-left-leaves/?tab=Description" target="_blank" rel="noopener">404. Sum of Left Leaves</a></h3><p>Find the sum of all left leaves in a given binary tree.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</span><br></pre></td></tr></table></figure>
<h4 id="JavaScript-Solution-11"><a href="#JavaScript-Solution-11" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><p>Iterative method.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var sumOfLeftLeaves = function(root) &#123;</span><br><span class="line">    let nodes = [];</span><br><span class="line">    let sum = 0;</span><br><span class="line">    if (root === null) return sum;</span><br><span class="line">    nodes.push(root);</span><br><span class="line">    while (nodes.length !== 0) &#123;</span><br><span class="line">    	let node = nodes.pop();</span><br><span class="line">    	if (node.left !== null) &#123;</span><br><span class="line">    		nodes.push(node.left);</span><br><span class="line">    		if (node.left.left === null &amp;&amp; node.left.right === null) </span><br><span class="line">    			sum += node.left.val;</span><br><span class="line">    	&#125;</span><br><span class="line">    	if (node.right !== null) &#123;</span><br><span class="line">    		nodes.push(node.right);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Java-Solution-5"><a href="#Java-Solution-5" class="headerlink" title="Java Solution"></a>Java Solution</h4><p>Recursive method</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int sumOfLeftLeaves(TreeNode root) &#123;</span><br><span class="line">    if(root == null) return 0;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    if(root.left != null) &#123;</span><br><span class="line">        if(root.left.left == null &amp;&amp; root.left.right == null) ans += root.left.val;</span><br><span class="line">        else ans += sumOfLeftLeaves(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += sumOfLeftLeaves(root.right);</span><br><span class="line">    </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. Path Sum III</a></h3><p>You are given a binary tree in which each node contains an integer value.</p>
<p>Find the number of paths that sum to a given value.</p>
<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure>
<h4 id="JavaScript-Solution-12"><a href="#JavaScript-Solution-12" class="headerlink" title="JavaScript Solution"></a>JavaScript Solution</h4><p>做法就是，遍历树，并且计算所有中间和的结果，放在 map 里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @param &#123;number&#125; sum</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var pathSum = function(root, sum) &#123;</span><br><span class="line">    let map = new Map();</span><br><span class="line">    let calPathSum = function(node, sums) &#123;</span><br><span class="line">    	if (node === null) &#123;return ;&#125;</span><br><span class="line">    	for (let i = 0; i &lt; sums.length; i ++) &#123;</span><br><span class="line">    		sums[i] += node.val;</span><br><span class="line">    	&#125;</span><br><span class="line">    	sums.push(node.val);</span><br><span class="line">    	for (let i = 0; i &lt; sums.length; i++) &#123;</span><br><span class="line">    		if (map.has(sums[i])) &#123;</span><br><span class="line">    			map.set(sums[i], map.get(sums[i]) + 1);</span><br><span class="line">    		&#125; else &#123;</span><br><span class="line">    			map.set(sums[i], 1);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	calPathSum(node.left, sums.concat());</span><br><span class="line">    	calPathSum(node.right, sums.concat());</span><br><span class="line">    &#125;</span><br><span class="line">    calPathSum(root, []);</span><br><span class="line">    if (map.has(sum)) &#123;return map.get(sum)&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Best-Solution-3"><a href="#Best-Solution-3" class="headerlink" title="Best Solution"></a>Best Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">       HashMap&lt;Integer, Integer&gt; preSum = new HashMap();</span><br><span class="line">       preSum.put(0,1);</span><br><span class="line">       return helper(root, 0, sum, preSum);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public int helper(TreeNode root, int currSum, int target, HashMap&lt;Integer, Integer&gt; preSum) &#123;</span><br><span class="line">       if (root == null) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       currSum += root.val;</span><br><span class="line">       int res = preSum.getOrDefault(currSum - target, 0);</span><br><span class="line">       preSum.put(currSum, preSum.getOrDefault(currSum, 0) + 1);</span><br><span class="line">       </span><br><span class="line">       res += helper(root.left, currSum, target, preSum) + helper(root.right, currSum, target, preSum);</span><br><span class="line">       preSum.put(currSum, preSum.get(currSum) - 1);</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501. Find Mode in Binary Search Tree"></a><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/?tab=Description" target="_blank" rel="noopener">501. Find Mode in Binary Search Tree</a></h3><p>Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>For example:</p>
<p>Given BST <code>[1,null,2,2]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>return <code>[2]</code>.</p>
<p><strong>Note:</strong> If a tree has more than one mode, you can return them in any order.</p>
<p><strong>Follow up: </strong>Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p>
<h4 id="Best-Solution-4"><a href="#Best-Solution-4" class="headerlink" title="Best Solution"></a>Best Solution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] findMode(TreeNode root) &#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        modes = new int[modeCount];</span><br><span class="line">        modeCount = 0;</span><br><span class="line">        currCount = 0;</span><br><span class="line">        inorder(root);</span><br><span class="line">        return modes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int currVal;</span><br><span class="line">    private int currCount = 0;</span><br><span class="line">    private int maxCount = 0;</span><br><span class="line">    private int modeCount = 0;</span><br><span class="line">    </span><br><span class="line">    private int[] modes;</span><br><span class="line"></span><br><span class="line">    private void handleValue(int val) &#123;</span><br><span class="line">        if (val != currVal) &#123;</span><br><span class="line">            currVal = val;</span><br><span class="line">            currCount = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        currCount++;</span><br><span class="line">        if (currCount &gt; maxCount) &#123;</span><br><span class="line">            maxCount = currCount;</span><br><span class="line">            modeCount = 1;</span><br><span class="line">        &#125; else if (currCount == maxCount) &#123;</span><br><span class="line">            if (modes != null)</span><br><span class="line">                modes[modeCount] = currVal;</span><br><span class="line">            modeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void inorder(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        handleValue(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
            <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/Tree/" rel="tag"># Tree</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/11/CSS3-Flex-布局/" rel="next" title="CSS3 Flex 布局">
                <i class="fa fa-chevron-left"></i> CSS3 Flex 布局
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/16/使用-React-和-Webpack-创建画廊应用/" rel="prev" title="使用 React 和 Webpack 创建画廊应用">
                使用 React 和 Webpack 创建画廊应用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/02/12/LeetCode-Tree题集/" data-title="LeetCode Tree题集" data-url="https://shiningdan.github.io/2017/02/12/LeetCode-Tree题集/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg" alt="ShiningDan">
          <p class="site-author-name" itemprop="name">ShiningDan</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">121</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">108</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#100-Same-Tree"><span class="nav-number">1.</span> <span class="nav-text">100. Same Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution"><span class="nav-number">2.</span> <span class="nav-text">JavaScript Solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-Solution"><span class="nav-number">3.</span> <span class="nav-text">Java Solution</span></a></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#101-Symmetric-Tree"><span class="nav-number"></span> <span class="nav-text">101. Symmetric Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-1"><span class="nav-number">1.</span> <span class="nav-text">JavaScript Solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-Solution-1"><span class="nav-number">2.</span> <span class="nav-text">Java Solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree"><span class="nav-number"></span> <span class="nav-text">104. Maximum Depth of Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-2"><span class="nav-number">1.</span> <span class="nav-text">JavaScript Solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-Solution-2"><span class="nav-number">2.</span> <span class="nav-text">Java Solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#107-Binary-Tree-Level-Order-Traversal-II"><span class="nav-number"></span> <span class="nav-text">107. Binary Tree Level Order Traversal II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-3"><span class="nav-number">1.</span> <span class="nav-text">JavaScript Solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-Convert-Sorted-Array-to-Binary-Search-Tree"><span class="nav-number"></span> <span class="nav-text">108. Convert Sorted Array to Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-4"><span class="nav-number">1.</span> <span class="nav-text">JavaScript Solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-Balanced-Binary-Tree"><span class="nav-number"></span> <span class="nav-text">110. Balanced Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-5"><span class="nav-number">1.</span> <span class="nav-text">JavaScript Solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-Solution-3"><span class="nav-number">2.</span> <span class="nav-text">Java Solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-Minimum-Depth-of-Binary-Tree"><span class="nav-number"></span> <span class="nav-text">111. Minimum Depth of Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-6"><span class="nav-number">1.</span> <span class="nav-text">JavaScript Solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112-Path-Sum"><span class="nav-number"></span> <span class="nav-text">112. Path Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-7"><span class="nav-number">1.</span> <span class="nav-text">JavaScript Solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Best-Solution"><span class="nav-number">2.</span> <span class="nav-text">Best Solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#226-Invert-Binary-Tree"><span class="nav-number"></span> <span class="nav-text">226. Invert Binary Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-8"><span class="nav-number">1.</span> <span class="nav-text">JavaScript Solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-Solution-4"><span class="nav-number">2.</span> <span class="nav-text">Java Solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="nav-number">3.</span> <span class="nav-text">235. Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-9"><span class="nav-number">4.</span> <span class="nav-text">JavaScript Solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Best-Solution-1"><span class="nav-number">5.</span> <span class="nav-text">Best Solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#257-Binary-Tree-Paths"><span class="nav-number"></span> <span class="nav-text">257. Binary Tree Paths</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-10"><span class="nav-number">1.</span> <span class="nav-text">JavaScript Solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Best-Solution-2"><span class="nav-number">2.</span> <span class="nav-text">Best Solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#404-Sum-of-Left-Leaves"><span class="nav-number"></span> <span class="nav-text">404. Sum of Left Leaves</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-11"><span class="nav-number">1.</span> <span class="nav-text">JavaScript Solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-Solution-5"><span class="nav-number">2.</span> <span class="nav-text">Java Solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#437-Path-Sum-III"><span class="nav-number"></span> <span class="nav-text">437. Path Sum III</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-Solution-12"><span class="nav-number">1.</span> <span class="nav-text">JavaScript Solution</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Best-Solution-3"><span class="nav-number">2.</span> <span class="nav-text">Best Solution</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#501-Find-Mode-in-Binary-Search-Tree"><span class="nav-number"></span> <span class="nav-text">501. Find Mode in Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Best-Solution-4"><span class="nav-number">1.</span> <span class="nav-text">Best Solution</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShiningDan</span>
</div>



        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"shiningdan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js?v=5.1.0"></script>
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("nr3cyUXVpbTxQQRcqfMp5cHa-gzGzoHsz", "B1SG80mnbseYxv4C0vAjig8s");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
