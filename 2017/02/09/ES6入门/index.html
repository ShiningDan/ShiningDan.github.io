<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ES6," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="本文是我在学习 ECMAScript 6 时的记录，用于个人查询总结。在学习的过程中参考过很多别人的文章，如有需要，可以根据链接详细学习：

ECMAScript 6 入门

ECMAScript 6简介ECMAScript和JavaScript的关系要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织E">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6入门">
<meta property="og:url" content="https://shiningdan.github.io/2017/02/09/ES6入门/index.html">
<meta property="og:site_name" content="ShiningDan的博客">
<meta property="og:description" content="本文是我在学习 ECMAScript 6 时的记录，用于个人查询总结。在学习的过程中参考过很多别人的文章，如有需要，可以根据链接详细学习：

ECMAScript 6 入门

ECMAScript 6简介ECMAScript和JavaScript的关系要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织E">
<meta property="og:updated_time" content="2017-02-14T12:29:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6入门">
<meta name="twitter:description" content="本文是我在学习 ECMAScript 6 时的记录，用于个人查询总结。在学习的过程中参考过很多别人的文章，如有需要，可以根据链接详细学习：

ECMAScript 6 入门

ECMAScript 6简介ECMAScript和JavaScript的关系要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织E">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6345612185049236000',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://shiningdan.github.io/2017/02/09/ES6入门/"/>





  <title> ES6入门 | ShiningDan的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?65f098889042a1740b5cfede967d34b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ShiningDan的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description"></h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photography">
          <a href="/categories/photography" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            摄影
          </a>
        </li>
      
        
        <li class="menu-item menu-item-coding">
          <a href="/categories/coding" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            编程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://shiningdan.github.io/2017/02/09/ES6入门/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ShiningDan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ShiningDan的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ShiningDan的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                ES6入门
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-09T16:38:32+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coding/" itemprop="url" rel="index">
                    <span itemprop="name">coding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/09/ES6入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/09/ES6入门/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/02/09/ES6入门/" class="leancloud_visitors" data-flag-title="ES6入门">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文是我在学习 ECMAScript 6 时的记录，用于个人查询总结。在学习的过程中参考过很多别人的文章，如有需要，可以根据链接详细学习：</p>
<ul>
<li><a href="http://es6.ruanyifeng.com" target="_blank" rel="external">ECMAScript 6 入门</a></li>
</ul>
<h2 id="ECMAScript-6简介"><a href="#ECMAScript-6简介" class="headerlink" title="ECMAScript 6简介"></a>ECMAScript 6简介</h2><h3 id="ECMAScript和JavaScript的关系"><a href="#ECMAScript和JavaScript的关系" class="headerlink" title="ECMAScript和JavaScript的关系"></a>ECMAScript和JavaScript的关系</h3><p>要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。</p>
<p>该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。日常场合，这两个词是可以互换的。</p>
<h3 id="部署进度"><a href="#部署进度" class="headerlink" title="部署进度"></a>部署进度</h3><p>各大浏览器的最新版本，对ES6的支持可以查看 kangax.github.io/es5-compat-table/es6/。随着时间的推移，支持度已经越来越高了，ES6的大部分特性都实现了</p>
<a id="more"></a>
<h2 id="ES6-和-ES5-的对比"><a href="#ES6-和-ES5-的对比" class="headerlink" title="ES6 和 ES5 的对比"></a>ES6 和 ES5 的对比</h2><h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><h4 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h4><p><code>let</code> 命令相比于 <code>var</code> 命令，有一下区别：</p>
<ol>
<li>不存在变量提升</li>
<li>暂时性死区</li>
<li>不允许重复声明</li>
</ol>
<h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p>ES5只有全局作用域和函数作用域，没有块级作用域。<code>let</code>实际上为JavaScript新增了块级作用域。</p>
<p><strong>块级作用域与函数声明</strong>：</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。</p>
<p>ES6 改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<h4 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h4><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p><code>const</code>声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const foo;</div><div class="line">// SyntaxError: Missing initializer in const declaration</div></pre></td></tr></table></figure>
<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>
<p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>
<p><strong>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。<code>const</code>命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</strong></p>
<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。除了将对象本身冻结，对象的属性也应该冻结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var constantize = (obj) =&gt; &#123;</div><div class="line">  Object.freeze(obj);</div><div class="line">  Object.keys(obj).forEach( (key, value) =&gt; &#123;</div><div class="line">    if ( typeof obj[key] === &apos;object&apos; ) &#123;</div><div class="line">      constantize( obj[key] );</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>ES5只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6一共有6种声明变量的方法。</p>
<h4 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h4><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。ES5之中，顶层对象的属性与全局变量是等价的。</p>
<p>ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<h4 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h4><p>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p>
<ul>
<li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li>
<li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是Node没有<code>self</code>。</li>
<li><p>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</p>
</li>
<li><p>全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。</p>
</li>
<li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li>
<li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li>
</ul>
<p>现在有一个提案，在语言标准的层面，引入<code>global</code>作为顶层对象。也就是说，在所有环境下，<code>global</code>都是存在的，都可以从它拿到顶层对象。</p>
<p>垫片库<code>system.global</code>模拟了这个提案，可以在所有环境拿到<code>global</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// CommonJS的写法</div><div class="line">var global = require(&apos;system.global&apos;)();</div><div class="line"></div><div class="line">// ES6模块的写法</div><div class="line">import getGlobal from &apos;system.global&apos;;</div><div class="line">const global = getGlobal();</div></pre></td></tr></table></figure>
<p>上面代码将顶层对象放入变量<code>global</code>。</p>
<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [a, b, c] = [1, 2, 3];</div></pre></td></tr></table></figure>
<h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>解构赋值允许指定默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let [foo = true] = [];</div><div class="line">foo // true</div><div class="line"></div><div class="line">let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;</div><div class="line">let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;</div></pre></td></tr></table></figure>
<p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</p>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>解构不仅可以用于数组，还可以用于对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</div><div class="line">foo // &quot;aaa&quot;</div><div class="line">bar // &quot;bbb&quot;</div><div class="line">let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</div><div class="line">baz // undefined</div></pre></td></tr></table></figure>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;</div><div class="line">baz // &quot;aaa&quot;</div><div class="line"></div><div class="line">let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;</div><div class="line">let &#123; first: f, last: l &#125; = obj;</div><div class="line">f // &apos;hello&apos;</div><div class="line">l // &apos;world&apos;</div></pre></td></tr></table></figure>
<h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const [a, b, c, d, e] = &apos;hello&apos;;</div><div class="line">a // &quot;h&quot;</div><div class="line">b // &quot;e&quot;</div><div class="line">c // &quot;l&quot;</div><div class="line">d // &quot;l&quot;</div><div class="line">e // &quot;o&quot;</div></pre></td></tr></table></figure>
<h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let &#123;toString: s&#125; = 123;</div><div class="line">s === Number.prototype.toString // true</div><div class="line"></div><div class="line">let &#123;toString: s&#125; = true;</div><div class="line">s === Boolean.prototype.toString // true</div></pre></td></tr></table></figure>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量s都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function add([x, y])&#123;</div><div class="line">  return x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add([1, 2]); // 3</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);</div><div class="line">// [ 3, 7 ]</div></pre></td></tr></table></figure>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><h5 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let x = 1;</div><div class="line">let y = 2;</div><div class="line"></div><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<h5 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 返回一个数组</div><div class="line"></div><div class="line">function example() &#123;</div><div class="line">  return [1, 2, 3];</div><div class="line">&#125;</div><div class="line">let [a, b, c] = example();</div><div class="line"></div><div class="line">// 返回一个对象</div><div class="line"></div><div class="line">function example() &#123;</div><div class="line">  return &#123;</div><div class="line">    foo: 1,</div><div class="line">    bar: 2</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">let &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure>
<h5 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 参数是一组有次序的值</div><div class="line">function f([x, y, z]) &#123; ... &#125;</div><div class="line">f([1, 2, 3]);</div><div class="line"></div><div class="line">// 参数是一组无次序的值</div><div class="line">function f(&#123;x, y, z&#125;) &#123; ... &#125;</div><div class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</div></pre></td></tr></table></figure>
<h5 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h5><p>解构赋值对提取JSON对象中的数据，尤其有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let jsonData = &#123;</div><div class="line">  id: 42,</div><div class="line">  status: &quot;OK&quot;,</div><div class="line">  data: [867, 5309]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let &#123; id, status, data: number &#125; = jsonData;</div><div class="line"></div><div class="line">console.log(id, status, number);</div><div class="line">// 42, &quot;OK&quot;, [867, 5309]</div></pre></td></tr></table></figure>
<h5 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = function (url, &#123;</div><div class="line">  async = true,</div><div class="line">  beforeSend = function () &#123;&#125;,</div><div class="line">  cache = true,</div><div class="line">  complete = function () &#123;&#125;,</div><div class="line">  crossDomain = false,</div><div class="line">  global = true,</div><div class="line">  // ... more config</div><div class="line">&#125;) &#123;</div><div class="line">  // ... do stuff</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<h5 id="遍历Map结构"><a href="#遍历Map结构" class="headerlink" title="遍历Map结构"></a>遍历Map结构</h5><p>任何部署了<code>Iterator</code>接口的对象，都可以用<code>for...of</code>循环遍历。<code>Map</code>结构原生支持<code>Iterator</code>接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set(&apos;first&apos;, &apos;hello&apos;);</div><div class="line">map.set(&apos;second&apos;, &apos;world&apos;);</div><div class="line"></div><div class="line">for (let [key, value] of map) &#123;</div><div class="line">  console.log(key + &quot; is &quot; + value);</div><div class="line">&#125;</div><div class="line">// first is hello</div><div class="line">// second is world</div></pre></td></tr></table></figure>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 获取键名</div><div class="line">for (let [key] of map) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取键值</div><div class="line">for (let [,value] of map) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="输入模块的指定方法"></a>输入模块的指定方法</h5><p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);</div></pre></td></tr></table></figure>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><p>ES6加强了对Unicode的支持，并且扩展了字符串对象。</p>
<h4 id="字符的Unicode表示法"><a href="#字符的Unicode表示法" class="headerlink" title="字符的Unicode表示法"></a>字符的Unicode表示法</h4><p>JavaScript允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。但是，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;\uD842\uDFB7&quot;</div><div class="line">// &quot;𠮷&quot;</div><div class="line"></div><div class="line">&quot;\u20BB7&quot;</div><div class="line">// &quot; 7&quot;</div></pre></td></tr></table></figure>
<p>上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;\u&#123;20BB7&#125;&quot;</div><div class="line">// &quot;𠮷&quot;</div><div class="line"></div><div class="line">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</div><div class="line">// &quot;ABC&quot;</div><div class="line"></div><div class="line">let hello = 123;</div><div class="line">hell\u&#123;6F&#125; // 123</div><div class="line"></div><div class="line">&apos;\u&#123;1F680&#125;&apos; === &apos;\uD83D\uDE80&apos;</div><div class="line">// true</div></pre></td></tr></table></figure>
<p>上面代码中，最后一个例子表明，大括号表示法与四字节的UTF-16编码是等价的。</p>
<p>有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;\z&apos; === &apos;z&apos;  // true</div><div class="line">&apos;\172&apos; === &apos;z&apos; // true</div><div class="line">&apos;\x7A&apos; === &apos;z&apos; // true</div><div class="line">&apos;\u007A&apos; === &apos;z&apos; // true</div><div class="line">&apos;\u&#123;7A&#125;&apos; === &apos;z&apos; // true</div></pre></td></tr></table></figure>
<h4 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h4><p>JavaScript内部，字符以UTF-16的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要4个字节储存的字符（Unicode码点大于<code>0xFFFF</code>的字符），JavaScript会认为它们是两个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var s = &quot;𠮷&quot;;</div><div class="line"></div><div class="line">s.length // 2</div><div class="line">s.charAt(0) // &apos;&apos;</div><div class="line">s.charAt(1) // &apos;&apos;</div><div class="line">s.charCodeAt(0) // 55362</div><div class="line">s.charCodeAt(1) // 57271</div></pre></td></tr></table></figure>
<p>ES6提供了<code>codePointAt</code>方法，能够正确处理4个字节储存的字符，返回一个字符的码点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = &apos;𠮷a&apos;;</div><div class="line"></div><div class="line">s.codePointAt(0).toString(16) // &quot;20bb7&quot;</div><div class="line">s.codePointAt(2).toString(16) // &quot;61&quot;</div></pre></td></tr></table></figure>
<p><code>codePointAt</code>方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt</code>方法相同。</p>
<h4 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h4><p>ES5提供<code>String.fromCharCode</code>方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。</p>
<p>ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String.fromCodePoint(0x20BB7)</div><div class="line">// &quot;𠮷&quot;</div><div class="line">String.fromCodePoint(0x78, 0x1f680, 0x79) === &apos;x\uD83D\uDE80y&apos;</div><div class="line">// true</div></pre></td></tr></table></figure>
<p>上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</p>
<h4 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h4><p>ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for…of循环遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (let codePoint of &apos;foo&apos;) &#123;</div><div class="line">  console.log(codePoint)</div><div class="line">&#125;</div><div class="line">// &quot;f&quot;</div><div class="line">// &quot;o&quot;</div><div class="line">// &quot;o&quot;</div></pre></td></tr></table></figure>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p>
<h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&apos;x&apos;.repeat(3) // &quot;xxx&quot;</div><div class="line">&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;</div><div class="line">&apos;na&apos;.repeat(0) // &quot;&quot;</div></pre></td></tr></table></figure>
<h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>传统的JavaScript语言，输出模板通常是这样写的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(&apos;#result&apos;).append(</div><div class="line">  &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; +</div><div class="line">  &apos;items in your basket, &apos; +</div><div class="line">  &apos;&lt;em&gt;&apos; + basket.onSale +</div><div class="line">  &apos;&lt;/em&gt; are on sale!&apos;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(&apos;#result&apos;).append(`</div><div class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</div><div class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure>
<h3 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h3><h4 id="RegExp构造函数"><a href="#RegExp构造函数" class="headerlink" title="RegExp构造函数"></a>RegExp构造函数</h4><p>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new RegExp(/abc/ig, &apos;i&apos;).flags</div><div class="line">// &quot;i&quot;</div></pre></td></tr></table></figure>
<p>上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。</p>
<h4 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h4><p>字符串对象共有4个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>
<p>ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>
<ul>
<li>String.prototype.match 调用 RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search 调用 RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split 调用 RegExp.prototype[Symbol.split]</li>
</ul>
<h4 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h4><p>S6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于<code>\uFFFF</code>的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;)</div><div class="line">// false</div><div class="line">/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;)</div><div class="line">// true</div></pre></td></tr></table></figure>
<p>上面代码中，<code>\uD83D\uDC2A</code>是一个四个字节的UTF-16编码，代表一个字符。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>。加了<code>u</code>修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为<code>false</code>。</p>
<p>一旦加上<code>u</code>修饰符号，就会修改一些正则表达式的行为。</p>
<h4 id="y-修饰符"><a href="#y-修饰符" class="headerlink" title="y 修饰符"></a>y 修饰符</h4><p>除了<code>u</code>修饰符，ES6还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符。</p>
<p><code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<p>进一步说，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var s = &apos;aaa_aa_a&apos;;</div><div class="line">var r1 = /a+/g;</div><div class="line">var r2 = /a+/y;</div><div class="line"></div><div class="line">r1.exec(s) // [&quot;aaa&quot;]</div><div class="line">r2.exec(s) // [&quot;aaa&quot;]</div><div class="line"></div><div class="line">r1.exec(s) // [&quot;aa&quot;]</div><div class="line">r2.exec(s) // null</div></pre></td></tr></table></figure>
<p>与<code>y</code>修饰符相匹配，ES6的正则对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var r = /hello\d/y;</div><div class="line">r.sticky // true</div></pre></td></tr></table></figure>
<h4 id="flags属性"><a href="#flags属性" class="headerlink" title="flags属性"></a>flags属性</h4><p>ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// ES5的source属性</div><div class="line">// 返回正则表达式的正文</div><div class="line">/abc/ig.source</div><div class="line">// &quot;abc&quot;</div><div class="line"></div><div class="line">// ES6的flags属性</div><div class="line">// 返回正则表达式的修饰符</div><div class="line">/abc/ig.flags</div><div class="line">// &apos;gi&apos;</div></pre></td></tr></table></figure>
<h4 id="RegExp-escape"><a href="#RegExp-escape" class="headerlink" title="RegExp.escape()"></a>RegExp.escape()</h4><p>字符串必须转义，才能作为正则模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function escapeRegExp(str) &#123;</div><div class="line">  return str.replace(/[\-\[\]\/\&#123;\&#125;\(\)\*\+\?\.\\\^\$\|]/g, &apos;\\$&amp;&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">let str = &apos;/path/to/resource.html?search=query&apos;;</div><div class="line">escapeRegExp(str)</div><div class="line">// &quot;\/path\/to\/resource\.html\?search=query&quot;</div></pre></td></tr></table></figure>
<p>用字符串生成正则匹配模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">RegExp.escape(&apos;The Quick Brown Fox&apos;);</div><div class="line">// &quot;The Quick Brown Fox&quot;</div><div class="line"></div><div class="line">RegExp.escape(&apos;Buy it. use it. break it. fix it.&apos;);</div><div class="line">// &quot;Buy it\. use it\. break it\. fix it\.&quot;</div><div class="line"></div><div class="line">RegExp.escape(&apos;(*.*)&apos;);</div><div class="line">// &quot;\(\*\.\*\)&quot;</div></pre></td></tr></table></figure>
<h4 id="s-修饰符：dotAll-模式"><a href="#s-修饰符：dotAll-模式" class="headerlink" title="s 修饰符：dotAll 模式"></a>s 修饰符：dotAll 模式</h4><p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外。</p>
<p>以下四个字符属于”行终止符“。</p>
<ul>
<li>U+000A 换行符（\n）</li>
<li>U+000D 回车符（\r）</li>
<li>U+2028 行分隔符（line separator）</li>
<li>U+2029 段分隔符（paragraph separator）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/foo.bar/.test(&apos;foo\nbar&apos;)</div><div class="line">// false</div></pre></td></tr></table></figure>
<p>现在有一个提案，引入<code>/s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/foo.bar/s.test(&apos;foo\nbar&apos;) // true</div></pre></td></tr></table></figure>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><h4 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="headerlink" title="二进制和八进制表示法"></a>二进制和八进制表示法</h4><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0b111110111 === 503 // true</div><div class="line">0o767 === 503 // true</div></pre></td></tr></table></figure>
<p>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Number(&apos;0b111&apos;)  // 7</div><div class="line">Number(&apos;0o10&apos;)  // 8</div></pre></td></tr></table></figure>
<h4 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h4><p>ES6在<code>Number</code>对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p>
<p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（<code>finite</code>）。</p>
<p><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。</p>
<p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回<code>false</code>。</p>
<h4 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h4><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到Number对象上面，行为完全保持不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES5的写法</div><div class="line">parseInt(&apos;12.34&apos;) // 12</div><div class="line">parseFloat(&apos;123.45#&apos;) // 123.45</div><div class="line"></div><div class="line">// ES6的写法</div><div class="line">Number.parseInt(&apos;12.34&apos;) // 12</div><div class="line">Number.parseFloat(&apos;123.45#&apos;) // 123.45</div></pre></td></tr></table></figure>
<h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p><code>Number.isInteger()</code>用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Number.isInteger(25) // true</div><div class="line">Number.isInteger(25.0) // true</div><div class="line">Number.isInteger(25.1) // false</div><div class="line">Number.isInteger(&quot;15&quot;) // false</div><div class="line">Number.isInteger(true) // false</div></pre></td></tr></table></figure>
<h4 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h4><p>ES6在Number对象上面，新增一个极小的常量<code>Number.EPSILON</code>。</p>
<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。</p>
<p>但是如果这个误差能够小于<code>Number.EPSILON</code>，我们就可以认为得到了正确结果。</p>
<p>因此，<code>Number.EPSILON</code>的实质是一个可以接受的误差范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Number.EPSILON</div><div class="line">// 2.220446049250313e-16</div><div class="line">Number.EPSILON.toFixed(20)</div><div class="line">// &apos;0.00000000000000022204&apos;</div><div class="line">5.551115123125783e-17 &lt; Number.EPSILON</div><div class="line">// true</div></pre></td></tr></table></figure>
<h4 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h4><p>JavaScript能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Math.pow(2, 53) // 9007199254740992</div><div class="line"></div><div class="line">9007199254740992  // 9007199254740992</div><div class="line">9007199254740993  // 9007199254740992</div><div class="line"></div><div class="line">Math.pow(2, 53) === Math.pow(2, 53) + 1</div><div class="line">// true</div></pre></td></tr></table></figure>
<p>ES6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。<code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1</div><div class="line">// true</div><div class="line">Number.MAX_SAFE_INTEGER === 9007199254740991</div><div class="line">// true</div><div class="line"></div><div class="line">Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER</div><div class="line">// true</div><div class="line">Number.MIN_SAFE_INTEGER === -9007199254740991</div><div class="line">// true</div></pre></td></tr></table></figure>
<h3 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h3><h4 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h4><p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Math.trunc(4.1) // 4</div><div class="line">Math.trunc(4.9) // 4</div><div class="line">Math.trunc(-4.1) // -4</div><div class="line">Math.trunc(-4.9) // -4</div><div class="line">Math.trunc(-0.1234) // -0</div></pre></td></tr></table></figure>
<h4 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h4><p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
<h4 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h4><p><code>Math.cbrt</code>方法用于计算一个数的立方根。</p>
<h4 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h4><p>JavaScript的整数使用32位二进制形式表示，<code>Math.clz32</code>方法返回一个数的32位无符号整数形式有多少个前导0。</p>
<h4 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h4><p><code>Math.imul</code>方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。</p>
<p>大多数情况下，<code>Math.imul(a, b)</code>与<code>a * b</code>的结果是相同的,之所以需要部署这个方法，是因为JavaScript有精度限制，超过2的53次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，<code>Math.imul</code>方法可以返回正确的低位数值。</p>
<h4 id="Math-signbit"><a href="#Math-signbit" class="headerlink" title="Math.signbit()"></a>Math.signbit()</h4><p><code>Math.sign()</code>用来判断一个值的正负，但是如果参数是-0，它会返回-0。</p>
<p>引入了<code>Math.signbit()</code>方法判断一个数的符号位是否设置了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Math.signbit(2) //false</div><div class="line">Math.signbit(-2) //true</div><div class="line">Math.signbit(0) //false</div><div class="line">Math.signbit(-0) //true</div></pre></td></tr></table></figure>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。<code>Array.from</code>都可以将它们转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// NodeList对象</div><div class="line">let ps = document.querySelectorAll(&apos;p&apos;);</div><div class="line">Array.from(ps).forEach(function (p) &#123;</div><div class="line">  console.log(p);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// arguments对象</div><div class="line">function foo() &#123;</div><div class="line">  var args = Array.from(arguments);</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用<code>forEach</code>方法</p>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Array.of(3, 11, 8) // [3,11,8]</div><div class="line">Array.of(3) // [3]</div><div class="line">Array.of(3).length // 1</div></pre></td></tr></table></figure>
<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Array() // []</div><div class="line">Array(3) // [, , ,]</div><div class="line">Array(3, 11, 8) // [3, 11, 8]</div></pre></td></tr></table></figure>
<h4 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h4><p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<h4 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h4><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p>
<p>数组实例的<code>findIndex</code>方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p>
<p>这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>IndexOf</code>方法的不足。</p>
<h4 id="数组实例的entries-，keys-和values"><a href="#数组实例的entries-，keys-和values" class="headerlink" title="数组实例的entries()，keys()和values()"></a>数组实例的entries()，keys()和values()</h4><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</div><div class="line">  console.log(index);</div><div class="line">&#125;</div><div class="line">// 0</div><div class="line">// 1</div><div class="line"></div><div class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</div><div class="line">  console.log(elem);</div><div class="line">&#125;</div><div class="line">// &apos;a&apos;</div><div class="line">// &apos;b&apos;</div><div class="line"></div><div class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</div><div class="line">  console.log(index, elem);</div><div class="line">&#125;</div><div class="line">// 0 &quot;a&quot;</div><div class="line">// 1 &quot;b&quot;</div></pre></td></tr></table></figure>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="函数参数的默认值-1"><a href="#函数参数的默认值-1" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><p>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function log(x, y) &#123;</div><div class="line">  y = y || &apos;World&apos;;</div><div class="line">  console.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(&apos;Hello&apos;) // Hello World</div><div class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</div><div class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello World</div></pre></td></tr></table></figure>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function log(x, y = &apos;World&apos;) &#123;</div><div class="line">  console.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(&apos;Hello&apos;) // Hello World</div><div class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</div><div class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello</div></pre></td></tr></table></figure>
<p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<h4 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h4><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>
<h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><p>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用<figure class="highlight plain"><figcaption><span>参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>function add(…values) {<br>  let sum = 0;</p>
<p>  for (var val of values) {<br>    sum += val;<br>  }</p>
<p>  return sum;<br>}</p>
<p>add(2, 5, 3) // 10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 扩展运算符</div><div class="line"></div><div class="line">扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</div></pre></td></tr></table></figure></p>
<p>console.log(…[1, 2, 3])<br>// 1 2 3</p>
<p>console.log(1, …[2, 3, 4], 5)<br>// 1 2 3 4 5</p>
<p>[…document.querySelectorAll(‘div’)]<br>// [<div>, <div>, <div>]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 扩展运算符的应用</div><div class="line"></div><div class="line">**合并数组**</div></pre></td></tr></table></figure></div></div></div></p>
<p>// ES5<br>[1, 2].concat(more)<br>// ES6<br>[1, 2, …more]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**与解构赋值结合**</div></pre></td></tr></table></figure></p>
<p>// ES5<br>a = list[0], rest = list.slice(1)<br>// ES6<br>[a, …rest] = list<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**字符串**</div><div class="line"></div><div class="line">扩展运算符还可以将字符串转为真正的数组。</div></pre></td></tr></table></figure></p>
<p>[…’hello’]<br>// [ “h”, “e”, “l”, “l”, “o” ]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数</div><div class="line"></div><div class="line">凡是涉及到操作32位Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</div></pre></td></tr></table></figure></p>
<p>let str = ‘x\uD83D\uDE80y’;</p>
<p>str.split(‘’).reverse().join(‘’)<br>// ‘y\uDE80\uD83Dx’</p>
<p>[…str].reverse().join(‘’)<br>// ‘y\uD83D\uDE80x’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 实现了Iterator接口的对象</div><div class="line"></div><div class="line">任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</div></pre></td></tr></table></figure></p>
<p>var nodeList = document.querySelectorAll(‘div’);<br>var array = […nodeList];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 箭头函数 </div><div class="line"></div><div class="line">ES6允许使用“箭头”（`=&gt;`）定义函数</div></pre></td></tr></table></figure></p>
<p>var f = v =&gt; v;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面的箭头函数等同于：</div></pre></td></tr></table></figure></p>
<p>var f = function(v) {<br>  return v;<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</div><div class="line"></div><div class="line">如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用`return`语句返回。</div></pre></td></tr></table></figure></p>
<p>var sum = (num1, num2) =&gt; { return num1 + num2; }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果箭头函数直接返回一个对象，必须在对象外面加上括号。</div></pre></td></tr></table></figure></p>
<p>var getTempItem = id =&gt; ({ id: id, name: “Temp” });<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">箭头函数有几个使用注意点。</div><div class="line"></div><div class="line">（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</div><div class="line"></div><div class="line">（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</div><div class="line"></div><div class="line">（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</div><div class="line"></div><div class="line">（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</div><div class="line"></div><div class="line">箭头函数转成ES5的代码如下。</div></pre></td></tr></table></figure></p>
<p>// ES6<br>function foo() {<br>  setTimeout(() =&gt; {<br>    console.log(‘id:’, this.id);<br>  }, 100);<br>}</p>
<p>// ES5<br>function foo() {<br>  var _this = this;</p>
<p>  setTimeout(function () {<br>    console.log(‘id:’, _this.id);<br>  }, 100);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 绑定 this</div><div class="line"></div><div class="line">箭头函数可以绑定`this`对象，大大减少了显式绑定`this`对象的写法（`call、apply、bind`）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代`call、apply、bind`调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</div></pre></td></tr></table></figure></p>
<p>foo::bar;<br>// 等同于<br>bar.bind(foo);</p>
<p>foo::bar(…arguments);<br>// 等同于<br>bar.apply(foo, arguments);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 尾调用优化</div><div class="line"></div><div class="line">##### 什么是尾调用？</div><div class="line"></div><div class="line">尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</div></pre></td></tr></table></figure></p>
<p>function f(x){<br>  return g(x);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 尾调用优化</div><div class="line"></div><div class="line">尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</div><div class="line"></div><div class="line">我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</div><div class="line"></div><div class="line">尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</div><div class="line"></div><div class="line">##### 尾递归</div><div class="line"></div><div class="line">函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</div><div class="line"></div><div class="line">递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</div><div class="line"></div><div class="line">还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性</div><div class="line"></div><div class="line">如果是非尾递归的fibonacci 递归方法</div></pre></td></tr></table></figure></p>
<p>function Fibonacci (n) {<br>  if ( n &lt;= 1 ) {return 1};</p>
<p>  return Fibonacci(n - 1) + Fibonacci(n - 2);<br>}</p>
<p>Fibonacci(10); // 89<br>// Fibonacci(100)<br>// Fibonacci(500)<br>// 堆栈溢出了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果我们使用尾递归优化过的fibonacci 递归算法</div></pre></td></tr></table></figure></p>
<p>function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {<br>  if( n &lt;= 1 ) {return ac2};</p>
<p>  return Fibonacci2 (n - 1, ac2, ac1 + ac2);<br>}</p>
<p>Fibonacci2(100) // 573147844013817200000<br>Fibonacci2(1000) // 7.0330367711422765e+208<br>Fibonacci2(10000) // Infinity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</div><div class="line"></div><div class="line"></div><div class="line">函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</div></pre></td></tr></table></figure></p>
<p>function currying(fn, n) {<br>  return function (m) {<br>    return fn.call(this, m, n);<br>  };<br>}</p>
<p>function tailFactorial(n, total) {<br>  if (n === 1) return total;<br>  return tailFactorial(n - 1, n * total);<br>}</p>
<p>const factorial = currying(tailFactorial, 1);</p>
<p>factorial(5) // 120<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**ES6的尾调用优化只在严格模式下开启，正常模式是无效的。**</div><div class="line"></div><div class="line">### 对象的扩展</div><div class="line"></div><div class="line">#### 属性的简洁表示法</div><div class="line"></div><div class="line">ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</div></pre></td></tr></table></figure></p>
<p>var foo = ‘bar’;<br>var baz = {foo};<br>baz // {foo: “bar”}</p>
<p>// 等同于<br>var baz = {foo: foo};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">除了属性简写，方法也可以简写。</div></pre></td></tr></table></figure></p>
<p>var o = {<br>  method() {<br>    return “Hello!”;<br>  }<br>};</p>
<p>// 等同于</p>
<p>var o = {<br>  method: function() {<br>    return “Hello!”;<br>  }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 属性名表达式</div><div class="line"></div><div class="line">ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</div></pre></td></tr></table></figure></p>
<p>var lastWord = ‘last word’;</p>
<p>var a = {<br>  ‘first word’: ‘hello’,</p>
<p>};</p>
<p>a[‘first word’] // “hello”<br>a<a href="&#39;world&#39;">lastWord</a> // “world”<br>a[‘last word’] // “world”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### Object.is()</div><div class="line"></div><div class="line">ES5比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</div><div class="line"></div><div class="line">ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（`===`）的行为基本一致。</div></pre></td></tr></table></figure></p>
<p>+0 === -0 //true<br>NaN === NaN // false</p>
<p>Object.is(+0, -0) // false<br>Object.is(NaN, NaN) // true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### Object.assign()</div><div class="line"></div><div class="line">`Object.assign`方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</div></pre></td></tr></table></figure></p>
<p>var target = { a: 1 };</p>
<p>var source1 = { b: 2 };<br>var source2 = { c: 3 };</p>
<p>Object.assign(target, source1, source2);<br>target // {a:1, b:2, c:3}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`Object.assign`方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</div><div class="line"></div><div class="line">#### 属性的遍历</div><div class="line"></div><div class="line">ES6一共有5种方法可以遍历对象的属性。</div><div class="line"></div><div class="line">（1）for...in</div><div class="line"></div><div class="line">for...in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</div><div class="line"></div><div class="line">（2）Object.keys(obj)</div><div class="line"></div><div class="line">Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</div><div class="line"></div><div class="line">（3）Object.getOwnPropertyNames(obj)</div><div class="line"></div><div class="line">Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</div><div class="line"></div><div class="line">（4）Object.getOwnPropertySymbols(obj)</div><div class="line"></div><div class="line">Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</div><div class="line"></div><div class="line">（5）Reflect.ownKeys(obj)</div><div class="line"></div><div class="line">Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</div><div class="line"></div><div class="line"></div><div class="line">#### `__proto__`属性，Object.setPrototypeOf()，Object.getPrototypeOf()</div><div class="line"></div><div class="line">`__proto__`前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的`Object.setPrototypeOf()`（写操作）、`Object.getPrototypeOf()`（读操作）、`Object.create()`（生成操作）代替。</div><div class="line"></div><div class="line">在实现上，`__proto__`调用的是`Object.prototype.__proto__`</div><div class="line"></div><div class="line">#### Object.keys()，Object.values()，Object.entries()</div><div class="line"></div><div class="line">ES5 引入了`Object.keys`方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名</div><div class="line"></div><div class="line">ES2017 引入了跟`Object.keys`配套的`Object.values`和`Object.entries`，作为遍历一个对象的补充手段，供`for...of`循环使用。</div><div class="line"></div><div class="line">#### Object.getOwnPropertyDescriptors() </div><div class="line"></div><div class="line">ES5有一个`Object.getOwnPropertyDescriptor`方法，返回某个对象属性的描述对象（descriptor）。</div><div class="line"></div><div class="line">ES2017 引入了`Object.getOwnPropertyDescriptors`方法，返回指定对象所有自身属性（非继承属性）的描述对象。</div></pre></td></tr></table></figure></p>
<p>const obj = {<br>  foo: 123,<br>  get bar() { return ‘abc’ }<br>};</p>
<p>Object.getOwnPropertyDescriptors(obj)<br>// { foo:<br>//    { value: 123,<br>//      writable: true,<br>//      enumerable: true,<br>//      configurable: true },<br>//   bar:<br>//    { get: [Function: bar],<br>//      set: undefined,<br>//      enumerable: true,<br>//      configurable: true } }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Symbol</div><div class="line"></div><div class="line">ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。</div><div class="line"></div><div class="line">ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</div><div class="line"></div><div class="line">Symbol值通过`Symbol`函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</div></pre></td></tr></table></figure></p>
<p>let s = Symbol();</p>
<p>typeof s<br>// “symbol”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">注意，`Symbol`函数前不能使用`new`命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。</div><div class="line"></div><div class="line">#### 作为属性名的Symbol</div></pre></td></tr></table></figure></p>
<p>var mySymbol = Symbol();</p>
<p>// 第一种写法<br>var a = {};<br>a<a href="&#39;Hello!&#39;">mySymbol</a> = ‘Hello!’;</p>
<p>// 第二种写法<br>var a = {</p>
<p>};</p>
<p>// 第三种写法<br>var a = {};<br>Object.defineProperty(a, mySymbol, { value: ‘Hello!’ });</p>
<p>// 以上写法都得到同样结果<br>a<a href="&#39;Hello!&#39;">mySymbol</a> // “Hello!”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">注意，Symbol值作为对象属性名时，不能用点运算符。</div></pre></td></tr></table></figure></p>
<p>var mySymbol = Symbol();<br>var a = {};</p>
<p>a.mySymbol = ‘Hello!’;<br>a<a href="&#39;Hello!&#39;">mySymbol</a> // undefined<br>a[‘mySymbol’] // “Hello!”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 属性名的遍历</div><div class="line"></div><div class="line">Symbol 作为属性名，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols`方法，可以获取指定对象的所有 Symbol 属性名。</div><div class="line"></div><div class="line">另一个新的API，`Reflect.ownKeys`方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</div></pre></td></tr></table></figure></p>
<p>let obj = {</p>
<p>  enum: 2,<br>  nonEnum: 3<br>};</p>
<p>Reflect.ownKeys(obj)<br>//  [“enum”, “nonEnum”, Symbol(my_key)]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</div><div class="line"></div><div class="line">#### Symbol.for()，Symbol.keyFor()</div><div class="line"></div><div class="line">有时，我们希望重新使用同一个Symbol值，`Symbol.for`方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</div><div class="line"></div><div class="line">##### 模块的 Singleton 模式</div><div class="line"></div><div class="line">Singleton模式指的是调用一个类，任何时候返回的都是同一个实例。使用 `Symbol.for` 可以实现。</div><div class="line"></div><div class="line">### Set和Map数据结构</div><div class="line"></div><div class="line">#### Set</div><div class="line"></div><div class="line">ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</div><div class="line"></div><div class="line">Set结构的实例有四个遍历方法，可以用于遍历成员。</div><div class="line"></div><div class="line">* keys()：返回键名的遍历器</div><div class="line">* values()：返回键值的遍历器</div><div class="line">* entries()：返回键值对的遍历器</div><div class="line">* forEach()：使用回调函数遍历每个成员</div><div class="line"></div><div class="line">扩展运算符和Set结构相结合，就可以去除数组的重复成员。</div></pre></td></tr></table></figure></p>
<p>let arr = [3, 5, 2, 2, 5, 5];<br>let unique = […new Set(arr)];<br>// [3, 5, 2]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### WeakSet</div><div class="line"></div><div class="line">WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</div><div class="line"></div><div class="line">首先，WeakSet的成员只能是对象，而不能是其他类型的值。</div><div class="line"></div><div class="line">其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</div><div class="line"></div><div class="line">WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</div><div class="line"></div><div class="line">#### Map</div><div class="line"></div><div class="line">JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</div><div class="line"></div><div class="line">为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</div><div class="line"></div><div class="line">Map原生提供三个遍历器生成函数和一个遍历方法。</div><div class="line"></div><div class="line">* keys()：返回键名的遍历器。</div><div class="line">* values()：返回键值的遍历器。</div><div class="line">* entries()：返回所有成员的遍历器。</div><div class="line">* forEach()：遍历Map的所有成员。</div><div class="line"></div><div class="line">需要特别注意的是，Map的遍历顺序就是插入顺序。</div><div class="line"></div><div class="line">##### Map转为数组</div><div class="line"></div><div class="line">前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（...）</div></pre></td></tr></table></figure></p>
<p>let myMap = new Map().set(true, 7).set({foo: 3}, [‘abc’]);<br>[…myMap]<br>// [ [ true, 7 ], [ { foo: 3 }, [ ‘abc’ ] ] ]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">将数组转入Map构造函数，就可以转为Map。</div></pre></td></tr></table></figure></p>
<p>new Map([[true, 7], [{foo: 3}, [‘abc’]]])<br>// Map {true =&gt; 7, Object {foo: 3} =&gt; [‘abc’]}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### WeakMap</div><div class="line"></div><div class="line">`WeakMap`结构与`Map`结构基本类似，唯一的区别是它只接受对象作为键名（`null`除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</div><div class="line"></div><div class="line">### Proxy</div><div class="line"></div><div class="line">Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</div><div class="line"></div><div class="line">Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</div></pre></td></tr></table></figure></p>
<p>var obj = new Proxy({}, {<br>  get: function (target, key, receiver) {<br>    console.log(<code>getting ${key}!</code>);<br>    return Reflect.get(target, key, receiver);<br>  },<br>  set: function (target, key, value, receiver) {<br>    console.log(<code>setting ${key}!</code>);<br>    return Reflect.set(target, key, value, receiver);<br>  }<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。</div></pre></td></tr></table></figure></p>
<p>obj.count = 1<br>//  setting count!<br>++obj.count<br>//  getting count!<br>//  setting count!<br>//  2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Reflect</div><div class="line"></div><div class="line">`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。</div><div class="line"></div><div class="line">（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</div><div class="line"></div><div class="line">（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</div><div class="line"></div><div class="line">（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</div><div class="line"></div><div class="line">（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</div><div class="line"></div><div class="line">### Promise 对象</div><div class="line"></div><div class="line">Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。</div><div class="line"></div><div class="line">如果某些事件不断地反复发生，一般来说，使用 stream 模式是比部署Promise更好的选择。</div><div class="line"></div><div class="line">#### 基本用法</div></pre></td></tr></table></figure></p>
<p>var promise = new Promise(function(resolve, reject) {<br>  // … some code</p>
<p>  if (/<em> 异步操作成功 </em>/){<br>    resolve(value);<br>  } else {<br>    reject(error);<br>  }<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Promise构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由JavaScript引擎提供，不用自己部署。</div><div class="line"></div><div class="line">Promise实例生成以后，可以用`then`方法分别指定`Resolved`状态和`Reject`状态的回调函数。</div></pre></td></tr></table></figure></p>
<p>promise.then(function(value) {<br>  // success<br>}, function(error) {<br>  // failure<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以使用 `Promise` 异步加载图片，进行 Ajax 处理等。</div><div class="line"></div><div class="line">下面是异步加载图片的例子。</div></pre></td></tr></table></figure></p>
<p>function loadImageAsync(url) {<br>  return new Promise(function(resolve, reject) {<br>    var image = new Image();</p>
<pre><code>image.onload = function() {
  resolve(image);
};

image.onerror = function() {
  reject(new Error(&apos;Could not load image at &apos; + url));
};

image.src = url;
</code></pre><p>  });<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下面是一个用Promise对象实现的Ajax操作的例子。</div></pre></td></tr></table></figure></p>
<p>var getJSON = function(url) {<br>  var promise = new Promise(function(resolve, reject){<br>    var client = new XMLHttpRequest();<br>    client.open(“GET”, url);<br>    client.onreadystatechange = handler;<br>    client.responseType = “json”;<br>    client.setRequestHeader(“Accept”, “application/json”);<br>    client.send();</p>
<pre><code>function handler() {
  if (this.readyState !== 4) {
    return;
  }
  if (this.status === 200) {
    resolve(this.response);
  } else {
    reject(new Error(this.statusText));
  }
};
</code></pre><p>  });</p>
<p>  return promise;<br>};</p>
<p>getJSON(“/posts.json”).then(function(json) {<br>  console.log(‘Contents: ‘ + json);<br>}, function(error) {<br>  console.error(‘出错了’, error);<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### Promise.prototype.then()</div><div class="line"></div><div class="line">then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</div><div class="line"></div><div class="line">#### Promise.prototype.catch()</div><div class="line"></div><div class="line">`Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。</div><div class="line"></div><div class="line"></div><div class="line">一般来说，不要在`then`方法里面定义`Reject`状态的回调函数（即then的第二个参数），总是使用`catch`方法。</div></pre></td></tr></table></figure></p>
<p>// bad<br>promise<br>  .then(function(data) {<br>    // success<br>  }, function(err) {<br>    // error<br>  });</p>
<p>// good<br>promise<br>  .then(function(data) { //cb<br>    // success<br>  })<br>  .catch(function(err) {<br>    // error<br>  });<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面`then`方法执行中的错误，也更接近同步的写法（`try/catch`）。因此，建议总是使用`catch`方法，而不使用`then`方法的第二个参数。</div><div class="line"></div><div class="line">**缺点：跟传统的`try/catch`代码块不同的是，如果没有使用`catch`方法指定错误处理的回调函数，`Promise`对象抛出的错误不会传递到外层代码，即不会有任何反应。**</div><div class="line"></div><div class="line">#### Promise.all()</div><div class="line"></div><div class="line">`Promise.all`方法用于将多个Promise实例，包装成一个新的Promise实例。</div></pre></td></tr></table></figure></p>
<p>var p = Promise.all([p1, p2, p3]);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</div><div class="line"></div><div class="line">（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</div><div class="line"></div><div class="line">### Promise.race() </div><div class="line"></div><div class="line">`Promise.race`方法同样是将多个Promise实例，包装成一个新的Promise实例。</div><div class="line"></div><div class="line">上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</div><div class="line"></div><div class="line">#### Promise.resolve() </div><div class="line"></div><div class="line">有时需要将现有对象转为Promise对象，`Promise.resolve`方法就起到这个作用。</div><div class="line"></div><div class="line">#### done()</div><div class="line"></div><div class="line">Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</div><div class="line"></div><div class="line">#### finally()</div><div class="line"></div><div class="line">finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</div><div class="line"></div><div class="line">### Iterator和for...of循环</div><div class="line"></div><div class="line">#### Iterator（遍历器）的概念</div><div class="line"></div><div class="line">遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</div><div class="line"></div><div class="line">Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令`for...of`循环，Iterator接口主要供`for...of`消费。</div><div class="line"></div><div class="line">#### 数据结构的默认Iterator接口</div><div class="line"></div><div class="line">Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即`for...of`循环（详见下文）。当使用`for...of`循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。</div><div class="line"></div><div class="line">在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象(字符串，`rguments`对象、DOM NodeList 对象，Generator 对象)、Set和Map结构。</div><div class="line"></div><div class="line">对于字符串来说，`for...of`循环还有一个特点，就是会正确识别32位UTF-16字符。</div><div class="line"></div><div class="line">##### 数组</div><div class="line"></div><div class="line">`for...of`循环可以代替数组实例的`forEach`方法。</div><div class="line"></div><div class="line">JavaScript原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6提供for...of循环，允许遍历获得键值。</div></pre></td></tr></table></figure></p>
<p>var arr = [‘a’, ‘b’, ‘c’, ‘d’];</p>
<p>for (let a in arr) {<br>  console.log(a); // 0 1 2 3<br>}</p>
<p>for (let a of arr) {<br>  console.log(a); // a b c d<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### Set和Map结构</div><div class="line"></div><div class="line">遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。</div><div class="line"></div><div class="line">### Generator 函数的语法</div><div class="line"></div><div class="line">Generator 函数是 ES6 提供的一种异步编程解决方案</div><div class="line"></div><div class="line">Generator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</div><div class="line"></div><div class="line">执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</div><div class="line"></div><div class="line">形式上，Generator 函数是一个普通函数，但是有两个特征。一是，`function`关键字与函数名之间有一个星号(`*`)；二是，函数体内部使用`yield`语句，定义不同的内部状态（yield在英语里的意思就是“产出”）。</div><div class="line"></div><div class="line">yield语句不能用在普通函数中，否则会报错。</div></pre></td></tr></table></figure></p>
<p>function* helloWorldGenerator() {<br>  yield ‘hello’;<br>  yield ‘world’;<br>  return ‘ending’;<br>}</p>
<p>var hw = helloWorldGenerator();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码定义了一个Generator函数helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello，world和return语句（结束执行）。</div><div class="line"></div><div class="line">每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。</div><div class="line"></div><div class="line">#### 与Iterator接口的关系</div><div class="line"></div><div class="line">由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。</div><div class="line"></div><div class="line">#### Generator.prototype.return()</div><div class="line"></div><div class="line">Generator函数返回的遍历器对象，还有一个`return`方法，可以返回给定的值，并且终结遍历Generator函数。</div><div class="line"></div><div class="line">**第一次使用 `next()`，就从函数头运行到第一个 `yield`**</div></pre></td></tr></table></figure></p>
<p>function* gen() {<br>  yield 1;<br>  yield 2;<br>  yield 3;<br>}</p>
<p>var g = gen();</p>
<p>g.next()        // { value: 1, done: false }<br>g.return(‘foo’) // { value: “foo”, done: true }<br>g.next()        // { value: undefined, done: true }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### yield* 语句</div><div class="line"></div><div class="line">用到`yield*`语句，用来在一个 Generator 函数里面执行另一个 Generator 函数。</div><div class="line"></div><div class="line">#### 应用</div><div class="line"></div><div class="line">##### 异步操作的同步化表达</div><div class="line"></div><div class="line">Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。</div><div class="line"></div><div class="line">通过Generator函数逐行读取文本文件</div></pre></td></tr></table></figure></p>
<p>function* numbers() {<br>  let file = new FileReader(“numbers.txt”);<br>  try {<br>    while(!file.eof) {<br>      yield parseInt(file.readLine(), 10);<br>    }<br>  } finally {<br>    file.close();<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 控制流管理 </div><div class="line"></div><div class="line">利用`for...of`循环会自动依次执行`yield`命令的特性，提供一种更一般的控制流管理的方法。</div></pre></td></tr></table></figure></p>
<p>let steps = [step1Func, step2Func, step3Func];</p>
<p>function *iterateSteps(steps){<br>  for (var i=0; i&lt; steps.length; i++){<br>    var step = steps[i];<br>    yield step();<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 部署Iterator接口</div><div class="line"></div><div class="line">利用Generator函数，可以在任意对象上部署Iterator接口。</div></pre></td></tr></table></figure></p>
<p>function* iterEntries(obj) {<br>  let keys = Object.keys(obj);<br>  for (let i=0; i &lt; keys.length; i++) {<br>    let key = keys[i];<br>    yield [key, obj[key]];<br>  }<br>}</p>
<p>let myObj = { foo: 3, bar: 7 };</p>
<p>for (let [key, value] of iterEntries(myObj)) {<br>  console.log(key, value);<br>}</p>
<p>// foo 3<br>// bar 7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Generator 函数的异步应用</div><div class="line"></div><div class="line">#### 基本概念</div><div class="line"></div><div class="line">##### 异步</div><div class="line"></div><div class="line">所谓&quot;异步&quot;，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</div><div class="line"></div><div class="line">##### 回调函数 </div><div class="line"></div><div class="line">JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字`callback`，直译过来就是&quot;重新调用&quot;。</div><div class="line"></div><div class="line">##### Promise</div><div class="line"></div><div class="line">回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</div></pre></td></tr></table></figure></p>
<p>fs.readFile(fileA, ‘utf-8’, function (err, data) {<br>  fs.readFile(fileB, ‘utf-8’, function (err, data) {<br>    // …<br>  });<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为&quot;回调函数地狱&quot;（callback hell）。</div><div class="line"></div><div class="line">Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</div></pre></td></tr></table></figure></p>
<p>var readFile = require(‘fs-readfile-promise’);</p>
<p>readFile(fileA)<br>.then(function (data) {<br>  console.log(data.toString());<br>})<br>.then(function () {<br>  return readFile(fileB);<br>})<br>.then(function (data) {<br>  console.log(data.toString());<br>})<br>.catch(function (err) {<br>  console.log(err);<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆`then`，原来的语义变得很不清楚。</div><div class="line"></div><div class="line">#### Generator 函数</div><div class="line"></div><div class="line">##### 协程</div><div class="line"></div><div class="line">传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做&quot;协程&quot;（coroutine），意思是多个线程互相协作，完成异步任务。</div></pre></td></tr></table></figure></p>
<p>function *asyncJob() {<br>  // …其他代码<br>  var f = yield readFile(fileA);<br>  // …其他代码<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码的函数`asyncJob`是一个协程，它的奥妙就在其中的`yield`命令。它表示执行到此处，执行权将交给其他协程。也就是说，`yield`命令是异步两个阶段的分界线。</div><div class="line"></div><div class="line">协程遇到`yield`命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除`yield`命令，简直一模一样。</div><div class="line"></div><div class="line">##### 协程的 Generator 函数实现</div><div class="line"></div><div class="line">Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</div></pre></td></tr></table></figure></p>
<p>function* gen(x) {<br>  var y = yield x + 2;<br>  return y;<br>}</p>
<p>var g = gen(1);<br>g.next() // { value: 3, done: false }<br>g.next() // { value: undefined, done: true }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。</div><div class="line"></div><div class="line">#### Thunk 函数的自动流程管理</div><div class="line"></div><div class="line">Thunk 函数真正的威力，在于可以自动执行 Generator 函数。</div><div class="line"></div><div class="line">#### co 模块</div><div class="line"></div><div class="line">co 模块是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行</div><div class="line"></div><div class="line">### async 函数</div><div class="line"></div><div class="line">#### 含义</div><div class="line"></div><div class="line">async 函数是什么？一句话，它就是 Generator 函数的语法糖。</div><div class="line"></div><div class="line">前文有一个 Generator 函数，依次读取两个文件。</div></pre></td></tr></table></figure></p>
<p>var fs = require(‘fs’);</p>
<p>var readFile = function (fileName) {<br>  return new Promise(function (resolve, reject) {<br>    fs.readFile(fileName, function(error, data) {<br>      if (error) reject(error);<br>      resolve(data);<br>    });<br>  });<br>};</p>
<p>var gen = function* () {<br>  var f1 = yield readFile(‘/etc/fstab’);<br>  var f2 = yield readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">写成`async`函数，就是下面这样。</div></pre></td></tr></table></figure></p>
<p>var asyncReadFile = async function () {<br>  var f1 = await readFile(‘/etc/fstab’);<br>  var f2 = await readFile(‘/etc/shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成`async`，将`yield`替换成`await`，仅此而已。</div><div class="line"></div><div class="line">async函数对 Generator 函数的改进，体现在以下四点。</div><div class="line"></div><div class="line">（1）内置执行器。</div><div class="line"></div><div class="line">（2）更好的语义。</div><div class="line"></div><div class="line">（3）更广的适用性。</div><div class="line"></div><div class="line">（4）返回值是 Promise。</div><div class="line"></div><div class="line">async 函数有多种使用形式。</div></pre></td></tr></table></figure></p>
<p>// 函数声明<br>async function foo() {}</p>
<p>// 函数表达式<br>const foo = async function () {};</p>
<p>// 对象的方法<br>let obj = { async foo() {} };<br>obj.foo().then(…)</p>
<p>// Class 的方法<br>class Storage {<br>  constructor() {<br>    this.cachePromise = caches.open(‘avatars’);<br>  }</p>
<p>  async getAvatar(name) {<br>    const cache = await this.cachePromise;<br>    return cache.match(<code>/avatars/${name}.jpg</code>);<br>  }<br>}</p>
<p>const storage = new Storage();<br>storage.getAvatar(‘jake’).then(…);</p>
<p>// 箭头函数<br>const foo = async () =&gt; {};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### Promise 对象的状态变</div><div class="line"></div><div class="line">async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</div></pre></td></tr></table></figure></p>
<p>async function getTitle(url) {<br>  let response = await fetch(url);<br>  let html = await response.text();<br>  return html.match(/<title>([\s\S]+)&lt;\/title&gt;/i)[1];<br>}<br>getTitle(‘<a href="https://tc39.github.io/ecma262/&#39;).then(console.log" target="_blank" rel="external">https://tc39.github.io/ecma262/&#39;).then(console.log</a>)<br>// “ECMAScript 2017 Language Specification”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码中，函数`getTitle`内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的`console.log`。</div><div class="line"></div><div class="line">### Class</div><div class="line"></div><div class="line">ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</div></pre></td></tr></table></figure></title></p>
<p>//定义类<br>class Point {<br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }</p>
<p>  toString() {<br>    return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>  }</p>
<p>  <a href="">methodName</a> {<br>    // …<br>  }<br>}</p>
<p>typeof Point // “function”<br>Point === Point.prototype.constructor // true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">构造函数的`prototype`属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的`prototype`属性上面。</div><div class="line"></div><div class="line">类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</div><div class="line"></div><div class="line">#### 类的实例对象</div></pre></td></tr></table></figure></p>
<p>//定义类<br>class Point {</p>
<p>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }</p>
<p>  toString() {<br>    return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>  }</p>
<p>}</p>
<p>var point = new Point(2, 3);</p>
<p>point.toString() // (2, 3)</p>
<p>point.hasOwnProperty(‘x’) // true<br>point.hasOwnProperty(‘y’) // true<br>point.hasOwnProperty(‘toString’) // false<br>point.<strong>proto</strong>.hasOwnProperty(‘toString’) // true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。</div><div class="line"></div><div class="line">#### 私有方法</div><div class="line"></div><div class="line">私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</div><div class="line"></div><div class="line">#### this的指向</div><div class="line"></div><div class="line">类的方法内部如果含有this，它默认指向类的实例。</div><div class="line"></div><div class="line">#### Class的继承</div><div class="line"></div><div class="line">Class之间可以通过`extends`关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</div></pre></td></tr></table></figure></p>
<p>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    super(x, y); // 调用父类的constructor(x, y)<br>    this.color = color;<br>  }</p>
<p>  toString() {<br>    return this.color + ‘ ‘ + super.toString(); // 调用父类的toString()<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</div><div class="line"></div><div class="line">ES5的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面（`Parent.apply(this)`）。ES6的继承机制完全不同，实质是先创造父类的实例对象`this`（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。</div><div class="line"></div><div class="line">另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</div><div class="line"></div><div class="line">#### 类的prototype属性和__proto__属性</div><div class="line"></div><div class="line">大多数浏览器的ES5实现之中，每一个对象都有`__proto__`属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和`__proto__`属性，因此同时存在两条继承链。</div><div class="line"></div><div class="line">（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类。</div><div class="line"></div><div class="line">（2）子类`prototype`属性的`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## ES6 转码</div><div class="line"></div><div class="line">### Babel转码器</div><div class="line"></div><div class="line">[Babel](https://babeljs.io) 是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。</div></pre></td></tr></table></figure></p>
<p>// 转码前<br>input.map(item =&gt; item + 1);</p>
<p>// 转码后<br>input.map(function (item) {<br>  return item + 1;<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面的原始代码用了箭头函数，这个特性还没有得到广泛支持，Babel将其转为普通函数，就能在现有的JavaScript环境执行了。</div><div class="line"></div><div class="line">### 配置文件.babelrc</div><div class="line"></div><div class="line">Babel的配置文件是`.babelrc`，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。</div><div class="line"></div><div class="line">该文件用来设置转码规则和插件，基本格式如下</div></pre></td></tr></table></figure></p>
<p>{<br>  “presets”: [],<br>  “plugins”: []<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`presets`字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</div></pre></td></tr></table></figure></p>
<h1 id="ES2015转码规则"><a href="#ES2015转码规则" class="headerlink" title="ES2015转码规则"></a>ES2015转码规则</h1><p>$ npm install –save-dev babel-preset-es2015</p>
<h1 id="react转码规则"><a href="#react转码规则" class="headerlink" title="react转码规则"></a>react转码规则</h1><p>$ npm install –save-dev babel-preset-react</p>
<h1 id="ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个"><a href="#ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个" class="headerlink" title="ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个"></a>ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个</h1><p>$ npm install –save-dev babel-preset-stage-0<br>$ npm install –save-dev babel-preset-stage-1<br>$ npm install –save-dev babel-preset-stage-2<br>$ npm install –save-dev babel-preset-stage-3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">然后，将这些规则加入`.babelrc`。</div></pre></td></tr></table></figure></p>
<p>{<br>    “presets”: [<br>      “es2015”,<br>      “react”,<br>      “stage-2”<br>    ],<br>    “plugins”: []<br>  }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">注意，以下所有Babel工具和模块的使用，都必须先写好`.babelrc`。</div><div class="line"></div><div class="line">### 命令行转码babel-cli</div><div class="line"></div><div class="line">Babel提供`babel-cli`工具，用于命令行转码。</div><div class="line"></div><div class="line">它的安装命令如下。</div></pre></td></tr></table></figure></p>
<p>$ npm install –global babel-cli<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<h1 id="转码结果输出到标准输出"><a href="#转码结果输出到标准输出" class="headerlink" title="转码结果输出到标准输出"></a>转码结果输出到标准输出</h1><p>$ babel example.js</p>
<h1 id="转码结果写入一个文件"><a href="#转码结果写入一个文件" class="headerlink" title="转码结果写入一个文件"></a>转码结果写入一个文件</h1><h1 id="–out-file-或-o-参数指定输出文件"><a href="#–out-file-或-o-参数指定输出文件" class="headerlink" title="–out-file 或 -o 参数指定输出文件"></a>–out-file 或 -o 参数指定输出文件</h1><p>$ babel example.js –out-file compiled.js</p>
<h1 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h1><p>$ babel example.js -o compiled.js</p>
<h1 id="整个目录转码"><a href="#整个目录转码" class="headerlink" title="整个目录转码"></a>整个目录转码</h1><h1 id="–out-dir-或-d-参数指定输出目录"><a href="#–out-dir-或-d-参数指定输出目录" class="headerlink" title="–out-dir 或 -d 参数指定输出目录"></a>–out-dir 或 -d 参数指定输出目录</h1><p>$ babel src –out-dir lib</p>
<h1 id="或者-1"><a href="#或者-1" class="headerlink" title="或者"></a>或者</h1><p>$ babel src -d lib</p>
<h1 id="s-参数生成source-map文件"><a href="#s-参数生成source-map文件" class="headerlink" title="-s 参数生成source map文件"></a>-s 参数生成source map文件</h1><p>$ babel src -d lib -s<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的Babel。</div><div class="line"></div><div class="line">一个解决办法是将`babel-cli`安装在项目之中。</div></pre></td></tr></table></figure></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>$ npm install –save-dev babel-cli<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后，改写`package.json`。</div></pre></td></tr></table></figure></p>
<p>{<br>  // …<br>  “devDependencies”: {<br>    “babel-cli”: “^6.0.0”<br>  },<br>  “scripts”: {<br>    “build”: “babel src -d lib”<br>  },<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">转码的时候，就执行下面的命令。</div></pre></td></tr></table></figure></p>
<p>$ npm run build<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### babel-node</div><div class="line"></div><div class="line">`babel-cli`工具自带一个`babel-node`命令，提供一个支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。</div><div class="line"></div><div class="line">它不用单独安装，而是随`babel-cli`一起安装。然后，执行babel-node`就进入REPL环境。</div></pre></td></tr></table></figure></p>
<p>$ babel-node</p>
<blockquote>
<p>(x =&gt; x * 2)(1)<br>2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`babel-node`命令可以直接运行ES6脚本。将上面的代码放入脚本文件es6.js，然后直接运行。</div></pre></td></tr></table></figure></p>
</blockquote>
<p>$ babel-node es6.js<br>2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">`babel-node`也可以安装在项目中。</div></pre></td></tr></table></figure></p>
<p>$ npm install –save-dev babel-cli<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后，改写`package.json`</div></pre></td></tr></table></figure></p>
<p>{<br>  “scripts”: {<br>    “script-name”: “babel-node script.js”<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码中，使用`babel-node`替代`node`，这样`script.js`本身就不用做任何转码处理。</div><div class="line"></div><div class="line">### babel-core</div><div class="line"></div><div class="line">如果某些代码(Webpack 代码)需要调用Babel的API进行转码，就要使用`babel-core`模块。</div><div class="line"></div><div class="line">安装命令如下。</div></pre></td></tr></table></figure></p>
<p>npm install babel-core –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后，在项目中就可以调用babel-core。</div></pre></td></tr></table></figure></p>
<p>var babel = require(‘babel-core’);</p>
<p>// 字符串转码<br>babel.transform(‘code();’, options);<br>// =&gt; { code, map, ast }</p>
<p>// 文件转码（异步）<br>babel.transformFile(‘filename.js’, options, function(err, result) {<br>  result; // =&gt; { code, map, ast }<br>});</p>
<p>// 文件转码（同步）<br>babel.transformFileSync(‘filename.js’, options);<br>// =&gt; { code, map, ast }</p>
<p>// Babel AST转码<br>babel.transformFromAst(ast, code, options);<br>// =&gt; { code, map, ast }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">配置对象`options`，可以参看官方文档http://babeljs.io/docs/usage/options/。</div><div class="line"></div><div class="line">下面是一个例子。</div></pre></td></tr></table></figure></p>
<p>var es6Code = ‘let x = n =&gt; n + 1’;<br>var es5Code = require(‘babel-core’)<br>  .transform(es6Code, {<br>    presets: [‘es2015’]<br>  })<br>  .code;<br>// ‘“use strict”;\n\nvar x = function x(n) {\n  return n + 1;\n};’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面代码中，`transform`方法的第一个参数是一个字符串，表示需要被转换的ES6代码，第二个参数是转换的配置对象。</div><div class="line"></div><div class="line">### babel-polyfill</div><div class="line"></div><div class="line">Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如`Object.assign`）都不会转码。</div><div class="line"></div><div class="line">举例来说，ES6在`Array`对象上新增了`Array.from`方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用`babel-polyfill`，为当前环境提供一个垫片。</div><div class="line"></div><div class="line">安装命令如下。</div></pre></td></tr></table></figure></p>
<p>$ npm install –save babel-polyfill<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">然后，在脚本头部，加入如下一行代码。</div></pre></td></tr></table></figure></p>
<p>import ‘babel-polyfill’;<br>// 或者<br>require(‘babel-polyfill’);<br>```</p>
<p>Babel默认不转码的API非常多，详细清单可以查看babel-plugin-transform-runtime模块的<a href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/definitions.js" target="_blank" rel="external">definitions.js</a>文件。</p>
<h3 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h3><p>Babel提供一个<a href="https://babeljs.io/repl/" target="_blank" rel="external">REPL在线编译器</a>，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ES6/" rel="tag"># ES6</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/08/LeetCode-String题集/" rel="next" title="LeetCode String题集">
                <i class="fa fa-chevron-left"></i> LeetCode String题集
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/11/CSS3-Flex-布局/" rel="prev" title="CSS3 Flex 布局">
                CSS3 Flex 布局 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/02/09/ES6入门/"
           data-title="ES6入门" data-url="https://shiningdan.github.io/2017/02/09/ES6入门/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg"
               alt="ShiningDan" />
          <p class="site-author-name" itemprop="name">ShiningDan</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ECMAScript-6简介"><span class="nav-number">1.</span> <span class="nav-text">ECMAScript 6简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ECMAScript和JavaScript的关系"><span class="nav-number">1.1.</span> <span class="nav-text">ECMAScript和JavaScript的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部署进度"><span class="nav-number">1.2.</span> <span class="nav-text">部署进度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-和-ES5-的对比"><span class="nav-number">2.</span> <span class="nav-text">ES6 和 ES5 的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#let-和-const"><span class="nav-number">2.1.</span> <span class="nav-text">let 和 const</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#let-命令"><span class="nav-number">2.1.1.</span> <span class="nav-text">let 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#块级作用域"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">块级作用域</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const命令"><span class="nav-number">2.1.2.</span> <span class="nav-text">const命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顶层对象的属性"><span class="nav-number">2.1.3.</span> <span class="nav-text">顶层对象的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#global-对象"><span class="nav-number">2.1.4.</span> <span class="nav-text">global 对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的解构赋值"><span class="nav-number">2.2.</span> <span class="nav-text">变量的解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的解构赋值"><span class="nav-number">2.2.1.</span> <span class="nav-text">数组的解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#默认值"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">默认值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的解构赋值"><span class="nav-number">2.2.2.</span> <span class="nav-text">对象的解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串的解构赋值"><span class="nav-number">2.2.3.</span> <span class="nav-text">字符串的解构赋值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值和布尔值的解构赋值"><span class="nav-number">2.3.</span> <span class="nav-text">数值和布尔值的解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数参数的解构赋值"><span class="nav-number">2.3.1.</span> <span class="nav-text">函数参数的解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用途"><span class="nav-number">2.3.2.</span> <span class="nav-text">用途</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#交换变量的值"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">交换变量的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从函数返回多个值"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">从函数返回多个值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数参数的定义"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">函数参数的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#提取JSON数据"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">提取JSON数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数参数的默认值"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">函数参数的默认值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历Map结构"><span class="nav-number">2.3.2.6.</span> <span class="nav-text">遍历Map结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输入模块的指定方法"><span class="nav-number">2.3.2.7.</span> <span class="nav-text">输入模块的指定方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串的扩展"><span class="nav-number">2.4.</span> <span class="nav-text">字符串的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符的Unicode表示法"><span class="nav-number">2.4.1.</span> <span class="nav-text">字符的Unicode表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#codePointAt"><span class="nav-number">2.4.2.</span> <span class="nav-text">codePointAt()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-fromCodePoint"><span class="nav-number">2.4.3.</span> <span class="nav-text">String.fromCodePoint()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串的遍历器接口"><span class="nav-number">2.4.4.</span> <span class="nav-text">字符串的遍历器接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#includes-startsWith-endsWith"><span class="nav-number">2.4.5.</span> <span class="nav-text">includes(), startsWith(), endsWith()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#repeat"><span class="nav-number">2.4.6.</span> <span class="nav-text">repeat()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#padStart-，padEnd"><span class="nav-number">2.4.7.</span> <span class="nav-text">padStart()，padEnd()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板字符串"><span class="nav-number">2.4.8.</span> <span class="nav-text">模板字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则的扩展"><span class="nav-number">2.5.</span> <span class="nav-text">正则的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RegExp构造函数"><span class="nav-number">2.5.1.</span> <span class="nav-text">RegExp构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串的正则方法"><span class="nav-number">2.5.2.</span> <span class="nav-text">字符串的正则方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u修饰符"><span class="nav-number">2.5.3.</span> <span class="nav-text">u修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#y-修饰符"><span class="nav-number">2.5.4.</span> <span class="nav-text">y 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flags属性"><span class="nav-number">2.5.5.</span> <span class="nav-text">flags属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RegExp-escape"><span class="nav-number">2.5.6.</span> <span class="nav-text">RegExp.escape()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#s-修饰符：dotAll-模式"><span class="nav-number">2.5.7.</span> <span class="nav-text">s 修饰符：dotAll 模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值的扩展"><span class="nav-number">2.6.</span> <span class="nav-text">数值的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制和八进制表示法"><span class="nav-number">2.6.1.</span> <span class="nav-text">二进制和八进制表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-isFinite-Number-isNaN"><span class="nav-number">2.6.2.</span> <span class="nav-text">Number.isFinite(), Number.isNaN()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-parseInt-Number-parseFloat"><span class="nav-number">2.6.3.</span> <span class="nav-text">Number.parseInt(), Number.parseFloat()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-isInteger"><span class="nav-number">2.6.4.</span> <span class="nav-text">Number.isInteger()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-EPSILON"><span class="nav-number">2.6.5.</span> <span class="nav-text">Number.EPSILON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安全整数和Number-isSafeInteger"><span class="nav-number">2.6.6.</span> <span class="nav-text">安全整数和Number.isSafeInteger()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math对象的扩展"><span class="nav-number">2.7.</span> <span class="nav-text">Math对象的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-trunc"><span class="nav-number">2.7.1.</span> <span class="nav-text">Math.trunc()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-sign"><span class="nav-number">2.7.2.</span> <span class="nav-text">Math.sign()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-cbrt"><span class="nav-number">2.7.3.</span> <span class="nav-text">Math.cbrt()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-clz32"><span class="nav-number">2.7.4.</span> <span class="nav-text">Math.clz32()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-imul"><span class="nav-number">2.7.5.</span> <span class="nav-text">Math.imul()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-signbit"><span class="nav-number">2.7.6.</span> <span class="nav-text">Math.signbit()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的扩展"><span class="nav-number">2.8.</span> <span class="nav-text">数组的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-from"><span class="nav-number">2.8.1.</span> <span class="nav-text">Array.from()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-of"><span class="nav-number">2.8.2.</span> <span class="nav-text">Array.of()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组实例的copyWithin"><span class="nav-number">2.8.3.</span> <span class="nav-text">数组实例的copyWithin()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组实例的find-和findIndex"><span class="nav-number">2.8.4.</span> <span class="nav-text">数组实例的find()和findIndex()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组实例的entries-，keys-和values"><span class="nav-number">2.8.5.</span> <span class="nav-text">数组实例的entries()，keys()和values()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的扩展"><span class="nav-number">2.9.</span> <span class="nav-text">函数的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数参数的默认值-1"><span class="nav-number">2.9.1.</span> <span class="nav-text">函数参数的默认值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数的-length-属性"><span class="nav-number">2.9.2.</span> <span class="nav-text">函数的 length 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rest参数"><span class="nav-number">2.9.3.</span> <span class="nav-text">rest参数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES2015转码规则"><span class="nav-number"></span> <span class="nav-text">ES2015转码规则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#react转码规则"><span class="nav-number"></span> <span class="nav-text">react转码规则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个"><span class="nav-number"></span> <span class="nav-text">ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#转码结果输出到标准输出"><span class="nav-number"></span> <span class="nav-text">转码结果输出到标准输出</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#转码结果写入一个文件"><span class="nav-number"></span> <span class="nav-text">转码结果写入一个文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#–out-file-或-o-参数指定输出文件"><span class="nav-number"></span> <span class="nav-text">–out-file 或 -o 参数指定输出文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#或者"><span class="nav-number"></span> <span class="nav-text">或者</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#整个目录转码"><span class="nav-number"></span> <span class="nav-text">整个目录转码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#–out-dir-或-d-参数指定输出目录"><span class="nav-number"></span> <span class="nav-text">–out-dir 或 -d 参数指定输出目录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#或者-1"><span class="nav-number"></span> <span class="nav-text">或者</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#s-参数生成source-map文件"><span class="nav-number"></span> <span class="nav-text">-s 参数生成source map文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安装"><span class="nav-number"></span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在线转换"><span class="nav-number">0.1.</span> <span class="nav-text">在线转换</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShiningDan</span>
</div>



        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"shiningdan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js?v=5.1.0"></script>
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("nr3cyUXVpbTxQQRcqfMp5cHa-gzGzoHsz", "B1SG80mnbseYxv4C0vAjig8s");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
