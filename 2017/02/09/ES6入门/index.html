<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ES6," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="本文是我在学习 ECMAScript 6 时的记录，用于个人查询总结。在学习的过程中参考过很多别人的文章，如有需要，可以根据链接详细学习：

ECMAScript 6 入门

ECMAScript 6简介ECMAScript和JavaScript的关系要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织E">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6入门">
<meta property="og:url" content="https://shiningdan.github.io/2017/02/09/ES6入门/index.html">
<meta property="og:site_name" content="ShiningDan的博客">
<meta property="og:description" content="本文是我在学习 ECMAScript 6 时的记录，用于个人查询总结。在学习的过程中参考过很多别人的文章，如有需要，可以根据链接详细学习：

ECMAScript 6 入门

ECMAScript 6简介ECMAScript和JavaScript的关系要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织E">
<meta property="og:updated_time" content="2017-02-15T09:25:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6入门">
<meta name="twitter:description" content="本文是我在学习 ECMAScript 6 时的记录，用于个人查询总结。在学习的过程中参考过很多别人的文章，如有需要，可以根据链接详细学习：

ECMAScript 6 入门

ECMAScript 6简介ECMAScript和JavaScript的关系要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织E">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6345612185049236000',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://shiningdan.github.io/2017/02/09/ES6入门/"/>





  <title> ES6入门 | ShiningDan的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?65f098889042a1740b5cfede967d34b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ShiningDan的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description"></h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photography">
          <a href="/categories/photography" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            摄影
          </a>
        </li>
      
        
        <li class="menu-item menu-item-coding">
          <a href="/categories/coding" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            编程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://shiningdan.github.io/2017/02/09/ES6入门/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ShiningDan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ShiningDan的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ShiningDan的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                ES6入门
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-09T16:38:32+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/coding/" itemprop="url" rel="index">
                    <span itemprop="name">coding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/09/ES6入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/09/ES6入门/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/02/09/ES6入门/" class="leancloud_visitors" data-flag-title="ES6入门">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文是我在学习 ECMAScript 6 时的记录，用于个人查询总结。在学习的过程中参考过很多别人的文章，如有需要，可以根据链接详细学习：</p>
<ul>
<li><a href="http://es6.ruanyifeng.com" target="_blank" rel="external">ECMAScript 6 入门</a></li>
</ul>
<h2 id="ECMAScript-6简介"><a href="#ECMAScript-6简介" class="headerlink" title="ECMAScript 6简介"></a>ECMAScript 6简介</h2><h3 id="ECMAScript和JavaScript的关系"><a href="#ECMAScript和JavaScript的关系" class="headerlink" title="ECMAScript和JavaScript的关系"></a>ECMAScript和JavaScript的关系</h3><p>要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。</p>
<p>该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。日常场合，这两个词是可以互换的。</p>
<h3 id="部署进度"><a href="#部署进度" class="headerlink" title="部署进度"></a>部署进度</h3><p>各大浏览器的最新版本，对ES6的支持可以查看 kangax.github.io/es5-compat-table/es6/。随着时间的推移，支持度已经越来越高了，ES6的大部分特性都实现了</p>
<a id="more"></a>
<h2 id="ES6-和-ES5-的对比"><a href="#ES6-和-ES5-的对比" class="headerlink" title="ES6 和 ES5 的对比"></a>ES6 和 ES5 的对比</h2><h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><h4 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h4><p><code>let</code> 命令相比于 <code>var</code> 命令，有一下区别：</p>
<ol>
<li>不存在变量提升</li>
<li>暂时性死区</li>
<li>不允许重复声明</li>
</ol>
<h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p>ES5只有全局作用域和函数作用域，没有块级作用域。<code>let</code>实际上为JavaScript新增了块级作用域。</p>
<p><strong>块级作用域与函数声明</strong>：</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。</p>
<p>ES6 改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<h4 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h4><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p><code>const</code>声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const foo;</div><div class="line">// SyntaxError: Missing initializer in const declaration</div></pre></td></tr></table></figure>
<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>
<p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>
<p><strong>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。<code>const</code>命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</strong></p>
<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。除了将对象本身冻结，对象的属性也应该冻结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var constantize = (obj) =&gt; &#123;</div><div class="line">  Object.freeze(obj);</div><div class="line">  Object.keys(obj).forEach( (key, value) =&gt; &#123;</div><div class="line">    if ( typeof obj[key] === &apos;object&apos; ) &#123;</div><div class="line">      constantize( obj[key] );</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>ES5只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6一共有6种声明变量的方法。</p>
<h4 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h4><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。ES5之中，顶层对象的属性与全局变量是等价的。</p>
<p>ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<h4 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h4><p>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p>
<ul>
<li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li>
<li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是Node没有<code>self</code>。</li>
<li><p>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</p>
</li>
<li><p>全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。</p>
</li>
<li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li>
<li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li>
</ul>
<p>现在有一个提案，在语言标准的层面，引入<code>global</code>作为顶层对象。也就是说，在所有环境下，<code>global</code>都是存在的，都可以从它拿到顶层对象。</p>
<p>垫片库<code>system.global</code>模拟了这个提案，可以在所有环境拿到<code>global</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// CommonJS的写法</div><div class="line">var global = require(&apos;system.global&apos;)();</div><div class="line"></div><div class="line">// ES6模块的写法</div><div class="line">import getGlobal from &apos;system.global&apos;;</div><div class="line">const global = getGlobal();</div></pre></td></tr></table></figure>
<p>上面代码将顶层对象放入变量<code>global</code>。</p>
<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [a, b, c] = [1, 2, 3];</div></pre></td></tr></table></figure>
<h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>解构赋值允许指定默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let [foo = true] = [];</div><div class="line">foo // true</div><div class="line"></div><div class="line">let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;</div><div class="line">let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;</div></pre></td></tr></table></figure>
<p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</p>
<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><p>解构不仅可以用于数组，还可以用于对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</div><div class="line">foo // &quot;aaa&quot;</div><div class="line">bar // &quot;bbb&quot;</div><div class="line">let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</div><div class="line">baz // undefined</div></pre></td></tr></table></figure>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;</div><div class="line">baz // &quot;aaa&quot;</div><div class="line"></div><div class="line">let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;</div><div class="line">let &#123; first: f, last: l &#125; = obj;</div><div class="line">f // &apos;hello&apos;</div><div class="line">l // &apos;world&apos;</div></pre></td></tr></table></figure>
<h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h4><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const [a, b, c, d, e] = &apos;hello&apos;;</div><div class="line">a // &quot;h&quot;</div><div class="line">b // &quot;e&quot;</div><div class="line">c // &quot;l&quot;</div><div class="line">d // &quot;l&quot;</div><div class="line">e // &quot;o&quot;</div></pre></td></tr></table></figure>
<h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let &#123;toString: s&#125; = 123;</div><div class="line">s === Number.prototype.toString // true</div><div class="line"></div><div class="line">let &#123;toString: s&#125; = true;</div><div class="line">s === Boolean.prototype.toString // true</div></pre></td></tr></table></figure>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量s都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h4><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function add([x, y])&#123;</div><div class="line">  return x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add([1, 2]); // 3</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);</div><div class="line">// [ 3, 7 ]</div></pre></td></tr></table></figure>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><h5 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let x = 1;</div><div class="line">let y = 2;</div><div class="line"></div><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<h5 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 返回一个数组</div><div class="line"></div><div class="line">function example() &#123;</div><div class="line">  return [1, 2, 3];</div><div class="line">&#125;</div><div class="line">let [a, b, c] = example();</div><div class="line"></div><div class="line">// 返回一个对象</div><div class="line"></div><div class="line">function example() &#123;</div><div class="line">  return &#123;</div><div class="line">    foo: 1,</div><div class="line">    bar: 2</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">let &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure>
<h5 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 参数是一组有次序的值</div><div class="line">function f([x, y, z]) &#123; ... &#125;</div><div class="line">f([1, 2, 3]);</div><div class="line"></div><div class="line">// 参数是一组无次序的值</div><div class="line">function f(&#123;x, y, z&#125;) &#123; ... &#125;</div><div class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</div></pre></td></tr></table></figure>
<h5 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h5><p>解构赋值对提取JSON对象中的数据，尤其有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let jsonData = &#123;</div><div class="line">  id: 42,</div><div class="line">  status: &quot;OK&quot;,</div><div class="line">  data: [867, 5309]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let &#123; id, status, data: number &#125; = jsonData;</div><div class="line"></div><div class="line">console.log(id, status, number);</div><div class="line">// 42, &quot;OK&quot;, [867, 5309]</div></pre></td></tr></table></figure>
<h5 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = function (url, &#123;</div><div class="line">  async = true,</div><div class="line">  beforeSend = function () &#123;&#125;,</div><div class="line">  cache = true,</div><div class="line">  complete = function () &#123;&#125;,</div><div class="line">  crossDomain = false,</div><div class="line">  global = true,</div><div class="line">  // ... more config</div><div class="line">&#125;) &#123;</div><div class="line">  // ... do stuff</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<h5 id="遍历Map结构"><a href="#遍历Map结构" class="headerlink" title="遍历Map结构"></a>遍历Map结构</h5><p>任何部署了<code>Iterator</code>接口的对象，都可以用<code>for...of</code>循环遍历。<code>Map</code>结构原生支持<code>Iterator</code>接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set(&apos;first&apos;, &apos;hello&apos;);</div><div class="line">map.set(&apos;second&apos;, &apos;world&apos;);</div><div class="line"></div><div class="line">for (let [key, value] of map) &#123;</div><div class="line">  console.log(key + &quot; is &quot; + value);</div><div class="line">&#125;</div><div class="line">// first is hello</div><div class="line">// second is world</div></pre></td></tr></table></figure>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 获取键名</div><div class="line">for (let [key] of map) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取键值</div><div class="line">for (let [,value] of map) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="输入模块的指定方法"></a>输入模块的指定方法</h5><p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);</div></pre></td></tr></table></figure>
<h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><p>ES6加强了对Unicode的支持，并且扩展了字符串对象。</p>
<h4 id="字符的Unicode表示法"><a href="#字符的Unicode表示法" class="headerlink" title="字符的Unicode表示法"></a>字符的Unicode表示法</h4><p>JavaScript允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。但是，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;\uD842\uDFB7&quot;</div><div class="line">// &quot;𠮷&quot;</div><div class="line"></div><div class="line">&quot;\u20BB7&quot;</div><div class="line">// &quot; 7&quot;</div></pre></td></tr></table></figure>
<p>上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;\u&#123;20BB7&#125;&quot;</div><div class="line">// &quot;𠮷&quot;</div><div class="line"></div><div class="line">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</div><div class="line">// &quot;ABC&quot;</div><div class="line"></div><div class="line">let hello = 123;</div><div class="line">hell\u&#123;6F&#125; // 123</div><div class="line"></div><div class="line">&apos;\u&#123;1F680&#125;&apos; === &apos;\uD83D\uDE80&apos;</div><div class="line">// true</div></pre></td></tr></table></figure>
<p>上面代码中，最后一个例子表明，大括号表示法与四字节的UTF-16编码是等价的。</p>
<p>有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;\z&apos; === &apos;z&apos;  // true</div><div class="line">&apos;\172&apos; === &apos;z&apos; // true</div><div class="line">&apos;\x7A&apos; === &apos;z&apos; // true</div><div class="line">&apos;\u007A&apos; === &apos;z&apos; // true</div><div class="line">&apos;\u&#123;7A&#125;&apos; === &apos;z&apos; // true</div></pre></td></tr></table></figure>
<h4 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h4><p>JavaScript内部，字符以UTF-16的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要4个字节储存的字符（Unicode码点大于<code>0xFFFF</code>的字符），JavaScript会认为它们是两个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var s = &quot;𠮷&quot;;</div><div class="line"></div><div class="line">s.length // 2</div><div class="line">s.charAt(0) // &apos;&apos;</div><div class="line">s.charAt(1) // &apos;&apos;</div><div class="line">s.charCodeAt(0) // 55362</div><div class="line">s.charCodeAt(1) // 57271</div></pre></td></tr></table></figure>
<p>ES6提供了<code>codePointAt</code>方法，能够正确处理4个字节储存的字符，返回一个字符的码点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = &apos;𠮷a&apos;;</div><div class="line"></div><div class="line">s.codePointAt(0).toString(16) // &quot;20bb7&quot;</div><div class="line">s.codePointAt(2).toString(16) // &quot;61&quot;</div></pre></td></tr></table></figure>
<p><code>codePointAt</code>方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt</code>方法相同。</p>
<h4 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h4><p>ES5提供<code>String.fromCharCode</code>方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。</p>
<p>ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String.fromCodePoint(0x20BB7)</div><div class="line">// &quot;𠮷&quot;</div><div class="line">String.fromCodePoint(0x78, 0x1f680, 0x79) === &apos;x\uD83D\uDE80y&apos;</div><div class="line">// true</div></pre></td></tr></table></figure>
<p>上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</p>
<h4 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h4><p>ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for…of循环遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (let codePoint of &apos;foo&apos;) &#123;</div><div class="line">  console.log(codePoint)</div><div class="line">&#125;</div><div class="line">// &quot;f&quot;</div><div class="line">// &quot;o&quot;</div><div class="line">// &quot;o&quot;</div></pre></td></tr></table></figure>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p>
<h4 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h4><p>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&apos;x&apos;.repeat(3) // &quot;xxx&quot;</div><div class="line">&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;</div><div class="line">&apos;na&apos;.repeat(0) // &quot;&quot;</div></pre></td></tr></table></figure>
<h4 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h4><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>传统的JavaScript语言，输出模板通常是这样写的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(&apos;#result&apos;).append(</div><div class="line">  &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; +</div><div class="line">  &apos;items in your basket, &apos; +</div><div class="line">  &apos;&lt;em&gt;&apos; + basket.onSale +</div><div class="line">  &apos;&lt;/em&gt; are on sale!&apos;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(&apos;#result&apos;).append(`</div><div class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</div><div class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure>
<h3 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h3><h4 id="RegExp构造函数"><a href="#RegExp构造函数" class="headerlink" title="RegExp构造函数"></a>RegExp构造函数</h4><p>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new RegExp(/abc/ig, &apos;i&apos;).flags</div><div class="line">// &quot;i&quot;</div></pre></td></tr></table></figure>
<p>上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。</p>
<h4 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h4><p>字符串对象共有4个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>
<p>ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>
<ul>
<li>String.prototype.match 调用 RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search 调用 RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split 调用 RegExp.prototype[Symbol.split]</li>
</ul>
<h4 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h4><p>S6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于<code>\uFFFF</code>的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/^\uD83D/u.test(&apos;\uD83D\uDC2A&apos;)</div><div class="line">// false</div><div class="line">/^\uD83D/.test(&apos;\uD83D\uDC2A&apos;)</div><div class="line">// true</div></pre></td></tr></table></figure>
<p>上面代码中，<code>\uD83D\uDC2A</code>是一个四个字节的UTF-16编码，代表一个字符。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>。加了<code>u</code>修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为<code>false</code>。</p>
<p>一旦加上<code>u</code>修饰符号，就会修改一些正则表达式的行为。</p>
<h4 id="y-修饰符"><a href="#y-修饰符" class="headerlink" title="y 修饰符"></a>y 修饰符</h4><p>除了<code>u</code>修饰符，ES6还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符。</p>
<p><code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<p>进一步说，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var s = &apos;aaa_aa_a&apos;;</div><div class="line">var r1 = /a+/g;</div><div class="line">var r2 = /a+/y;</div><div class="line"></div><div class="line">r1.exec(s) // [&quot;aaa&quot;]</div><div class="line">r2.exec(s) // [&quot;aaa&quot;]</div><div class="line"></div><div class="line">r1.exec(s) // [&quot;aa&quot;]</div><div class="line">r2.exec(s) // null</div></pre></td></tr></table></figure>
<p>与<code>y</code>修饰符相匹配，ES6的正则对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var r = /hello\d/y;</div><div class="line">r.sticky // true</div></pre></td></tr></table></figure>
<h4 id="flags属性"><a href="#flags属性" class="headerlink" title="flags属性"></a>flags属性</h4><p>ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// ES5的source属性</div><div class="line">// 返回正则表达式的正文</div><div class="line">/abc/ig.source</div><div class="line">// &quot;abc&quot;</div><div class="line"></div><div class="line">// ES6的flags属性</div><div class="line">// 返回正则表达式的修饰符</div><div class="line">/abc/ig.flags</div><div class="line">// &apos;gi&apos;</div></pre></td></tr></table></figure>
<h4 id="RegExp-escape"><a href="#RegExp-escape" class="headerlink" title="RegExp.escape()"></a>RegExp.escape()</h4><p>字符串必须转义，才能作为正则模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function escapeRegExp(str) &#123;</div><div class="line">  return str.replace(/[\-\[\]\/\&#123;\&#125;\(\)\*\+\?\.\\\^\$\|]/g, &apos;\\$&amp;&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">let str = &apos;/path/to/resource.html?search=query&apos;;</div><div class="line">escapeRegExp(str)</div><div class="line">// &quot;\/path\/to\/resource\.html\?search=query&quot;</div></pre></td></tr></table></figure>
<p>用字符串生成正则匹配模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">RegExp.escape(&apos;The Quick Brown Fox&apos;);</div><div class="line">// &quot;The Quick Brown Fox&quot;</div><div class="line"></div><div class="line">RegExp.escape(&apos;Buy it. use it. break it. fix it.&apos;);</div><div class="line">// &quot;Buy it\. use it\. break it\. fix it\.&quot;</div><div class="line"></div><div class="line">RegExp.escape(&apos;(*.*)&apos;);</div><div class="line">// &quot;\(\*\.\*\)&quot;</div></pre></td></tr></table></figure>
<h4 id="s-修饰符：dotAll-模式"><a href="#s-修饰符：dotAll-模式" class="headerlink" title="s 修饰符：dotAll 模式"></a>s 修饰符：dotAll 模式</h4><p>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外。</p>
<p>以下四个字符属于”行终止符“。</p>
<ul>
<li>U+000A 换行符（\n）</li>
<li>U+000D 回车符（\r）</li>
<li>U+2028 行分隔符（line separator）</li>
<li>U+2029 段分隔符（paragraph separator）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/foo.bar/.test(&apos;foo\nbar&apos;)</div><div class="line">// false</div></pre></td></tr></table></figure>
<p>现在有一个提案，引入<code>/s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/foo.bar/s.test(&apos;foo\nbar&apos;) // true</div></pre></td></tr></table></figure>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><h4 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="headerlink" title="二进制和八进制表示法"></a>二进制和八进制表示法</h4><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0b111110111 === 503 // true</div><div class="line">0o767 === 503 // true</div></pre></td></tr></table></figure>
<p>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Number(&apos;0b111&apos;)  // 7</div><div class="line">Number(&apos;0o10&apos;)  // 8</div></pre></td></tr></table></figure>
<h4 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(), Number.isNaN()"></a>Number.isFinite(), Number.isNaN()</h4><p>ES6在<code>Number</code>对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p>
<p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（<code>finite</code>）。</p>
<p><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。</p>
<p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回<code>false</code>。</p>
<h4 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h4><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到Number对象上面，行为完全保持不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// ES5的写法</div><div class="line">parseInt(&apos;12.34&apos;) // 12</div><div class="line">parseFloat(&apos;123.45#&apos;) // 123.45</div><div class="line"></div><div class="line">// ES6的写法</div><div class="line">Number.parseInt(&apos;12.34&apos;) // 12</div><div class="line">Number.parseFloat(&apos;123.45#&apos;) // 123.45</div></pre></td></tr></table></figure>
<h4 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h4><p><code>Number.isInteger()</code>用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Number.isInteger(25) // true</div><div class="line">Number.isInteger(25.0) // true</div><div class="line">Number.isInteger(25.1) // false</div><div class="line">Number.isInteger(&quot;15&quot;) // false</div><div class="line">Number.isInteger(true) // false</div></pre></td></tr></table></figure>
<h4 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h4><p>ES6在Number对象上面，新增一个极小的常量<code>Number.EPSILON</code>。</p>
<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。</p>
<p>但是如果这个误差能够小于<code>Number.EPSILON</code>，我们就可以认为得到了正确结果。</p>
<p>因此，<code>Number.EPSILON</code>的实质是一个可以接受的误差范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Number.EPSILON</div><div class="line">// 2.220446049250313e-16</div><div class="line">Number.EPSILON.toFixed(20)</div><div class="line">// &apos;0.00000000000000022204&apos;</div><div class="line">5.551115123125783e-17 &lt; Number.EPSILON</div><div class="line">// true</div></pre></td></tr></table></figure>
<h4 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h4><p>JavaScript能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Math.pow(2, 53) // 9007199254740992</div><div class="line"></div><div class="line">9007199254740992  // 9007199254740992</div><div class="line">9007199254740993  // 9007199254740992</div><div class="line"></div><div class="line">Math.pow(2, 53) === Math.pow(2, 53) + 1</div><div class="line">// true</div></pre></td></tr></table></figure>
<p>ES6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。<code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1</div><div class="line">// true</div><div class="line">Number.MAX_SAFE_INTEGER === 9007199254740991</div><div class="line">// true</div><div class="line"></div><div class="line">Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER</div><div class="line">// true</div><div class="line">Number.MIN_SAFE_INTEGER === -9007199254740991</div><div class="line">// true</div></pre></td></tr></table></figure>
<h3 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h3><h4 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h4><p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Math.trunc(4.1) // 4</div><div class="line">Math.trunc(4.9) // 4</div><div class="line">Math.trunc(-4.1) // -4</div><div class="line">Math.trunc(-4.9) // -4</div><div class="line">Math.trunc(-0.1234) // -0</div></pre></td></tr></table></figure>
<h4 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h4><p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
<h4 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h4><p><code>Math.cbrt</code>方法用于计算一个数的立方根。</p>
<h4 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h4><p>JavaScript的整数使用32位二进制形式表示，<code>Math.clz32</code>方法返回一个数的32位无符号整数形式有多少个前导0。</p>
<h4 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h4><p><code>Math.imul</code>方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。</p>
<p>大多数情况下，<code>Math.imul(a, b)</code>与<code>a * b</code>的结果是相同的,之所以需要部署这个方法，是因为JavaScript有精度限制，超过2的53次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，<code>Math.imul</code>方法可以返回正确的低位数值。</p>
<h4 id="Math-signbit"><a href="#Math-signbit" class="headerlink" title="Math.signbit()"></a>Math.signbit()</h4><p><code>Math.sign()</code>用来判断一个值的正负，但是如果参数是-0，它会返回-0。</p>
<p>引入了<code>Math.signbit()</code>方法判断一个数的符号位是否设置了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Math.signbit(2) //false</div><div class="line">Math.signbit(-2) //true</div><div class="line">Math.signbit(0) //false</div><div class="line">Math.signbit(-0) //true</div></pre></td></tr></table></figure>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。<code>Array.from</code>都可以将它们转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// NodeList对象</div><div class="line">let ps = document.querySelectorAll(&apos;p&apos;);</div><div class="line">Array.from(ps).forEach(function (p) &#123;</div><div class="line">  console.log(p);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// arguments对象</div><div class="line">function foo() &#123;</div><div class="line">  var args = Array.from(arguments);</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用<code>forEach</code>方法</p>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Array.of(3, 11, 8) // [3,11,8]</div><div class="line">Array.of(3) // [3]</div><div class="line">Array.of(3).length // 1</div></pre></td></tr></table></figure>
<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Array() // []</div><div class="line">Array(3) // [, , ,]</div><div class="line">Array(3, 11, 8) // [3, 11, 8]</div></pre></td></tr></table></figure>
<h4 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h4><p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<h4 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h4><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p>
<p>数组实例的<code>findIndex</code>方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p>
<p>这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>IndexOf</code>方法的不足。</p>
<h4 id="数组实例的entries-，keys-和values"><a href="#数组实例的entries-，keys-和values" class="headerlink" title="数组实例的entries()，keys()和values()"></a>数组实例的entries()，keys()和values()</h4><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</div><div class="line">  console.log(index);</div><div class="line">&#125;</div><div class="line">// 0</div><div class="line">// 1</div><div class="line"></div><div class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</div><div class="line">  console.log(elem);</div><div class="line">&#125;</div><div class="line">// &apos;a&apos;</div><div class="line">// &apos;b&apos;</div><div class="line"></div><div class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</div><div class="line">  console.log(index, elem);</div><div class="line">&#125;</div><div class="line">// 0 &quot;a&quot;</div><div class="line">// 1 &quot;b&quot;</div></pre></td></tr></table></figure>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="函数参数的默认值-1"><a href="#函数参数的默认值-1" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><p>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function log(x, y) &#123;</div><div class="line">  y = y || &apos;World&apos;;</div><div class="line">  console.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(&apos;Hello&apos;) // Hello World</div><div class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</div><div class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello World</div></pre></td></tr></table></figure>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function log(x, y = &apos;World&apos;) &#123;</div><div class="line">  console.log(x, y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(&apos;Hello&apos;) // Hello World</div><div class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</div><div class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello</div></pre></td></tr></table></figure>
<p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<h4 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h4><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>
<h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><p>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function add(...values) &#123;</div><div class="line">  let sum = 0;</div><div class="line"></div><div class="line">  for (var val of values) &#123;</div><div class="line">    sum += val;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(2, 5, 3) // 10</div></pre></td></tr></table></figure>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">console.log(...[1, 2, 3])</div><div class="line">// 1 2 3</div><div class="line"></div><div class="line">console.log(1, ...[2, 3, 4], 5)</div><div class="line">// 1 2 3 4 5</div><div class="line"></div><div class="line">[...document.querySelectorAll(&apos;div&apos;)]</div><div class="line">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</div></pre></td></tr></table></figure>
<h5 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h5><p><strong>合并数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">[1, 2].concat(more)</div><div class="line">// ES6</div><div class="line">[1, 2, ...more]</div></pre></td></tr></table></figure>
<p><strong>与解构赋值结合</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// ES5</div><div class="line">a = list[0], rest = list.slice(1)</div><div class="line">// ES6</div><div class="line">[a, ...rest] = list</div></pre></td></tr></table></figure>
<p><strong>字符串</strong></p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[...&apos;hello&apos;]</div><div class="line">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</div></pre></td></tr></table></figure>
<p>上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数</p>
<p>凡是涉及到操作32位Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let str = &apos;x\uD83D\uDE80y&apos;;</div><div class="line"></div><div class="line">str.split(&apos;&apos;).reverse().join(&apos;&apos;)</div><div class="line">// &apos;y\uDE80\uD83Dx&apos;</div><div class="line"></div><div class="line">[...str].reverse().join(&apos;&apos;)</div><div class="line">// &apos;y\uD83D\uDE80x&apos;</div></pre></td></tr></table></figure>
<h4 id="实现了Iterator接口的对象"><a href="#实现了Iterator接口的对象" class="headerlink" title="实现了Iterator接口的对象"></a>实现了Iterator接口的对象</h4><p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var nodeList = document.querySelectorAll(&apos;div&apos;);</div><div class="line">var array = [...nodeList];</div></pre></td></tr></table></figure>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6允许使用“箭头”（<code>=&gt;</code>）定义函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var f = v =&gt; v;</div></pre></td></tr></table></figure>
<p>上面的箭头函数等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var f = function(v) &#123;</div><div class="line">  return v;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;</div></pre></td></tr></table></figure>
<p>如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);</div></pre></td></tr></table></figure>
<p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<p>箭头函数转成ES5的代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">function foo() &#123;</div><div class="line">  setTimeout(() =&gt; &#123;</div><div class="line">    console.log(&apos;id:&apos;, this.id);</div><div class="line">  &#125;, 100);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ES5</div><div class="line">function foo() &#123;</div><div class="line">  var _this = this;</div><div class="line"></div><div class="line">  setTimeout(function () &#123;</div><div class="line">    console.log(&apos;id:&apos;, _this.id);</div><div class="line">  &#125;, 100);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="绑定-this"><a href="#绑定-this" class="headerlink" title="绑定 this"></a>绑定 this</h4><p>箭头函数可以绑定<code>this</code>对象，大大减少了显式绑定<code>this</code>对象的写法（<code>call、apply、bind</code>）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代<code>call、apply、bind</code>调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">foo::bar;</div><div class="line">// 等同于</div><div class="line">bar.bind(foo);</div><div class="line"></div><div class="line">foo::bar(...arguments);</div><div class="line">// 等同于</div><div class="line">bar.apply(foo, arguments);</div></pre></td></tr></table></figure>
<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><h5 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h5><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function f(x)&#123;</div><div class="line">  return g(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="尾调用优化-1"><a href="#尾调用优化-1" class="headerlink" title="尾调用优化"></a>尾调用优化</h5><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<h5 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h5><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<p>还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性</p>
<p>如果是非尾递归的fibonacci 递归方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Fibonacci (n) &#123;</div><div class="line">  if ( n &lt;= 1 ) &#123;return 1&#125;;</div><div class="line"></div><div class="line">  return Fibonacci(n - 1) + Fibonacci(n - 2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Fibonacci(10); // 89</div><div class="line">// Fibonacci(100)</div><div class="line">// Fibonacci(500)</div><div class="line">// 堆栈溢出了</div></pre></td></tr></table></figure>
<p>如果我们使用尾递归优化过的fibonacci 递归算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;</div><div class="line">  if( n &lt;= 1 ) &#123;return ac2&#125;;</div><div class="line"></div><div class="line">  return Fibonacci2 (n - 1, ac2, ac1 + ac2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Fibonacci2(100) // 573147844013817200000</div><div class="line">Fibonacci2(1000) // 7.0330367711422765e+208</div><div class="line">Fibonacci2(10000) // Infinity</div></pre></td></tr></table></figure>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>
<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function currying(fn, n) &#123;</div><div class="line">  return function (m) &#123;</div><div class="line">    return fn.call(this, m, n);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function tailFactorial(n, total) &#123;</div><div class="line">  if (n === 1) return total;</div><div class="line">  return tailFactorial(n - 1, n * total);</div><div class="line">&#125;</div><div class="line"></div><div class="line">const factorial = currying(tailFactorial, 1);</div><div class="line"></div><div class="line">factorial(5) // 120</div></pre></td></tr></table></figure>
<p><strong>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</strong></p>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h4><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var foo = &apos;bar&apos;;</div><div class="line">var baz = &#123;foo&#125;;</div><div class="line">baz // &#123;foo: &quot;bar&quot;&#125;</div><div class="line"></div><div class="line">// 等同于</div><div class="line">var baz = &#123;foo: foo&#125;;</div></pre></td></tr></table></figure>
<p>除了属性简写，方法也可以简写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">  method() &#123;</div><div class="line">    return &quot;Hello!&quot;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 等同于</div><div class="line"></div><div class="line">var o = &#123;</div><div class="line">  method: function() &#123;</div><div class="line">    return &quot;Hello!&quot;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var lastWord = &apos;last word&apos;;</div><div class="line"></div><div class="line">var a = &#123;</div><div class="line">  &apos;first word&apos;: &apos;hello&apos;,</div><div class="line">  [lastWord]: &apos;world&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">a[&apos;first word&apos;] // &quot;hello&quot;</div><div class="line">a[lastWord] // &quot;world&quot;</div><div class="line">a[&apos;last word&apos;] // &quot;world&quot;</div></pre></td></tr></table></figure>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>ES5比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+0 === -0 //true</div><div class="line">NaN === NaN // false</div><div class="line"></div><div class="line">Object.is(+0, -0) // false</div><div class="line">Object.is(NaN, NaN) // true</div></pre></td></tr></table></figure>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var target = &#123; a: 1 &#125;;</div><div class="line"></div><div class="line">var source1 = &#123; b: 2 &#125;;</div><div class="line">var source2 = &#123; c: 3 &#125;;</div><div class="line"></div><div class="line">Object.assign(target, source1, source2);</div><div class="line">target // &#123;a:1, b:2, c:3&#125;</div></pre></td></tr></table></figure>
<p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><p>ES6一共有5种方法可以遍历对象的属性。</p>
<p>（1）for…in</p>
<p>for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p>
<p>（2）Object.keys(obj)</p>
<p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</p>
<p>（3）Object.getOwnPropertyNames(obj)</p>
<p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</p>
<p>（4）Object.getOwnPropertySymbols(obj)</p>
<p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</p>
<p>（5）Reflect.ownKeys(obj)</p>
<p>Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</p>
<h4 id="proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a><code>__proto__</code>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h4><p><code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>在实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code></p>
<h4 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h4><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名</p>
<p>ES2017 引入了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p>
<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><p>ES5有一个<code>Object.getOwnPropertyDescriptor</code>方法，返回某个对象属性的描述对象（descriptor）。</p>
<p>ES2017 引入了<code>Object.getOwnPropertyDescriptors</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">const obj = &#123;</div><div class="line">  foo: 123,</div><div class="line">  get bar() &#123; return &apos;abc&apos; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Object.getOwnPropertyDescriptors(obj)</div><div class="line">// &#123; foo:</div><div class="line">//    &#123; value: 123,</div><div class="line">//      writable: true,</div><div class="line">//      enumerable: true,</div><div class="line">//      configurable: true &#125;,</div><div class="line">//   bar:</div><div class="line">//    &#123; get: [Function: bar],</div><div class="line">//      set: undefined,</div><div class="line">//      enumerable: true,</div><div class="line">//      configurable: true &#125; &#125;</div></pre></td></tr></table></figure>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。</p>
<p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let s = Symbol();</div><div class="line"></div><div class="line">typeof s</div><div class="line">// &quot;symbol&quot;</div></pre></td></tr></table></figure>
<p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。</p>
<h4 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var mySymbol = Symbol();</div><div class="line"></div><div class="line">// 第一种写法</div><div class="line">var a = &#123;&#125;;</div><div class="line">a[mySymbol] = &apos;Hello!&apos;;</div><div class="line"></div><div class="line">// 第二种写法</div><div class="line">var a = &#123;</div><div class="line">  [mySymbol]: &apos;Hello!&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 第三种写法</div><div class="line">var a = &#123;&#125;;</div><div class="line">Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);</div><div class="line"></div><div class="line">// 以上写法都得到同样结果</div><div class="line">a[mySymbol] // &quot;Hello!&quot;</div></pre></td></tr></table></figure>
<p>注意，Symbol值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var mySymbol = Symbol();</div><div class="line">var a = &#123;&#125;;</div><div class="line"></div><div class="line">a.mySymbol = &apos;Hello!&apos;;</div><div class="line">a[mySymbol] // undefined</div><div class="line">a[&apos;mySymbol&apos;] // &quot;Hello!&quot;</div></pre></td></tr></table></figure>
<h4 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h4><p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p>另一个新的API，<code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">  [Symbol(&apos;my_key&apos;)]: 1,</div><div class="line">  enum: 2,</div><div class="line">  nonEnum: 3</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Reflect.ownKeys(obj)</div><div class="line">//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</div></pre></td></tr></table></figure>
<p>由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<h4 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h4><p>有时，我们希望重新使用同一个Symbol值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p>
<h5 id="模块的-Singleton-模式"><a href="#模块的-Singleton-模式" class="headerlink" title="模块的 Singleton 模式"></a>模块的 Singleton 模式</h5><p>Singleton模式指的是调用一个类，任何时候返回的都是同一个实例。使用 <code>Symbol.for</code> 可以实现。</p>
<h3 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h3><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<p>扩展运算符和Set结构相结合，就可以去除数组的重复成员。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let arr = [3, 5, 2, 2, 5, 5];</div><div class="line">let unique = [...new Set(arr)];</div><div class="line">// [3, 5, 2]</div></pre></td></tr></table></figure>
<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p>
<p>首先，WeakSet的成员只能是对象，而不能是其他类型的值。</p>
<p>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>
<p>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<p>为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>
<p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>
<ul>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历Map的所有成员。</li>
</ul>
<p>需要特别注意的是，Map的遍历顺序就是插入顺序。</p>
<h5 id="Map转为数组"><a href="#Map转为数组" class="headerlink" title="Map转为数组"></a>Map转为数组</h5><p>前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</div><div class="line">[...myMap]</div><div class="line">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &apos;abc&apos; ] ] ]</div></pre></td></tr></table></figure>
<p>将数组转入Map构造函数，就可以转为Map。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">new Map([[true, 7], [&#123;foo: 3&#125;, [&apos;abc&apos;]]])</div><div class="line">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&apos;abc&apos;]&#125;</div></pre></td></tr></table></figure>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p><code>WeakMap</code>结构与<code>Map</code>结构基本类似，唯一的区别是它只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj = new Proxy(&#123;&#125;, &#123;</div><div class="line">  get: function (target, key, receiver) &#123;</div><div class="line">    console.log(`getting $&#123;key&#125;!`);</div><div class="line">    return Reflect.get(target, key, receiver);</div><div class="line">  &#125;,</div><div class="line">  set: function (target, key, value, receiver) &#123;</div><div class="line">    console.log(`setting $&#123;key&#125;!`);</div><div class="line">    return Reflect.set(target, key, value, receiver);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">obj.count = 1</div><div class="line">//  setting count!</div><div class="line">++obj.count</div><div class="line">//  getting count!</div><div class="line">//  setting count!</div><div class="line">//  2</div></pre></td></tr></table></figure>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>
<p>（1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</p>
<p>（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</p>
<p>（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p>
<p>（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</p>
<h3 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>如果某些事件不断地反复发生，一般来说，使用 stream 模式是比部署Promise更好的选择。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  // ... some code</div><div class="line"></div><div class="line">  if (/* 异步操作成功 */)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; else &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p>
<p>Promise实例生成以后，可以用<code>then</code>方法分别指定<code>Resolved</code>状态和<code>Reject</code>状态的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(function(value) &#123;</div><div class="line">  // success</div><div class="line">&#125;, function(error) &#123;</div><div class="line">  // failure</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以使用 <code>Promise</code> 异步加载图片，进行 Ajax 处理等。</p>
<p>下面是异步加载图片的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function loadImageAsync(url) &#123;</div><div class="line">  return new Promise(function(resolve, reject) &#123;</div><div class="line">    var image = new Image();</div><div class="line"></div><div class="line">    image.onload = function() &#123;</div><div class="line">      resolve(image);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    image.onerror = function() &#123;</div><div class="line">      reject(new Error(&apos;Could not load image at &apos; + url));</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    image.src = url;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是一个用Promise对象实现的Ajax操作的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var getJSON = function(url) &#123;</div><div class="line">  var promise = new Promise(function(resolve, reject)&#123;</div><div class="line">    var client = new XMLHttpRequest();</div><div class="line">    client.open(&quot;GET&quot;, url);</div><div class="line">    client.onreadystatechange = handler;</div><div class="line">    client.responseType = &quot;json&quot;;</div><div class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</div><div class="line">    client.send();</div><div class="line"></div><div class="line">    function handler() &#123;</div><div class="line">      if (this.readyState !== 4) &#123;</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line">      if (this.status === 200) &#123;</div><div class="line">        resolve(this.response);</div><div class="line">      &#125; else &#123;</div><div class="line">        reject(new Error(this.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  return promise;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</div><div class="line">  console.log(&apos;Contents: &apos; + json);</div><div class="line">&#125;, function(error) &#123;</div><div class="line">  console.error(&apos;出错了&apos;, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<p>一般来说，不要在<code>then</code>方法里面定义<code>Reject</code>状态的回调函数（即then的第二个参数），总是使用<code>catch</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">promise</div><div class="line">  .then(function(data) &#123;</div><div class="line">    // success</div><div class="line">  &#125;, function(err) &#123;</div><div class="line">    // error</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">// good</div><div class="line">promise</div><div class="line">  .then(function(data) &#123; //cb</div><div class="line">    // success</div><div class="line">  &#125;)</div><div class="line">  .catch(function(err) &#123;</div><div class="line">    // error</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch</code>方法，而不使用<code>then</code>方法的第二个参数。</p>
<p><strong>缺点：跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，<code>Promise</code>对象抛出的错误不会传递到外层代码，即不会有任何反应。</strong></p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p><code>Promise.all</code>方法用于将多个Promise实例，包装成一个新的Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var p = Promise.all([p1, p2, p3]);</div></pre></td></tr></table></figure>
<p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>
<p>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><code>Promise.race</code>方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>
<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>有时需要将现有对象转为Promise对象，<code>Promise.resolve</code>方法就起到这个作用。</p>
<h4 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h4><p>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h4><p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<h3 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h3><h4 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h4><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令<code>for...of</code>循环，Iterator接口主要供<code>for...of</code>消费。</p>
<h4 id="数据结构的默认Iterator接口"><a href="#数据结构的默认Iterator接口" class="headerlink" title="数据结构的默认Iterator接口"></a>数据结构的默认Iterator接口</h4><p>Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。</p>
<p>在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象(字符串，<code>rguments</code>对象、DOM NodeList 对象，Generator 对象)、Set和Map结构。</p>
<p>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别32位UTF-16字符。</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p>
<p>JavaScript原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6提供for…of循环，允许遍历获得键值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</div><div class="line"></div><div class="line">for (let a in arr) &#123;</div><div class="line">  console.log(a); // 0 1 2 3</div><div class="line">&#125;</div><div class="line"></div><div class="line">for (let a of arr) &#123;</div><div class="line">  console.log(a); // a b c d</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Set和Map结构"><a href="#Set和Map结构" class="headerlink" title="Set和Map结构"></a>Set和Map结构</h5><p>遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。</p>
<h3 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案</p>
<p>Generator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号(<code>*</code>)；二是，函数体内部使用<code>yield</code>语句，定义不同的内部状态（yield在英语里的意思就是“产出”）。</p>
<p>yield语句不能用在普通函数中，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function* helloWorldGenerator() &#123;</div><div class="line">  yield &apos;hello&apos;;</div><div class="line">  yield &apos;world&apos;;</div><div class="line">  return &apos;ending&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var hw = helloWorldGenerator();</div></pre></td></tr></table></figure>
<p>上面代码定义了一个Generator函数helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello，world和return语句（结束执行）。</p>
<p>每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。</p>
<h4 id="与Iterator接口的关系"><a href="#与Iterator接口的关系" class="headerlink" title="与Iterator接口的关系"></a>与Iterator接口的关系</h4><p>由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。</p>
<h4 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h4><p>Generator函数返回的遍历器对象，还有一个<code>return</code>方法，可以返回给定的值，并且终结遍历Generator函数。</p>
<p><strong>第一次使用 <code>next()</code>，就从函数头运行到第一个 <code>yield</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function* gen() &#123;</div><div class="line">  yield 1;</div><div class="line">  yield 2;</div><div class="line">  yield 3;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen();</div><div class="line"></div><div class="line">g.next()        // &#123; value: 1, done: false &#125;</div><div class="line">g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125;</div><div class="line">g.next()        // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<h4 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield* 语句"></a>yield* 语句</h4><p>用到<code>yield*</code>语句，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="异步操作的同步化表达"><a href="#异步操作的同步化表达" class="headerlink" title="异步操作的同步化表达"></a>异步操作的同步化表达</h5><p>Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。</p>
<p>通过Generator函数逐行读取文本文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function* numbers() &#123;</div><div class="line">  let file = new FileReader(&quot;numbers.txt&quot;);</div><div class="line">  try &#123;</div><div class="line">    while(!file.eof) &#123;</div><div class="line">      yield parseInt(file.readLine(), 10);</div><div class="line">    &#125;</div><div class="line">  &#125; finally &#123;</div><div class="line">    file.close();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="控制流管理"><a href="#控制流管理" class="headerlink" title="控制流管理"></a>控制流管理</h5><p>利用<code>for...of</code>循环会自动依次执行<code>yield</code>命令的特性，提供一种更一般的控制流管理的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let steps = [step1Func, step2Func, step3Func];</div><div class="line"></div><div class="line">function *iterateSteps(steps)&#123;</div><div class="line">  for (var i=0; i&lt; steps.length; i++)&#123;</div><div class="line">    var step = steps[i];</div><div class="line">    yield step();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="部署Iterator接口"><a href="#部署Iterator接口" class="headerlink" title="部署Iterator接口"></a>部署Iterator接口</h5><p>利用Generator函数，可以在任意对象上部署Iterator接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function* iterEntries(obj) &#123;</div><div class="line">  let keys = Object.keys(obj);</div><div class="line">  for (let i=0; i &lt; keys.length; i++) &#123;</div><div class="line">    let key = keys[i];</div><div class="line">    yield [key, obj[key]];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let myObj = &#123; foo: 3, bar: 7 &#125;;</div><div class="line"></div><div class="line">for (let [key, value] of iterEntries(myObj)) &#123;</div><div class="line">  console.log(key, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// foo 3</div><div class="line">// bar 7</div></pre></td></tr></table></figure>
<h3 id="Generator-函数的异步应用"><a href="#Generator-函数的异步应用" class="headerlink" title="Generator 函数的异步应用"></a>Generator 函数的异步应用</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字<code>callback</code>，直译过来就是”重新调用”。</p>
<h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fs.readFile(fileA, &apos;utf-8&apos;, function (err, data) &#123;</div><div class="line">  fs.readFile(fileB, &apos;utf-8&apos;, function (err, data) &#123;</div><div class="line">    // ...</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。</p>
<p>Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var readFile = require(&apos;fs-readfile-promise&apos;);</div><div class="line"></div><div class="line">readFile(fileA)</div><div class="line">.then(function (data) &#123;</div><div class="line">  console.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.then(function () &#123;</div><div class="line">  return readFile(fileB);</div><div class="line">&#125;)</div><div class="line">.then(function (data) &#123;</div><div class="line">  console.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.catch(function (err) &#123;</div><div class="line">  console.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆<code>then</code>，原来的语义变得很不清楚。</p>
<h4 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h4><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function *asyncJob() &#123;</div><div class="line">  // ...其他代码</div><div class="line">  var f = yield readFile(fileA);</div><div class="line">  // ...其他代码</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线。</p>
<p>协程遇到<code>yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除<code>yield</code>命令，简直一模一样。</p>
<h5 id="协程的-Generator-函数实现"><a href="#协程的-Generator-函数实现" class="headerlink" title="协程的 Generator 函数实现"></a>协程的 Generator 函数实现</h5><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function* gen(x) &#123;</div><div class="line">  var y = yield x + 2;</div><div class="line">  return y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen(1);</div><div class="line">g.next() // &#123; value: 3, done: false &#125;</div><div class="line">g.next() // &#123; value: undefined, done: true &#125;</div></pre></td></tr></table></figure>
<p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。</p>
<h4 id="Thunk-函数的自动流程管理"><a href="#Thunk-函数的自动流程管理" class="headerlink" title="Thunk 函数的自动流程管理"></a>Thunk 函数的自动流程管理</h4><p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。</p>
<h4 id="co-模块"><a href="#co-模块" class="headerlink" title="co 模块"></a>co 模块</h4><p>co 模块是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行</p>
<h3 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p>
<p>前文有一个 Generator 函数，依次读取两个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">var readFile = function (fileName) &#123;</div><div class="line">  return new Promise(function (resolve, reject) &#123;</div><div class="line">    fs.readFile(fileName, function(error, data) &#123;</div><div class="line">      if (error) reject(error);</div><div class="line">      resolve(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var gen = function* () &#123;</div><div class="line">  var f1 = yield readFile(&apos;/etc/fstab&apos;);</div><div class="line">  var f2 = yield readFile(&apos;/etc/shells&apos;);</div><div class="line">  console.log(f1.toString());</div><div class="line">  console.log(f2.toString());</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>写成<code>async</code>函数，就是下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var asyncReadFile = async function () &#123;</div><div class="line">  var f1 = await readFile(&apos;/etc/fstab&apos;);</div><div class="line">  var f2 = await readFile(&apos;/etc/shells&apos;);</div><div class="line">  console.log(f1.toString());</div><div class="line">  console.log(f2.toString());</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>
<p>async函数对 Generator 函数的改进，体现在以下四点。</p>
<p>（1）内置执行器。</p>
<p>（2）更好的语义。</p>
<p>（3）更广的适用性。</p>
<p>（4）返回值是 Promise。</p>
<p>async 函数有多种使用形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 函数声明</div><div class="line">async function foo() &#123;&#125;</div><div class="line"></div><div class="line">// 函数表达式</div><div class="line">const foo = async function () &#123;&#125;;</div><div class="line"></div><div class="line">// 对象的方法</div><div class="line">let obj = &#123; async foo() &#123;&#125; &#125;;</div><div class="line">obj.foo().then(...)</div><div class="line"></div><div class="line">// Class 的方法</div><div class="line">class Storage &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    this.cachePromise = caches.open(&apos;avatars&apos;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  async getAvatar(name) &#123;</div><div class="line">    const cache = await this.cachePromise;</div><div class="line">    return cache.match(`/avatars/$&#123;name&#125;.jpg`);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const storage = new Storage();</div><div class="line">storage.getAvatar(&apos;jake&apos;).then(…);</div><div class="line"></div><div class="line">// 箭头函数</div><div class="line">const foo = async () =&gt; &#123;&#125;;</div></pre></td></tr></table></figure>
<h4 id="Promise-对象的状态变"><a href="#Promise-对象的状态变" class="headerlink" title="Promise 对象的状态变"></a>Promise 对象的状态变</h4><p>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">async function getTitle(url) &#123;</div><div class="line">  let response = await fetch(url);</div><div class="line">  let html = await response.text();</div><div class="line">  return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];</div><div class="line">&#125;</div><div class="line">getTitle(&apos;https://tc39.github.io/ecma262/&apos;).then(console.log)</div><div class="line">// &quot;ECMAScript 2017 Language Specification&quot;</div></pre></td></tr></table></figure>
<p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的<code>console.log</code>。</p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//定义类</div><div class="line">class Point &#123;</div><div class="line">  constructor(x, y) &#123;</div><div class="line">    this.x = x;</div><div class="line">    this.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  [methodName]() &#123;</div><div class="line">    // ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">typeof Point // &quot;function&quot;</div><div class="line">Point === Point.prototype.constructor // true</div></pre></td></tr></table></figure>
<p>构造函数的<code>prototype</code>属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p>
<p>类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<h4 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//定义类</div><div class="line">class Point &#123;</div><div class="line"></div><div class="line">  constructor(x, y) &#123;</div><div class="line">    this.x = x;</div><div class="line">    this.y = y;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">var point = new Point(2, 3);</div><div class="line"></div><div class="line">point.toString() // (2, 3)</div><div class="line"></div><div class="line">point.hasOwnProperty(&apos;x&apos;) // true</div><div class="line">point.hasOwnProperty(&apos;y&apos;) // true</div><div class="line">point.hasOwnProperty(&apos;toString&apos;) // false</div><div class="line">point.__proto__.hasOwnProperty(&apos;toString&apos;) // true</div></pre></td></tr></table></figure>
<p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。</p>
<h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p>
<h4 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h4><p>类的方法内部如果含有this，它默认指向类的实例。</p>
<h4 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h4><p>Class之间可以通过<code>extends</code>关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class ColorPoint extends Point &#123;</div><div class="line">  constructor(x, y, color) &#123;</div><div class="line">    super(x, y); // 调用父类的constructor(x, y)</div><div class="line">    this.color = color;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<p>ES5的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>
<p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p>
<h4 id="类的prototype属性和proto属性"><a href="#类的prototype属性和proto属性" class="headerlink" title="类的prototype属性和proto属性"></a>类的prototype属性和<strong>proto</strong>属性</h4><p>大多数浏览器的ES5实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>
<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B extends A &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">B.__proto__ === A // true</div><div class="line">B.prototype.__proto__ === A.prototype // true</div></pre></td></tr></table></figure>
<h4 id="Extends-的继承目标"><a href="#Extends-的继承目标" class="headerlink" title="Extends 的继承目标"></a>Extends 的继承目标</h4><p>extends关键字后面可以跟多种类型的值。</p>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class A &#123;&#125;</div><div class="line"></div><div class="line">class B extends A &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    super();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种情况，super作为对象时，指向父类的原型对象。</p>
<h4 id="实例的proto属性"><a href="#实例的proto属性" class="headerlink" title="实例的proto属性"></a>实例的<strong>proto</strong>属性</h4><p>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var p1 = new Point(2, 3);</div><div class="line">var p2 = new ColorPoint(2, 3, &apos;red&apos;);</div><div class="line"></div><div class="line">p2.__proto__ // Point &#123;&#125;</div><div class="line">p2.__proto__ === p1.__proto__ // false</div><div class="line">p2.__proto__.__proto__ === p1.__proto__ // true</div></pre></td></tr></table></figure>
<h4 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h4><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。</p>
<ul>
<li>Boolean()</li>
<li>Number()</li>
<li>String()</li>
<li>Array()</li>
<li>Date()</li>
<li>Function()</li>
<li>RegExp()</li>
<li>Error()</li>
<li>Object()</li>
</ul>
<p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。</p>
<p>ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。</p>
<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class MyArray extends Array &#123;</div><div class="line">  constructor(...args) &#123;</div><div class="line">    super(...args);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var arr = new MyArray();</div><div class="line">arr[0] = 12;</div><div class="line">arr.length // 1</div><div class="line"></div><div class="line">arr.length = 0;</div><div class="line">arr[0] // undefined</div></pre></td></tr></table></figure>
<h4 id="Class的取值函数（getter）和存值函数（setter）"><a href="#Class的取值函数（getter）和存值函数（setter）" class="headerlink" title="Class的取值函数（getter）和存值函数（setter）"></a>Class的取值函数（getter）和存值函数（setter）</h4><p>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    // ...</div><div class="line">  &#125;</div><div class="line">  get prop() &#123;</div><div class="line">    return &apos;getter&apos;;</div><div class="line">  &#125;</div><div class="line">  set prop(value) &#123;</div><div class="line">    console.log(&apos;setter: &apos;+value);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let inst = new MyClass();</div><div class="line"></div><div class="line">inst.prop = 123;</div><div class="line">// setter: 123</div><div class="line"></div><div class="line">inst.prop</div><div class="line">// &apos;getter&apos;</div></pre></td></tr></table></figure>
<h4 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h4><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<h4 id="Class的静态属性和实例属性"><a href="#Class的静态属性和实例属性" class="headerlink" title="Class的静态属性和实例属性"></a>Class的静态属性和实例属性</h4><p>静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prop = 1;</div><div class="line">Foo.prop // 1</div></pre></td></tr></table></figure>
<p>上面的写法为Foo类定义了一个静态属性prop。</p>
<p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>
<h4 id="new-target属性"><a href="#new-target属性" class="headerlink" title="new.target属性"></a>new.target属性</h4><p>new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<h4 id="Mixin模式的实现"><a href="#Mixin模式的实现" class="headerlink" title="Mixin模式的实现"></a>Mixin模式的实现</h4><p>将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class DistributedEdit extends mix(Loggable, Serializable) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="修饰器-Decorator"><a href="#修饰器-Decorator" class="headerlink" title="修饰器(Decorator)"></a>修饰器(Decorator)</h3><h4 id="类的修饰"><a href="#类的修饰" class="headerlink" title="类的修饰"></a>类的修饰</h4><p>修饰器（Decorator）是一个函数，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function testable(target) &#123;</div><div class="line">  target.isTestable = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@testable</div><div class="line">class MyTestableClass &#123;&#125;</div><div class="line"></div><div class="line">console.log(MyTestableClass.isTestable) // true</div></pre></td></tr></table></figure>
<p>基本上，修饰器的行为就是下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@decorator</div><div class="line">class A &#123;&#125;</div><div class="line"></div><div class="line">// 等同于</div><div class="line"></div><div class="line">class A &#123;&#125;</div><div class="line">A = decorator(A) || A;</div></pre></td></tr></table></figure>
<h4 id="方法的修饰"><a href="#方法的修饰" class="headerlink" title="方法的修饰"></a>方法的修饰</h4><p>修饰器不仅可以修饰类，还可以修饰类的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">  @readonly</div><div class="line">  name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，修饰器readonly用来修饰“类”的name方法。</p>
<p>此时，修饰器函数一共可以接受三个参数，第一个参数是所要修饰的目标对象，第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function readonly(target, name, descriptor)&#123;</div><div class="line">  // descriptor对象原来的值如下</div><div class="line">  // &#123;</div><div class="line">  //   value: specifiedFunction,</div><div class="line">  //   enumerable: false,</div><div class="line">  //   configurable: true,</div><div class="line">  //   writable: true</div><div class="line">  // &#125;;</div><div class="line">  descriptor.writable = false;</div><div class="line">  return descriptor;</div><div class="line">&#125;</div><div class="line"></div><div class="line">readonly(Person.prototype, &apos;name&apos;, descriptor);</div><div class="line">// 类似于</div><div class="line">Object.defineProperty(Person.prototype, &apos;name&apos;, descriptor);</div></pre></td></tr></table></figure>
<h4 id="为什么修饰器不能用于函数？"><a href="#为什么修饰器不能用于函数？" class="headerlink" title="为什么修饰器不能用于函数？"></a>为什么修饰器不能用于函数？</h4><p>修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p>
<h4 id="core-decorators-js"><a href="#core-decorators-js" class="headerlink" title="core-decorators.js"></a>core-decorators.js</h4><p>core-decorators.js是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。</p>
<h3 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h3><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// CommonJS模块</div><div class="line">let &#123; stat, exists, readFile &#125; = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">// 等同于</div><div class="line">let _fs = require(&apos;fs&apos;);</div><div class="line">let stat = _fs.stat;</div><div class="line">let exists = _fs.exists;</div><div class="line">let readfile = _fs.readfile;</div></pre></td></tr></table></figure>
<p>ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// ES6模块</div><div class="line">import &#123; stat, exists, readFile &#125; from &apos;fs&apos;;</div></pre></td></tr></table></figure>
<p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<h4 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h4><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// profile.js</div><div class="line">export var firstName = &apos;Michael&apos;;</div><div class="line">export var lastName = &apos;Jackson&apos;;</div><div class="line">export var year = 1958;</div><div class="line">// 或者</div><div class="line">export &#123;firstName, lastName, year&#125;;</div></pre></td></tr></table></figure>
<p><code>export</code>命令除了输出变量，还可以输出函数或类（class）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export function multiply(x, y) &#123;</div><div class="line">  return x * y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function v1() &#123; ... &#125;</div><div class="line">function v2() &#123; ... &#125;</div><div class="line"></div><div class="line">export &#123;</div><div class="line">  v1 as streamV1,</div><div class="line">  v2 as streamV2,</div><div class="line">  v2 as streamLatestVersion</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">export 1;</div><div class="line"></div><div class="line">// 报错</div><div class="line">var m = 1;</div><div class="line">export m;</div><div class="line"></div><div class="line">// 写法一</div><div class="line">export var m = 1;</div><div class="line"></div><div class="line">// 写法二</div><div class="line">var m = 1;</div><div class="line">export &#123;m&#125;;</div><div class="line"></div><div class="line">// 写法三</div><div class="line">var n = 1;</div><div class="line">export &#123;n as m&#125;;</div></pre></td></tr></table></figure>
<p><strong><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</strong>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新</p>
<p><code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。</p>
<h4 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h4><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// main.js</div><div class="line">import &#123;firstName, lastName, year&#125; from &apos;./profile&apos;;</div><div class="line"></div><div class="line">function setName(element) &#123;</div><div class="line">  element.textContent = firstName + &apos; &apos; + lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//</div><div class="line">import &#123; lastName as surname &#125; from &apos;./profile&apos;;</div></pre></td></tr></table></figure>
<p>上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。</p>
<p>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
<p>如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。</p>
<h4 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h4><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import * as circle from &apos;./circle&apos;;</div><div class="line"></div><div class="line">console.log(&apos;圆面积：&apos; + circle.area(4));</div><div class="line">console.log(&apos;圆周长：&apos; + circle.circumference(14));</div></pre></td></tr></table></figure>
<h4 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h4><p>从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>
<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// export-default.js</div><div class="line">export default function () &#123;</div><div class="line">  console.log(&apos;foo&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// import-default.js</div><div class="line">import customName from &apos;./export-default&apos;;</div><div class="line">customName(); // &apos;foo&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 第一组</div><div class="line">export default function crc32() &#123; // 输出</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">import crc32 from &apos;crc32&apos;; // 输入</div><div class="line"></div><div class="line">// 第二组</div><div class="line">export function crc32() &#123; // 输出</div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">import &#123;crc32&#125; from &apos;crc32&apos;; // 输入</div></pre></td></tr></table></figure>
<p>上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。</p>
<p>export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。</p>
<h4 id="export-与-import-的复合写法"><a href="#export-与-import-的复合写法" class="headerlink" title="export 与 import 的复合写法"></a>export 与 import 的复合写法</h4><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">export &#123; foo, bar &#125; from &apos;my_module&apos;;</div><div class="line"></div><div class="line">// 等同于</div><div class="line">import &#123; foo, bar &#125; from &apos;my_module&apos;;</div><div class="line">export &#123; foo, bar &#125;;</div></pre></td></tr></table></figure>
<h4 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h4><p>本书介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// constants.js 模块</div><div class="line">export const A = 1;</div><div class="line">export const B = 3;</div><div class="line">export const C = 4;</div><div class="line"></div><div class="line">// test1.js 模块</div><div class="line">import * as constants from &apos;./constants&apos;;</div><div class="line">console.log(constants.A); // 1</div><div class="line">console.log(constants.B); // 3</div><div class="line"></div><div class="line">// test2.js 模块</div><div class="line">import &#123;A, B&#125; from &apos;./constants&apos;;</div><div class="line">console.log(A); // 1</div><div class="line">console.log(B); // 3</div></pre></td></tr></table></figure>
<h4 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h4><p>前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">if (x === 2) &#123;</div><div class="line">  import MyModual from &apos;./myModual&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。从语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p>
<p>因此，有一个提案，建议引入<code>import()</code>函数，完成动态加载。</p>
<p><code>import()</code>返回一个 Promise 对象。</p>
<h3 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h3><h4 id="块级作用域-1"><a href="#块级作用域-1" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>（1）let 取代 var</p>
<p>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">const a = &quot;foobar&quot;;</div><div class="line">const b = &apos;foo&apos; + a + &apos;bar&apos;;</div><div class="line"></div><div class="line">// acceptable</div><div class="line">const c = `foobar`;</div><div class="line"></div><div class="line">// good</div><div class="line">const a = &apos;foobar&apos;;</div><div class="line">const b = `foo$&#123;a&#125;bar`;</div><div class="line">const c = &apos;foobar&apos;;</div></pre></td></tr></table></figure>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>使用数组成员对变量赋值时，优先使用解构赋值。</p>
<p>函数的参数如果是对象的成员，优先使用解构赋值。</p>
<p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p>
<p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</p>
<h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><p>使用扩展运算符（<code>...</code>）拷贝数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">const len = items.length;</div><div class="line">const itemsCopy = [];</div><div class="line">let i;</div><div class="line"></div><div class="line">for (i = 0; i &lt; len; i++) &#123;</div><div class="line">  itemsCopy[i] = items[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// good</div><div class="line">const itemsCopy = [...items];</div></pre></td></tr></table></figure>
<p>使用<code>Array.from</code>方法，将类似数组的对象转为数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const foo = document.querySelectorAll(&apos;.foo&apos;);</div><div class="line">const nodes = Array.from(foo);</div></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>立即执行函数可以写成箭头函数的形式。</p>
<p>那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。</p>
<p>箭头函数取代<code>Function.prototype.bind</code>，不应再用<code>self/_this/that</code>绑定 <code>this</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// bad</div><div class="line">const self = this;</div><div class="line">const boundMethod = function(...params) &#123;</div><div class="line">  return method.apply(self, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// acceptable</div><div class="line">const boundMethod = method.bind(this);</div><div class="line"></div><div class="line">// best</div><div class="line">const boundMethod = (...params) =&gt; method.apply(this, params);</div></pre></td></tr></table></figure>
<p>不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。</p>
<h4 id="Class-1"><a href="#Class-1" class="headerlink" title="Class"></a>Class</h4><p>总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。</p>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用<code>import</code>取代<code>require</code>。</p>
<p>使用<code>export</code>取代<code>module.exports</code>。</p>
<h3 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h3><p>SIMD 通常用于矢量运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = [1, 2, 3, 4];</div><div class="line">var b = [5, 6, 7, 8];</div><div class="line">var c = [];</div><div class="line"></div><div class="line">c[0] = a[0] + b[0];</div><div class="line">c[1] = a[1] + b[1];</div><div class="line">c[2] = a[2] + b[2];</div><div class="line">c[3] = a[3] + b[3];</div><div class="line">c // Array[6, 8, 10, 12]</div></pre></td></tr></table></figure>
<p>如果采用 SIMD 模式，只要运算一次就够了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = SIMD.Float32x4(1, 2, 3, 4);</div><div class="line">var b = SIMD.Float32x4(5, 6, 7, 8);</div><div class="line">var c = SIMD.Float32x4.add(a, b); // Float32x4[6, 8, 10, 12]</div></pre></td></tr></table></figure>
<h2 id="ES6-转码"><a href="#ES6-转码" class="headerlink" title="ES6 转码"></a>ES6 转码</h2><h3 id="Babel转码器"><a href="#Babel转码器" class="headerlink" title="Babel转码器"></a>Babel转码器</h3><p><a href="https://babeljs.io" target="_blank" rel="external">Babel</a> 是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 转码前</div><div class="line">input.map(item =&gt; item + 1);</div><div class="line"></div><div class="line">// 转码后</div><div class="line">input.map(function (item) &#123;</div><div class="line">  return item + 1;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的原始代码用了箭头函数，这个特性还没有得到广泛支持，Babel将其转为普通函数，就能在现有的JavaScript环境执行了。</p>
<h3 id="配置文件-babelrc"><a href="#配置文件-babelrc" class="headerlink" title="配置文件.babelrc"></a>配置文件.babelrc</h3><p>Babel的配置文件是<code>.babelrc</code>，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。</p>
<p>该文件用来设置转码规则和插件，基本格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [],</div><div class="line">  &quot;plugins&quot;: []</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>presets</code>字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># ES2015转码规则</div><div class="line">$ npm install --save-dev babel-preset-es2015</div><div class="line"></div><div class="line"># react转码规则</div><div class="line">$ npm install --save-dev babel-preset-react</div><div class="line"></div><div class="line"># ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个</div><div class="line">$ npm install --save-dev babel-preset-stage-0</div><div class="line">$ npm install --save-dev babel-preset-stage-1</div><div class="line">$ npm install --save-dev babel-preset-stage-2</div><div class="line">$ npm install --save-dev babel-preset-stage-3</div></pre></td></tr></table></figure>
<p>然后，将这些规则加入<code>.babelrc</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;presets&quot;: [</div><div class="line">      &quot;es2015&quot;,</div><div class="line">      &quot;react&quot;,</div><div class="line">      &quot;stage-2&quot;</div><div class="line">    ],</div><div class="line">    &quot;plugins&quot;: []</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>注意，以下所有Babel工具和模块的使用，都必须先写好<code>.babelrc</code>。</p>
<h3 id="命令行转码babel-cli"><a href="#命令行转码babel-cli" class="headerlink" title="命令行转码babel-cli"></a>命令行转码babel-cli</h3><p>Babel提供<code>babel-cli</code>工具，用于命令行转码。</p>
<p>它的安装命令如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --global babel-cli</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 转码结果输出到标准输出</div><div class="line">$ babel example.js</div><div class="line"></div><div class="line"># 转码结果写入一个文件</div><div class="line"># --out-file 或 -o 参数指定输出文件</div><div class="line">$ babel example.js --out-file compiled.js</div><div class="line"># 或者</div><div class="line">$ babel example.js -o compiled.js</div><div class="line"></div><div class="line"># 整个目录转码</div><div class="line"># --out-dir 或 -d 参数指定输出目录</div><div class="line">$ babel src --out-dir lib</div><div class="line"># 或者</div><div class="line">$ babel src -d lib</div><div class="line"></div><div class="line"># -s 参数生成source map文件</div><div class="line">$ babel src -d lib -s</div></pre></td></tr></table></figure>
<p>上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的Babel。</p>
<p>一个解决办法是将<code>babel-cli</code>安装在项目之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 安装</div><div class="line">$ npm install --save-dev babel-cli</div></pre></td></tr></table></figure>
<p>然后，改写<code>package.json</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  // ...</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;babel-cli&quot;: &quot;^6.0.0&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;build&quot;: &quot;babel src -d lib&quot;</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>转码的时候，就执行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run build</div></pre></td></tr></table></figure>
<h3 id="babel-node"><a href="#babel-node" class="headerlink" title="babel-node"></a>babel-node</h3><p><code>babel-cli</code>工具自带一个<code>babel-node</code>命令，提供一个支持ES6的REPL环境。它支持Node的REPL环境的所有功能，而且可以直接运行ES6代码。</p>
<p>它不用单独安装，而是随<code>babel-cli</code>一起安装。然后，执行babel-node`就进入REPL环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ babel-node</div><div class="line">&gt; (x =&gt; x * 2)(1)</div><div class="line">2</div></pre></td></tr></table></figure>
<p><code>babel-node</code>命令可以直接运行ES6脚本。将上面的代码放入脚本文件es6.js，然后直接运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ babel-node es6.js</div><div class="line">2</div></pre></td></tr></table></figure>
<p><code>babel-node</code>也可以安装在项目中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev babel-cli</div></pre></td></tr></table></figure>
<p>然后，改写<code>package.json</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;script-name&quot;: &quot;babel-node script.js&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，使用<code>babel-node</code>替代<code>node</code>，这样<code>script.js</code>本身就不用做任何转码处理。</p>
<h3 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h3><p>如果某些代码(Webpack 代码)需要调用Babel的API进行转码，就要使用<code>babel-core</code>模块。</p>
<p>安装命令如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install babel-core --save</div></pre></td></tr></table></figure>
<p>然后，在项目中就可以调用babel-core。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var babel = require(&apos;babel-core&apos;);</div><div class="line"></div><div class="line">// 字符串转码</div><div class="line">babel.transform(&apos;code();&apos;, options);</div><div class="line">// =&gt; &#123; code, map, ast &#125;</div><div class="line"></div><div class="line">// 文件转码（异步）</div><div class="line">babel.transformFile(&apos;filename.js&apos;, options, function(err, result) &#123;</div><div class="line">  result; // =&gt; &#123; code, map, ast &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 文件转码（同步）</div><div class="line">babel.transformFileSync(&apos;filename.js&apos;, options);</div><div class="line">// =&gt; &#123; code, map, ast &#125;</div><div class="line"></div><div class="line">// Babel AST转码</div><div class="line">babel.transformFromAst(ast, code, options);</div><div class="line">// =&gt; &#123; code, map, ast &#125;</div></pre></td></tr></table></figure>
<p>配置对象<code>options</code>，可以参看官方文档<a href="http://babeljs.io/docs/usage/options/。" target="_blank" rel="external">http://babeljs.io/docs/usage/options/。</a></p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var es6Code = &apos;let x = n =&gt; n + 1&apos;;</div><div class="line">var es5Code = require(&apos;babel-core&apos;)</div><div class="line">  .transform(es6Code, &#123;</div><div class="line">    presets: [&apos;es2015&apos;]</div><div class="line">  &#125;)</div><div class="line">  .code;</div><div class="line">// &apos;&quot;use strict&quot;;\n\nvar x = function x(n) &#123;\n  return n + 1;\n&#125;;&apos;</div></pre></td></tr></table></figure>
<p>上面代码中，<code>transform</code>方法的第一个参数是一个字符串，表示需要被转换的ES6代码，第二个参数是转换的配置对象。</p>
<h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h3><p>Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code>）都不会转码。</p>
<p>举例来说，ES6在<code>Array</code>对象上新增了<code>Array.from</code>方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用<code>babel-polyfill</code>，为当前环境提供一个垫片。</p>
<p>安装命令如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save babel-polyfill</div></pre></td></tr></table></figure>
<p>然后，在脚本头部，加入如下一行代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import &apos;babel-polyfill&apos;;</div><div class="line">// 或者</div><div class="line">require(&apos;babel-polyfill&apos;);</div></pre></td></tr></table></figure>
<p>Babel默认不转码的API非常多，详细清单可以查看babel-plugin-transform-runtime模块的<a href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/definitions.js" target="_blank" rel="external">definitions.js</a>文件。</p>
<h3 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h3><p>Babel提供一个<a href="https://babeljs.io/repl/" target="_blank" rel="external">REPL在线编译器</a>，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ES6/" rel="tag"># ES6</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/08/LeetCode-String题集/" rel="next" title="LeetCode String题集">
                <i class="fa fa-chevron-left"></i> LeetCode String题集
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/11/CSS3-Flex-布局/" rel="prev" title="CSS3 Flex 布局">
                CSS3 Flex 布局 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/02/09/ES6入门/"
           data-title="ES6入门" data-url="https://shiningdan.github.io/2017/02/09/ES6入门/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg"
               alt="ShiningDan" />
          <p class="site-author-name" itemprop="name">ShiningDan</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">88</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">75</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ECMAScript-6简介"><span class="nav-number">1.</span> <span class="nav-text">ECMAScript 6简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ECMAScript和JavaScript的关系"><span class="nav-number">1.1.</span> <span class="nav-text">ECMAScript和JavaScript的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部署进度"><span class="nav-number">1.2.</span> <span class="nav-text">部署进度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-和-ES5-的对比"><span class="nav-number">2.</span> <span class="nav-text">ES6 和 ES5 的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#let-和-const"><span class="nav-number">2.1.</span> <span class="nav-text">let 和 const</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#let-命令"><span class="nav-number">2.1.1.</span> <span class="nav-text">let 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#块级作用域"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">块级作用域</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const命令"><span class="nav-number">2.1.2.</span> <span class="nav-text">const命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顶层对象的属性"><span class="nav-number">2.1.3.</span> <span class="nav-text">顶层对象的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#global-对象"><span class="nav-number">2.1.4.</span> <span class="nav-text">global 对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量的解构赋值"><span class="nav-number">2.2.</span> <span class="nav-text">变量的解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组的解构赋值"><span class="nav-number">2.2.1.</span> <span class="nav-text">数组的解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#默认值"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">默认值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的解构赋值"><span class="nav-number">2.2.2.</span> <span class="nav-text">对象的解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串的解构赋值"><span class="nav-number">2.2.3.</span> <span class="nav-text">字符串的解构赋值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值和布尔值的解构赋值"><span class="nav-number">2.3.</span> <span class="nav-text">数值和布尔值的解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数参数的解构赋值"><span class="nav-number">2.3.1.</span> <span class="nav-text">函数参数的解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用途"><span class="nav-number">2.3.2.</span> <span class="nav-text">用途</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#交换变量的值"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">交换变量的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从函数返回多个值"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">从函数返回多个值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数参数的定义"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">函数参数的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#提取JSON数据"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">提取JSON数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数参数的默认值"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">函数参数的默认值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历Map结构"><span class="nav-number">2.3.2.6.</span> <span class="nav-text">遍历Map结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输入模块的指定方法"><span class="nav-number">2.3.2.7.</span> <span class="nav-text">输入模块的指定方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串的扩展"><span class="nav-number">2.4.</span> <span class="nav-text">字符串的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符的Unicode表示法"><span class="nav-number">2.4.1.</span> <span class="nav-text">字符的Unicode表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#codePointAt"><span class="nav-number">2.4.2.</span> <span class="nav-text">codePointAt()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-fromCodePoint"><span class="nav-number">2.4.3.</span> <span class="nav-text">String.fromCodePoint()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串的遍历器接口"><span class="nav-number">2.4.4.</span> <span class="nav-text">字符串的遍历器接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#includes-startsWith-endsWith"><span class="nav-number">2.4.5.</span> <span class="nav-text">includes(), startsWith(), endsWith()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#repeat"><span class="nav-number">2.4.6.</span> <span class="nav-text">repeat()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#padStart-，padEnd"><span class="nav-number">2.4.7.</span> <span class="nav-text">padStart()，padEnd()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板字符串"><span class="nav-number">2.4.8.</span> <span class="nav-text">模板字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则的扩展"><span class="nav-number">2.5.</span> <span class="nav-text">正则的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RegExp构造函数"><span class="nav-number">2.5.1.</span> <span class="nav-text">RegExp构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串的正则方法"><span class="nav-number">2.5.2.</span> <span class="nav-text">字符串的正则方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u修饰符"><span class="nav-number">2.5.3.</span> <span class="nav-text">u修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#y-修饰符"><span class="nav-number">2.5.4.</span> <span class="nav-text">y 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flags属性"><span class="nav-number">2.5.5.</span> <span class="nav-text">flags属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RegExp-escape"><span class="nav-number">2.5.6.</span> <span class="nav-text">RegExp.escape()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#s-修饰符：dotAll-模式"><span class="nav-number">2.5.7.</span> <span class="nav-text">s 修饰符：dotAll 模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值的扩展"><span class="nav-number">2.6.</span> <span class="nav-text">数值的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二进制和八进制表示法"><span class="nav-number">2.6.1.</span> <span class="nav-text">二进制和八进制表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-isFinite-Number-isNaN"><span class="nav-number">2.6.2.</span> <span class="nav-text">Number.isFinite(), Number.isNaN()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-parseInt-Number-parseFloat"><span class="nav-number">2.6.3.</span> <span class="nav-text">Number.parseInt(), Number.parseFloat()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-isInteger"><span class="nav-number">2.6.4.</span> <span class="nav-text">Number.isInteger()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-EPSILON"><span class="nav-number">2.6.5.</span> <span class="nav-text">Number.EPSILON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安全整数和Number-isSafeInteger"><span class="nav-number">2.6.6.</span> <span class="nav-text">安全整数和Number.isSafeInteger()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math对象的扩展"><span class="nav-number">2.7.</span> <span class="nav-text">Math对象的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-trunc"><span class="nav-number">2.7.1.</span> <span class="nav-text">Math.trunc()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-sign"><span class="nav-number">2.7.2.</span> <span class="nav-text">Math.sign()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-cbrt"><span class="nav-number">2.7.3.</span> <span class="nav-text">Math.cbrt()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-clz32"><span class="nav-number">2.7.4.</span> <span class="nav-text">Math.clz32()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-imul"><span class="nav-number">2.7.5.</span> <span class="nav-text">Math.imul()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-signbit"><span class="nav-number">2.7.6.</span> <span class="nav-text">Math.signbit()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的扩展"><span class="nav-number">2.8.</span> <span class="nav-text">数组的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-from"><span class="nav-number">2.8.1.</span> <span class="nav-text">Array.from()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-of"><span class="nav-number">2.8.2.</span> <span class="nav-text">Array.of()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组实例的copyWithin"><span class="nav-number">2.8.3.</span> <span class="nav-text">数组实例的copyWithin()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组实例的find-和findIndex"><span class="nav-number">2.8.4.</span> <span class="nav-text">数组实例的find()和findIndex()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组实例的entries-，keys-和values"><span class="nav-number">2.8.5.</span> <span class="nav-text">数组实例的entries()，keys()和values()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的扩展"><span class="nav-number">2.9.</span> <span class="nav-text">函数的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数参数的默认值-1"><span class="nav-number">2.9.1.</span> <span class="nav-text">函数参数的默认值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数的-length-属性"><span class="nav-number">2.9.2.</span> <span class="nav-text">函数的 length 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rest参数"><span class="nav-number">2.9.3.</span> <span class="nav-text">rest参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩展运算符"><span class="nav-number">2.9.4.</span> <span class="nav-text">扩展运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#扩展运算符的应用"><span class="nav-number">2.9.4.1.</span> <span class="nav-text">扩展运算符的应用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现了Iterator接口的对象"><span class="nav-number">2.9.5.</span> <span class="nav-text">实现了Iterator接口的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#箭头函数"><span class="nav-number">2.9.6.</span> <span class="nav-text">箭头函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绑定-this"><span class="nav-number">2.9.7.</span> <span class="nav-text">绑定 this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#尾调用优化"><span class="nav-number">2.9.8.</span> <span class="nav-text">尾调用优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是尾调用？"><span class="nav-number">2.9.8.1.</span> <span class="nav-text">什么是尾调用？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#尾调用优化-1"><span class="nav-number">2.9.8.2.</span> <span class="nav-text">尾调用优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#尾递归"><span class="nav-number">2.9.8.3.</span> <span class="nav-text">尾递归</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的扩展"><span class="nav-number">2.10.</span> <span class="nav-text">对象的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性的简洁表示法"><span class="nav-number">2.10.1.</span> <span class="nav-text">属性的简洁表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性名表达式"><span class="nav-number">2.10.2.</span> <span class="nav-text">属性名表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-is"><span class="nav-number">2.10.3.</span> <span class="nav-text">Object.is()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-assign"><span class="nav-number">2.10.4.</span> <span class="nav-text">Object.assign()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性的遍历"><span class="nav-number">2.10.5.</span> <span class="nav-text">属性的遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><span class="nav-number">2.10.6.</span> <span class="nav-text">__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-keys-，Object-values-，Object-entries"><span class="nav-number">2.10.7.</span> <span class="nav-text">Object.keys()，Object.values()，Object.entries()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-getOwnPropertyDescriptors"><span class="nav-number">2.10.8.</span> <span class="nav-text">Object.getOwnPropertyDescriptors()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol"><span class="nav-number">2.11.</span> <span class="nav-text">Symbol</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#作为属性名的Symbol"><span class="nav-number">2.11.1.</span> <span class="nav-text">作为属性名的Symbol</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性名的遍历"><span class="nav-number">2.11.2.</span> <span class="nav-text">属性名的遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Symbol-for-，Symbol-keyFor"><span class="nav-number">2.11.3.</span> <span class="nav-text">Symbol.for()，Symbol.keyFor()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#模块的-Singleton-模式"><span class="nav-number">2.11.3.1.</span> <span class="nav-text">模块的 Singleton 模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set和Map数据结构"><span class="nav-number">2.12.</span> <span class="nav-text">Set和Map数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Set"><span class="nav-number">2.12.1.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WeakSet"><span class="nav-number">2.12.2.</span> <span class="nav-text">WeakSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map"><span class="nav-number">2.12.3.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Map转为数组"><span class="nav-number">2.12.3.1.</span> <span class="nav-text">Map转为数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WeakMap"><span class="nav-number">2.12.4.</span> <span class="nav-text">WeakMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy"><span class="nav-number">2.13.</span> <span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect"><span class="nav-number">2.14.</span> <span class="nav-text">Reflect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-对象"><span class="nav-number">2.15.</span> <span class="nav-text">Promise 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本用法"><span class="nav-number">2.15.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-prototype-then"><span class="nav-number">2.15.2.</span> <span class="nav-text">Promise.prototype.then()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-prototype-catch"><span class="nav-number">2.15.3.</span> <span class="nav-text">Promise.prototype.catch()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-all"><span class="nav-number">2.15.4.</span> <span class="nav-text">Promise.all()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-race"><span class="nav-number">2.16.</span> <span class="nav-text">Promise.race()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-resolve"><span class="nav-number">2.16.1.</span> <span class="nav-text">Promise.resolve()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#done"><span class="nav-number">2.16.2.</span> <span class="nav-text">done()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finally"><span class="nav-number">2.16.3.</span> <span class="nav-text">finally()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator和for…of循环"><span class="nav-number">2.17.</span> <span class="nav-text">Iterator和for…of循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator（遍历器）的概念"><span class="nav-number">2.17.1.</span> <span class="nav-text">Iterator（遍历器）的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构的默认Iterator接口"><span class="nav-number">2.17.2.</span> <span class="nav-text">数据结构的默认Iterator接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数组"><span class="nav-number">2.17.2.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Set和Map结构"><span class="nav-number">2.17.2.2.</span> <span class="nav-text">Set和Map结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generator-函数的语法"><span class="nav-number">2.18.</span> <span class="nav-text">Generator 函数的语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#与Iterator接口的关系"><span class="nav-number">2.18.1.</span> <span class="nav-text">与Iterator接口的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator-prototype-return"><span class="nav-number">2.18.2.</span> <span class="nav-text">Generator.prototype.return()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#yield-语句"><span class="nav-number">2.18.3.</span> <span class="nav-text">yield* 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用"><span class="nav-number">2.18.4.</span> <span class="nav-text">应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#异步操作的同步化表达"><span class="nav-number">2.18.4.1.</span> <span class="nav-text">异步操作的同步化表达</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#控制流管理"><span class="nav-number">2.18.4.2.</span> <span class="nav-text">控制流管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#部署Iterator接口"><span class="nav-number">2.18.4.3.</span> <span class="nav-text">部署Iterator接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generator-函数的异步应用"><span class="nav-number">2.19.</span> <span class="nav-text">Generator 函数的异步应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本概念"><span class="nav-number">2.19.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#异步"><span class="nav-number">2.19.1.1.</span> <span class="nav-text">异步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#回调函数"><span class="nav-number">2.19.1.2.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise"><span class="nav-number">2.19.1.3.</span> <span class="nav-text">Promise</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generator-函数"><span class="nav-number">2.19.2.</span> <span class="nav-text">Generator 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#协程"><span class="nav-number">2.19.2.1.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#协程的-Generator-函数实现"><span class="nav-number">2.19.2.2.</span> <span class="nav-text">协程的 Generator 函数实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thunk-函数的自动流程管理"><span class="nav-number">2.19.3.</span> <span class="nav-text">Thunk 函数的自动流程管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#co-模块"><span class="nav-number">2.19.4.</span> <span class="nav-text">co 模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async-函数"><span class="nav-number">2.20.</span> <span class="nav-text">async 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#含义"><span class="nav-number">2.20.1.</span> <span class="nav-text">含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-对象的状态变"><span class="nav-number">2.20.2.</span> <span class="nav-text">Promise 对象的状态变</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class"><span class="nav-number">2.21.</span> <span class="nav-text">Class</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类的实例对象"><span class="nav-number">2.21.1.</span> <span class="nav-text">类的实例对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#私有方法"><span class="nav-number">2.21.2.</span> <span class="nav-text">私有方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this的指向"><span class="nav-number">2.21.3.</span> <span class="nav-text">this的指向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class的继承"><span class="nav-number">2.21.4.</span> <span class="nav-text">Class的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的prototype属性和proto属性"><span class="nav-number">2.21.5.</span> <span class="nav-text">类的prototype属性和proto属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Extends-的继承目标"><span class="nav-number">2.21.6.</span> <span class="nav-text">Extends 的继承目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super-关键字"><span class="nav-number">2.21.7.</span> <span class="nav-text">super 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例的proto属性"><span class="nav-number">2.21.8.</span> <span class="nav-text">实例的proto属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原生构造函数的继承"><span class="nav-number">2.21.9.</span> <span class="nav-text">原生构造函数的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class的取值函数（getter）和存值函数（setter）"><span class="nav-number">2.21.10.</span> <span class="nav-text">Class的取值函数（getter）和存值函数（setter）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-的静态方法"><span class="nav-number">2.21.11.</span> <span class="nav-text">Class 的静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class的静态属性和实例属性"><span class="nav-number">2.21.12.</span> <span class="nav-text">Class的静态属性和实例属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new-target属性"><span class="nav-number">2.21.13.</span> <span class="nav-text">new.target属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mixin模式的实现"><span class="nav-number">2.21.14.</span> <span class="nav-text">Mixin模式的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修饰器-Decorator"><span class="nav-number">2.22.</span> <span class="nav-text">修饰器(Decorator)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类的修饰"><span class="nav-number">2.22.1.</span> <span class="nav-text">类的修饰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法的修饰"><span class="nav-number">2.22.2.</span> <span class="nav-text">方法的修饰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么修饰器不能用于函数？"><span class="nav-number">2.22.3.</span> <span class="nav-text">为什么修饰器不能用于函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#core-decorators-js"><span class="nav-number">2.22.4.</span> <span class="nav-text">core-decorators.js</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Module-的语法"><span class="nav-number">2.23.</span> <span class="nav-text">Module 的语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#export-命令"><span class="nav-number">2.23.1.</span> <span class="nav-text">export 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#import-命令"><span class="nav-number">2.23.2.</span> <span class="nav-text">import 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块的整体加载"><span class="nav-number">2.23.3.</span> <span class="nav-text">模块的整体加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#export-default-命令"><span class="nav-number">2.23.4.</span> <span class="nav-text">export default 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#export-与-import-的复合写法"><span class="nav-number">2.23.5.</span> <span class="nav-text">export 与 import 的复合写法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跨模块常量"><span class="nav-number">2.23.6.</span> <span class="nav-text">跨模块常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#import"><span class="nav-number">2.23.7.</span> <span class="nav-text">import()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编程风格"><span class="nav-number">2.24.</span> <span class="nav-text">编程风格</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#块级作用域-1"><span class="nav-number">2.24.1.</span> <span class="nav-text">块级作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">2.24.2.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解构赋值"><span class="nav-number">2.24.3.</span> <span class="nav-text">解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象"><span class="nav-number">2.24.4.</span> <span class="nav-text">对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组-1"><span class="nav-number">2.24.5.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数"><span class="nav-number">2.24.6.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-1"><span class="nav-number">2.24.7.</span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块"><span class="nav-number">2.24.8.</span> <span class="nav-text">模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SIMD"><span class="nav-number">2.25.</span> <span class="nav-text">SIMD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-转码"><span class="nav-number">3.</span> <span class="nav-text">ES6 转码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Babel转码器"><span class="nav-number">3.1.</span> <span class="nav-text">Babel转码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置文件-babelrc"><span class="nav-number">3.2.</span> <span class="nav-text">配置文件.babelrc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令行转码babel-cli"><span class="nav-number">3.3.</span> <span class="nav-text">命令行转码babel-cli</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#babel-node"><span class="nav-number">3.4.</span> <span class="nav-text">babel-node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#babel-core"><span class="nav-number">3.5.</span> <span class="nav-text">babel-core</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#babel-polyfill"><span class="nav-number">3.6.</span> <span class="nav-text">babel-polyfill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在线转换"><span class="nav-number">3.7.</span> <span class="nav-text">在线转换</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShiningDan</span>
</div>



        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"shiningdan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js?v=5.1.0"></script>
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("nr3cyUXVpbTxQQRcqfMp5cHa-gzGzoHsz", "B1SG80mnbseYxv4C0vAjig8s");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
