<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="algorithm,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0">






<meta name="description" content="本笔记是刷 《剑指 offer》 题集中题目的笔记记录。">
<meta name="keywords" content="algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer题集">
<meta property="og:url" content="https://shiningdan.github.io/2017/04/04/剑指offer题集/index.html">
<meta property="og:site_name" content="ShiningDan的博客">
<meta property="og:description" content="本笔记是刷 《剑指 offer》 题集中题目的笔记记录。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ojt6zsxg2.bkt.clouddn.com/db1a4a13ee3697ba144dae3c999c114c.png">
<meta property="og:updated_time" content="2017-06-17T15:01:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer题集">
<meta name="twitter:description" content="本笔记是刷 《剑指 offer》 题集中题目的笔记记录。">
<meta name="twitter:image" content="http://ojt6zsxg2.bkt.clouddn.com/db1a4a13ee3697ba144dae3c999c114c.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6345612185049236000',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://shiningdan.github.io/2017/04/04/剑指offer题集/">





  <title> 剑指offer题集 | ShiningDan的博客 </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?65f098889042a1740b5cfede967d34b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ShiningDan的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description"></h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-photography">
          <a href="/categories/photography" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            摄影
          </a>
        </li>
      
        
        <li class="menu-item menu-item-coding">
          <a href="/categories/coding" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            编程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://shiningdan.github.io/2017/04/04/剑指offer题集/">

  <span style="display:none" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <meta itemprop="name" content="ShiningDan">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="ShiningDan的博客">
    <span style="display:none" itemprop="logo" itemscope="" itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="ShiningDan的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                剑指offer题集
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-04T19:59:11+08:00">
                2017-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/coding/" itemprop="url" rel="index">
                    <span itemprop="name">coding</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/04/剑指offer题集/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/04/剑指offer题集/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2017/04/04/剑指offer题集/" class="leancloud_visitors" data-flag-title="剑指offer题集">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本笔记是刷 《剑指 offer》 题集中题目的笔记记录。</p>
<a id="more"></a>
<p>《剑指 offer》上的真题可以在 <a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">牛客网</a> 上找到。</p>
<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>该解法将数组考虑成一个矩阵，不过每次比较的时候，是从矩阵的右上角或者左下角开始比较。假设从左下角开始比较，则通过每一次比较的结果，如果 <code>target &gt; a[i][j]</code>，则比较上一节点；如果<code>target &lt; a[i][j]</code>，则比较右边的节点。</strong></p>
<p>还需要注意边界判断，如果给的数组是 <code>[[]]</code>，则很容易返回边界错误，此时如何解决？</p>
<p>解法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Find(target, array)</span><br><span class="line">&#123;</span><br><span class="line">    var len = array.length;</span><br><span class="line">  	var colLen = array[0].length;</span><br><span class="line">    if (array != null &amp;&amp; len &gt; 0 &amp;&amp; colLen &gt; 0) &#123;</span><br><span class="line">        var i = 0, j = colLen-1;</span><br><span class="line">        while(i &lt; len &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">            if (target === array[i][j]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (target &gt; array[i][j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    Find : Find</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>第一个方法是创建新的字符串，进行拼接，但是这样会使用多余的空间。<strong>前两种方法都是要使用额外的空间的，是否使用额外的空间要提前询问面试官</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function replaceSpace(str)</span><br><span class="line">&#123;</span><br><span class="line">    for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">        if (str[i] === &apos; &apos;) &#123;</span><br><span class="line">            var left = str.slice(0, i), right = str.slice(i+1, str.length);</span><br><span class="line">            str = left + &apos;%20&apos; + right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    replaceSpace : replaceSpace</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者直接使用 replace 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function replaceSpace(str)</span><br><span class="line">&#123;</span><br><span class="line">    return str.replace(/\s/g, &apos;%20&apos;);</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    replaceSpace : replaceSpace</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是如果<strong>不考虑使用额外的空间</strong>，在原来的字符串上进行修改，在替换的时候，就需要将原来的字符串进行后移，一个空格需要向后移动三位，然后分别填充 <code>%</code>、<code>2</code>、<code>0</code>。</p>
<p>假设字符串的长度是 n，则对每个空格字符，都需要移动后面 O(n) 个字符，时间效率为 O(n^2)</p>
<p>下面介绍使用 O(n) 时间复杂度的移动字符的方法：</p>
<p>首先遍历一遍字符串，统计有多少个空格，就知道要后移 2 倍空格的长度。当入到字符串的时候，就用 <code>%20</code> 进行添加，否则，只是复制该字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function replaceSpace(str)</span><br><span class="line">&#123;</span><br><span class="line">    var spaceNum = 0;</span><br><span class="line">    for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">        if (str[i] === &apos; &apos;)</span><br><span class="line">            ++spaceNum;</span><br><span class="line">    &#125;</span><br><span class="line">    var p = str.length - 1 + 2*spaceNum;</span><br><span class="line">    for (var i = str.length-1; i &gt;=0; i--) &#123;</span><br><span class="line">        if (str[i] === &apos; &apos;) &#123;</span><br><span class="line">            str[p--] = &apos;0&apos;;</span><br><span class="line">            str[p--] = &apos;2&apos;;</span><br><span class="line">            str[p--] = &apos;%&apos;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            str[p--] = str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    replaceSpace : replaceSpace</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="从头到尾打印链表"><a href="#从头到尾打印链表" class="headerlink" title="从头到尾打印链表"></a>从头到尾打印链表</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，从尾到头打印链表每个节点的值。</p>
<p>如果可以修改链表的指向，可以让后一项指向前一项。但是如果不能修改链表的指向，我们可以如下分析：</p>
<p><strong>遍历的第一个节点最后一个输出，遍历的最后一个节点第一个输出，也就是先入后出，可以使用栈来实现。不过使用栈需要额外的 O(n) 空间：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*function ListNode(x)&#123;</span><br><span class="line">    this.val = x;</span><br><span class="line">    this.next = null;</span><br><span class="line">&#125;*/</span><br><span class="line">function printListFromTailToHead(head)</span><br><span class="line">&#123;</span><br><span class="line">    var stack = [];</span><br><span class="line">    while (head) &#123;</span><br><span class="line">        stack.unshift(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    printListFromTailToHead : printListFromTailToHead</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果用栈来实现这个函数，而递归本身就是一个栈结构，可以使用递归，先输出自己的后一个节点，再输出自己：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*function ListNode(x)&#123;</span><br><span class="line">    this.val = x;</span><br><span class="line">    this.next = null;</span><br><span class="line">&#125;*/</span><br><span class="line">var result = [];</span><br><span class="line">function printListFromTailToHead(head)</span><br><span class="line">&#123;</span><br><span class="line">    if (head) &#123;</span><br><span class="line">        if (head.next) &#123;</span><br><span class="line">            printListFromTailToHead(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    printListFromTailToHead : printListFromTailToHead</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p><strong>通过前序遍历，第一个节点就是根节点，然后在中序遍历中，根节点前面的就是根节点的左子树，根节点右边的就是右子树。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function TreeNode(x) &#123;</span><br><span class="line">    this.val = x;</span><br><span class="line">    this.left = null;</span><br><span class="line">    this.right = null;</span><br><span class="line">&#125;</span><br><span class="line">function reConstructBinaryTree(pre, vin)</span><br><span class="line">&#123;</span><br><span class="line">    if (pre == null || pre.length === 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    var node = new TreeNode(pre[0]);</span><br><span class="line">    for (var index = 0; index &lt; pre.length; index++) &#123;</span><br><span class="line">        if (vin[index] === pre[0]) &#123;</span><br><span class="line">            node.left = reConstructBinaryTree(pre.slice(1, index+1), vin.slice(0, index));</span><br><span class="line">    		node.right = reConstructBinaryTree(pre.slice(index+1, pre.length), vin.slice(index+1, vin.length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    return node;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    reConstructBinaryTree : reConstructBinaryTree</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="使用两个栈实现队列"><a href="#使用两个栈实现队列" class="headerlink" title="使用两个栈实现队列"></a>使用两个栈实现队列</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。具体实现思路如下：当 stack2 为空的时候，再把 stack1 的内容全部放到 stack2 里面，从 stack1 入队，stack2 出队。</p>
<p><img src="http://ojt6zsxg2.bkt.clouddn.com/db1a4a13ee3697ba144dae3c999c114c.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var q1 = [];</span><br><span class="line">var q2 = [];</span><br><span class="line">function push(node)</span><br><span class="line">&#123;</span><br><span class="line">    q1.push(node);</span><br><span class="line">&#125;</span><br><span class="line">function pop()</span><br><span class="line">&#123;</span><br><span class="line">    if(q2.length === 0) &#123;</span><br><span class="line">        while(q1.length !== 0) &#123;</span><br><span class="line">            q2.push(q1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return q2.pop();</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    push : push,</span><br><span class="line">    pop : pop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>使用折半查找法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function minNumberInRotateArray(rotateArray)</span><br><span class="line">&#123;</span><br><span class="line">    var index1 = 0;</span><br><span class="line">    var index2 = rotateArray.length-1;</span><br><span class="line">    var indexMid = index1;</span><br><span class="line">    while (rotateArray[index1] &gt;= rotateArray[index2]) &#123;</span><br><span class="line">        if (index2 - index1 == 1 || index2 - index1 ==0) &#123;</span><br><span class="line">          indexMid = index2;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        indexMid = Math.floor((indeax1 + index2)/2);</span><br><span class="line">        if (rotateArray[indexMid] &gt;= rotateArray[index1]) &#123;</span><br><span class="line">            index1 = indexMid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index2 = indexMid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return rotateArray[indexMid];</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    minNumberInRotateArray : minNumberInRotateArray</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39</p>
<p>使用递归的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Fibonacci(n)</span><br><span class="line">&#123;</span><br><span class="line">    if (n === 0)</span><br><span class="line">        return 0;</span><br><span class="line">    if (n === 1)</span><br><span class="line">        return 1;</span><br><span class="line">    return Fibonacci(n-1) + Fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    Fibonacci : Fibonacci</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是使用递归的方法时，在求解的过程中，有很多结点重复计算，这使得计算量随着结点大大增加。</p>
<p>所以，我们可以将计算过程中涉及的中间值保存下来，可以通过 <code>f(0)</code> 和 <code>f(1)</code> 计算得到 <code>f(2)</code>，然后通过 <code>f(1)</code> 和<code>f(2)</code> 计算得到 <code>f(3)</code>，一直到<code>f(n)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Fibonacci(n)</span><br><span class="line">&#123;</span><br><span class="line">    var fibOne = 0, fibTwo = 1, num = 1;</span><br><span class="line">    if (n &lt;= 1)</span><br><span class="line">        return n;</span><br><span class="line">    var temp;</span><br><span class="line">    while(num &lt; n) &#123;</span><br><span class="line">        temp = fibOne + fibTwo;</span><br><span class="line">        fibOne = fibTwo;</span><br><span class="line">        fibTwo = temp;</span><br><span class="line">        ++num;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    Fibonacci : Fibonacci</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>其实这道题的思路和斐波那契数的思路很像。如果只有 1 个台阶，就只有 1 种跳法。如果只有 2 个台阶。就有两种跳法，一个是分两次，另一个是一次跳两个。</p>
<p>如果有 <code>n</code> 个台阶，就有 <code>jumpFloor(n)</code> 种跳法，其中，<code>jumpFloor(n)</code> 的数等于 <code>jumpFloor(n-1) + jumpFloor(n-2)</code></p>
<p>所以这个问题和斐波那契数是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function jumpFloor(number)</span><br><span class="line">&#123;	</span><br><span class="line">    if (number === 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else if (number === 2) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var jNum1 = 1, jNum2 = 2, tmp;</span><br><span class="line">        while(number &gt; 2) &#123;</span><br><span class="line">            tmp = jNum2;</span><br><span class="line">            jNum2 = jNum2 + jNum1;</span><br><span class="line">            jNum1 = tmp;</span><br><span class="line">            --number;</span><br><span class="line">        &#125;</span><br><span class="line">        return jNum2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>这里具体的分析思路可以参考 <a href="https://www.nowcoder.com/questionTerminal/22243d016f6b47f2a6928b4313c85387" target="_blank" rel="noopener">第一个回答</a>，大致含义就是用数学归纳法证明 <code>f(n) = Math.pow(2, n-1)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function jumpFloorII(number)</span><br><span class="line">&#123;</span><br><span class="line">    return Math.pow(2, number-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们可以用 <code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个 <code>2*1</code>的小矩形无重叠地覆盖一个 <code>2*n</code> 的大矩形，总共有多少种方法？</p>
<p>其实这也是一个斐波那契数的问题，<code>f(n) = f(n-1) + f(n-2)</code>。</p>
<p><strong>像这种动态规划的问题，其实求解的方法都类似于数学归纳法，找到 <code>f(n)</code> 和之前状态的直接关系，然后构造公式，并且提供初始值。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function rectCover(number)</span><br><span class="line">&#123;</span><br><span class="line">    if (number === 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if (number === 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else if (number === 2) &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var rNum1 = 1, rNum2 = 2, tmp;</span><br><span class="line">        while(number &gt; 2) &#123;</span><br><span class="line">            tmp = rNum2;</span><br><span class="line">            rNum2 = rNum1 + rNum2;</span><br><span class="line">            rNum1 = tmp;</span><br><span class="line">            --number;</span><br><span class="line">        &#125;</span><br><span class="line">        return rNum2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制中-1-的个数"><a href="#二进制中-1-的个数" class="headerlink" title="二进制中 1 的个数"></a>二进制中 1 的个数</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function NumberOf1(n)</span><br><span class="line">&#123;</span><br><span class="line">    var count = 0;</span><br><span class="line">    while(n) &#123;</span><br><span class="line">        ++ count;</span><br><span class="line">        n = n &amp; (n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解答详解可以参见 [详解]（<a href="https://www.nowcoder.com/profile/1498510/codeBookDetail?submissionId=8851153）这里我要谈的是" target="_blank" rel="noopener">https://www.nowcoder.com/profile/1498510/codeBookDetail?submissionId=8851153）这里我要谈的是</a> JS 中的数值的二进制表达。</p>
<p>默认在 JS 中，数值是用 64 位的浮点型二进制进行存储的，但是只要对 JS 中的任何数字做位运算操作系统内部都会将其转换成 32 位的整型。</p>
<p>在计算机中，正整数存储的是正常的二进制真值，负数存储的是二进制补码（真值码取反加一后加上符号位）。所以计算负数二进制中 1 的个数的时候，得到的是正整数补码中 1 的位数。并且在进行位运算的时候，负数使用的是补码。</p>
<h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p><strong>在这道题中，我们可能还需要考虑指数是 0 或者负数的情况！</strong></p>
<p>所以，第一次的解法如此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Power(base, exponent)</span><br><span class="line">&#123;</span><br><span class="line">    if (exponent &lt; 0) &#123;</span><br><span class="line">        if (base === 0) &#123;</span><br><span class="line">            throw new Error(&apos;the deno should not be 0&apos;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var absexponent = -exponent, result = 1;</span><br><span class="line">            for (var i = 0; i &lt; absexponent; i++) &#123;</span><br><span class="line">                result *= base;</span><br><span class="line">            &#125;</span><br><span class="line">			result = 1/result;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (exponent === 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var result = 1;</span><br><span class="line">        for (var i = 0; i &lt; exponent; i++) &#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，使用这种解法的问题就在于，如果 <code>exponent</code> 的值为 <code>32</code>，我们就需要计算 32 次，其实 32 次方就等于 16 的平方的平方，这个问题就变成了之前的斐波拉契数列的问题，我们可以由此来减少计算的步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function PowerPosExp(base, exponent) &#123;</span><br><span class="line">    var result = base;</span><br><span class="line">    while(exponent &gt; 1) &#123;</span><br><span class="line">        if (exponent &amp; 0x01 === 1) &#123;</span><br><span class="line">            result = result * result * base;</span><br><span class="line">            exponent = (exponent - 1) / 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = result * result;</span><br><span class="line">            exponent = exponent / 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">function Power(base, exponent)</span><br><span class="line">&#123;</span><br><span class="line">    if (exponent &lt; 0) &#123;</span><br><span class="line">        if (base === 0) &#123;</span><br><span class="line">            throw new Error(&apos;the deno should not be 0&apos;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var result = PowerPosExp(base, -exponent);</span><br><span class="line">						result = 1/result;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (exponent === 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var result = PowerPosExp(base, exponent);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 1.要想保证原有次序，则只能顺次移动或相邻交换。</span><br><span class="line"> * 2.i从左向右遍历，找到第一个偶数。</span><br><span class="line"> * 3.j从i+1开始向后找，直到找到第一个奇数。</span><br><span class="line"> * 4.将[i,...,j-1]的元素整体后移一位，最后将找到的奇数放入i位置，然后i++。</span><br><span class="line"> * 5.终止条件：j向后遍历查找失敗。</span><br><span class="line"> */</span><br><span class="line">function reOrderArray(array)</span><br><span class="line">&#123;</span><br><span class="line">    for (var i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">        if (array[i]%2 == 1) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        var j = i + 1;</span><br><span class="line">        while(j &lt; array.length) &#123;</span><br><span class="line">            if (array[j]%2 == 1) &#123;</span><br><span class="line">            	while(j &gt; i) &#123;</span><br><span class="line">                    var tmp = array[j];</span><br><span class="line">                    array[j] = array[j - 1];</span><br><span class="line">                    array[j - 1] = tmp;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;  </span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [1, 2, 3, 4, 5, 6, 6, 7];</span><br><span class="line">console.log(reOrderArray(a));</span><br></pre></td></tr></table></figure>
<h2 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p>为了实现一次遍历就找到倒数第 k 个节点，我们可以定义两个指针，他们之间的节点数相差 <code>k - 1</code>。</p>
<p>然后，这道题考虑的是鲁棒性，所以，我们要考虑</p>
<ol>
<li>如果头指针为空</li>
<li>如果链表数少于 k</li>
<li>如果输入的 <code>k</code> 为 <code>0</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function FindKthToTail(head, k)</span><br><span class="line">&#123;</span><br><span class="line">    if (head === null || k &lt;= 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    var pA = head, pB = null;</span><br><span class="line">    for (var i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">        if (pA.next === null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        pA = pA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pB = head;</span><br><span class="line">    while(pA.next !== null) &#123;</span><br><span class="line">        pA = pA.next;</span><br><span class="line">        pB = pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，反转链表后，输出链表的所有元素。</p>
<p>这道题需要考虑，链表头为 <code>null</code>，链表只有一个节点和多个节点的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function ReverseList(pHead)</span><br><span class="line">&#123;</span><br><span class="line">    if (pHead) &#123;</span><br><span class="line">        if (pHead.next === null) &#123;</span><br><span class="line">            return pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        var pNext = pHead.next,</span><br><span class="line">            p = pHead,</span><br><span class="line">            pPrev = null;</span><br><span class="line">        p.next = pPrev;</span><br><span class="line">        while(pNext.next !== null) &#123;</span><br><span class="line">            pPrev = p;</span><br><span class="line">            p = pNext;</span><br><span class="line">            pNext = pNext.next;</span><br><span class="line">            p.next = pPrev;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext.next = p;</span><br><span class="line">        return pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>我们需要考虑的是如果给的链表是 <code>null</code>，该如何处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Merge(pHead1, pHead2)</span><br><span class="line">&#123;</span><br><span class="line">    if (pHead1 === null) &#123;</span><br><span class="line">        return pHead2;</span><br><span class="line">    &#125; else if (pHead2 === null) &#123;</span><br><span class="line">        return pHead1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (pHead1.val &lt;= pHead2.val) &#123;</span><br><span class="line">            pHead1.next = Merge(pHead1.next, pHead2);</span><br><span class="line">            return pHead1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pHead2.next = Merge(pHead1, pHead2.next);</span><br><span class="line">            return pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p><strong>在解决链表，树等类型的题，一定要注意判断输入是否为 null</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function HasSubtree(pRoot1, pRoot2)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRoot1 === null || pRoot2 === null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isSubtree(pRoot1, pRoot2) || HasSubtree(pRoot1.left, pRoot2) || HasSubtree(pRoot1.right, pRoot2);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">function isSubtree(pRoot1, pRoot2) &#123;</span><br><span class="line">    if (pRoot2 === null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pRoot1 === null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pRoot1.val === pRoot2.val) &#123;</span><br><span class="line">        return isSubtree(pRoot1.left, pRoot2.left) &amp;&amp; isSubtree(pRoot1.right, pRoot2.right);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>输入描述:<br>二叉树的镜像定义：源二叉树 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  6   10</span><br><span class="line"> / \  / \</span><br><span class="line">5  7 9 11</span><br><span class="line">镜像二叉树</span><br><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  10   6</span><br><span class="line"> / \  / \</span><br><span class="line">11 9 7  5</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Mirror(root)</span><br><span class="line">&#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    var tmp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = tmp;</span><br><span class="line">    root.left = Mirror(root.left);</span><br><span class="line">    root.right = Mirror(root.right);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function printMatrix(matrix)</span><br><span class="line">&#123;</span><br><span class="line">    if (matrix === null || matrix.length === 0) &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    var row = matrix.length, col = matrix[0].length;</span><br><span class="line">		if (col === undefined) &#123;</span><br><span class="line">        return matrix;</span><br><span class="line">    &#125;</span><br><span class="line">    var result = [], start = 0;</span><br><span class="line">    while(row &gt; 2 * start &amp;&amp; col &gt; 2 * start)&#123;</span><br><span class="line">				var endx = col - start;</span><br><span class="line">				var endy = row - start;</span><br><span class="line">				for (var i = start; i &lt; endx; i++) &#123;</span><br><span class="line">						result.push(matrix[start][i])</span><br><span class="line">				&#125;</span><br><span class="line">				if(start&lt;endy-1)&#123;</span><br><span class="line">						for (var j= (start + 1); j &lt; endy; j++) &#123;</span><br><span class="line">						result.push(matrix[j][endx-1]);</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if(start&lt;(endx-1)&amp;&amp;start&lt;(endy-1))&#123;</span><br><span class="line">						for (var  m = endx-2; m &gt;= start; m--) &#123;</span><br><span class="line">								result.push(matrix[endy-1][m])</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if(start&lt;(endx-1)&amp;&amp;start&lt;endy)&#123;</span><br><span class="line">						for (var n = endy - 2; n &gt;= start+1; n--) &#123;</span><br><span class="line">								result.push(matrix[n][start])</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				start++</span><br><span class="line">		&#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包含-min-函数的栈"><a href="#包含-min-函数的栈" class="headerlink" title="包含 min 函数的栈"></a>包含 min 函数的栈</h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。在该栈中，调用 min、push、pop 的时间复杂度为 O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var d_data = [];</span><br><span class="line">var m_data = [];</span><br><span class="line">function push(node)</span><br><span class="line">&#123;</span><br><span class="line">    d_data.push(node);</span><br><span class="line">    var min = m_data[m_data.length - 1];</span><br><span class="line">    if (min === undefined) &#123;</span><br><span class="line">        m_data.push(node);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        m_data.push(Math.min(min, node))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function pop()</span><br><span class="line">&#123;</span><br><span class="line">    if (m_data.length === 0) &#123;</span><br><span class="line">        throw new Error(&apos;Stack is Empty&apos;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        m_data.pop();</span><br><span class="line">    	return d_data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function top()</span><br><span class="line">&#123;</span><br><span class="line">    // write code here</span><br><span class="line">&#125;</span><br><span class="line">function min()</span><br><span class="line">&#123;</span><br><span class="line">    if (m_data.length === 0) &#123;</span><br><span class="line">        throw new Error(&apos;Stack is Empty&apos;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return m_data[m_data.length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p><strong>这道题使用了一个新的辅助栈来解决问题</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var stack = [];</span><br><span class="line">function IsPopOrder(pushV, popV)&#123;</span><br><span class="line">    for (var i = 0; i &lt; pushV.length; i++) &#123;</span><br><span class="line">        if (pushV[i] === popV[0]) &#123;</span><br><span class="line">            popV.shift();</span><br><span class="line">			while(stack.length &gt; 0) &#123;</span><br><span class="line">				if (stack[stack.length - 1] === popV[0]) &#123;</span><br><span class="line">					stack.pop();</span><br><span class="line">					popV.shift();</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">			stack.push(pushV[i]);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (stack.length === 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p><strong>这道题就是广度优先遍历，使用一个辅助的队列进行遍历</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function PrintFromTopToBottom(root)</span><br><span class="line">&#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line">    var a = [], result = [];</span><br><span class="line">    a.push(root);</span><br><span class="line">    while(a.length &gt; 0) &#123;</span><br><span class="line">        var elem = a.shift();</span><br><span class="line">        if (elem) &#123;</span><br><span class="line">            result.push(elem.val);</span><br><span class="line">            a.push(elem.left);</span><br><span class="line">            a.push(elem.right);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function VerifySquenceOfBST(sequence)</span><br><span class="line">&#123;</span><br><span class="line">    if (sequence === null || sequence.length === 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; </span><br><span class="line">    if (sequence.length &lt; 3) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    var i = 0, root = sequence[sequence.length - 1];</span><br><span class="line">    for (; i &lt; sequence.length - 1; i++) &#123;</span><br><span class="line">        if (sequence[i] &gt; root) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	var j = i;</span><br><span class="line">	for(;j &lt; sequence.length - 1; j++) &#123;</span><br><span class="line">		if (sequence[j] &lt; root) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (i &gt; 0 &amp;&amp; i &lt; sequence.length - 1) &#123;</span><br><span class="line">		return (VerifySquenceOfBST(sequence.slice(0, i)) &amp;&amp; VerifySquenceOfBST(sequence.slice(i, sequence.length - 1)))</span><br><span class="line">	&#125; else if (i &gt; 0) &#123;</span><br><span class="line">		return VerifySquenceOfBST(sequence.slice(0, i));</span><br><span class="line">	&#125; else if (i &lt; sequence.length - 1) &#123;</span><br><span class="line">		return VerifySquenceOfBST(sequence.slice(i, sequence.length - 1));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p><strong>这道题其实是深度优先遍历，并且使用一个栈结构来存储路径</strong></p>
<p>在计算每个节点的时候，要先把节点的值入栈，执行完该节点以及该节点的子节点的时候，要把该节点出栈。</p>
<p><strong>在 <code>result</code> 中存储的值是 <code>path</code> 的一个深拷贝，所以使用 <code>path.slice()</code> 创建一个新的数组</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var result = [], path = [];</span><br><span class="line">function FindPath(root, expectNumber)</span><br><span class="line">&#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    cal(root, expectNumber);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">function cal(root, expectNumber) &#123;</span><br><span class="line">	path.push(root.val);</span><br><span class="line"> 	if (expectNumber === root.val &amp;&amp; root.left === null &amp;&amp; root.right === null) &#123;</span><br><span class="line">        result.push(path.slice());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (root.left !== null) &#123;</span><br><span class="line">            cal(root.left, expectNumber - root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.right !== null) &#123;</span><br><span class="line">            cal(root.right, expectNumber - root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">	path.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p><strong>这个算法中，指向任意一个节点的寻找，是 O(n ^ 2) 时间复杂度。</strong>为了简化寻找任意一个节点，我们可以在创建下一个节点的时候，使用 HashMap 存储一个<code>&lt;N, N&#39;&gt;</code> 的哈希表，这就是一个用空间换时间的方法。</p>
<p>第二种方法是：创建的 <code>N&#39;</code> 链接到 <code>N</code> 的后面，这样就可以根据 <code>N</code> 找到 <code>N&#39;</code> 指向的的任意节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function RandomListNode(x)&#123;</span><br><span class="line">    this.label = x;</span><br><span class="line">    this.next = null;</span><br><span class="line">    this.random = null;</span><br><span class="line">&#125;</span><br><span class="line">function Clone(pHead)</span><br><span class="line">&#123;</span><br><span class="line">    if (pHead !== null) &#123;</span><br><span class="line">        cloneNodes(pHead);</span><br><span class="line">        ConnectRandomNodes(pHead);</span><br><span class="line">        return ReconnectNodes(pHead);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function cloneNodes(pHead) &#123;</span><br><span class="line">    var cNode = new RandomListNode(pHead.label);</span><br><span class="line">    var nextNode = pHead.next;</span><br><span class="line">    pHead.next = cNode;</span><br><span class="line">    cNode.next = nextNode;</span><br><span class="line">    if(nextNode !==  null) &#123;</span><br><span class="line">        cloneNodes(nextNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function ConnectRandomNodes(pHead) &#123;</span><br><span class="line">    if (pHead.random) &#123;</span><br><span class="line">        var rNode = pHead.random,</span><br><span class="line">            cNode = pHead.next;</span><br><span class="line">        cNode.random = rNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pHead.next.next) &#123;</span><br><span class="line">        ConnectRandomNodes(pHead.next.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function ReconnectNodes(pHead) &#123;</span><br><span class="line">    var cPHead = pHead.next, nNode = pHead.next;</span><br><span class="line">    while(nNode.next) &#123;</span><br><span class="line">        nNode.next = nNode.next.next;</span><br><span class="line">        nNode = nNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return cPHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><h3 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>二叉搜索树中，左节点的值总是小于右节点的值，生成的双向链表中，前一项的值总是小于后一项的值。</p>
<p><strong>相当于对二叉搜索树的中序遍历。</strong></p>
<p>在这里使用的是非递归方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Convert(pRootOfTree)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRootOfTree === null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    var stack = [], p = pRootOfTree, head, pre;</span><br><span class="line">    var isFirst = true;</span><br><span class="line">    while(p !== null || stack.length !== 0) &#123;</span><br><span class="line">        while(p) &#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        var node = stack.pop();</span><br><span class="line">        if (isFirst) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">            pre = node;</span><br><span class="line">            isFirst = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pre.right = node;</span><br><span class="line">            node.left = pre;</span><br><span class="line">            pre = node;</span><br><span class="line">        &#125;</span><br><span class="line">        p = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Permutation(str)</span><br><span class="line">&#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    if (str === null || str.length === 0) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    var arr = Array.from(str);</span><br><span class="line">    reformStr(arr, 0, result);</span><br><span class="line">	result = Array.from(new Set(result));</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">function reformStr(arr, start, result) &#123;</span><br><span class="line">	result.push(arr.join(&quot;&quot;));</span><br><span class="line">	for (var i = start; i &lt; arr.length; i++) &#123;</span><br><span class="line">		if (arr[start] !== arr[i]) &#123;</span><br><span class="line">			[arr[start], arr[i]] = [arr[i], arr[start]];</span><br><span class="line">			reformStr(arr, start + 1, result);</span><br><span class="line">			[arr[start], arr[i]] = [arr[i], arr[start]]; </span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			reformStr(arr, start + 1, result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p><strong>方法一，可以对数组进行排序，因为该数出现的次数超过数组长度的一半，所以排序后该数字必定出现在排序数组中的第 <code>n/2</code> 个位置上。</strong></p>
<p><strong>方法二，我们在遍历数组的时候保存两个值，第一个是数组的数字，第二个是出现的次数。如果遍历下一个数字和保存的数字相同，则该次数加一；如果不同，则该次数减一。如果次数减到 0，则保存下一个数字。</strong></p>
<p>这里用的是第二种方法，第二种方法的时间复杂度是 O(n)，比排序的时间复杂度要小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function MoreThanHalfNum_Solution(numbers)</span><br><span class="line">&#123;</span><br><span class="line">    if (numbers === null || numbers.length === 0) &#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">    var val = numbers[0], time = 0;</span><br><span class="line">    for (var i = 0; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        if (val === numbers[i]) &#123;</span><br><span class="line">            ++time;</span><br><span class="line">        &#125; else if (time &gt; 0) &#123;</span><br><span class="line">            --time;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            val = numbers[i];</span><br><span class="line">            ++time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var k = 0;</span><br><span class="line">	for (var i = 0; i &lt; numbers.length; i++) &#123;</span><br><span class="line">		if (numbers[i] == val) &#123;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return (k &gt; Math.floor(numbers.length/2) ? val : 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.nowcoder.com/profile/7551561/codeBookDetail?submissionId=11048551" target="_blank" rel="noopener">解题思路</a></p>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<p><strong>如果是先对所有的数据进行排序后再获得最小的 K 个数，这种思路的时间复杂度是 O(n)</strong></p>
<p><strong>还可以参考快排的方法，首先找到第 K 小的数字，然后用快排，将数组左右分割即可，该算法的时间复杂度是 O(n)</strong></p>
<p><strong>还可以构造最小堆，时间复杂度是 O(nlogk)，或者维护一个只有 K 大小的排序数组。</strong></p>
<p>我这里使用的是类似快排的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function GetLeastNumbers_Solution(input, k)</span><br><span class="line">&#123;</span><br><span class="line">    if (input === null || input.length &lt; k) &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    if (input.length === k) &#123;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;</span><br><span class="line">    var start = 0, end = input.length - 1, len = 0;</span><br><span class="line">    var index = Partition(input, start, end);</span><br><span class="line">    while(index != k - 1) &#123;</span><br><span class="line">        if (index &lt; k - 1) &#123;</span><br><span class="line">            index = Partition(input, index + 1, end);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            index = Partition(input, start, index - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return input.slice(0, k);</span><br><span class="line">&#125;</span><br><span class="line">function Partition(input, start, end) &#123;</span><br><span class="line">	var key = input[start], low = start, high = end;</span><br><span class="line">    while(low &lt; high) &#123;</span><br><span class="line">        while(low &lt; high &amp;&amp; key &lt; input[high]) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        input[low] = input[high];</span><br><span class="line">        while(low &lt; high &amp;&amp; key &gt; input[low]) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        input[high] = input[low];	</span><br><span class="line">    &#125;</span><br><span class="line">    input[low] = key;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>
<p><a href="https://www.nowcoder.com/profile/284008/codeBookDetail?submissionId=9704055" target="_blank" rel="noopener">解答</a></p>
<p>本方法是使用动态规划的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function FindGreatestSumOfSubArray(array)</span><br><span class="line">&#123;</span><br><span class="line">    if (array.length === 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    var max = array[0], temp = array[0];</span><br><span class="line">    for (var i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">        temp = temp &lt; 0 ? array[i] : array[i] + temp;</span><br><span class="line">        max = max &gt; temp ? max : temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="整数中1出现的次数（从1到n整数中1出现的次数）"></a>整数中1出现的次数（从1到n整数中1出现的次数）</h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<p><a href="https://www.nowcoder.com/profile/9571580/codeBookDetail?submissionId=12601864" target="_blank" rel="noopener">解答</a></p>
<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p>解决的方法是，使用 <code>Array.protorype.sort</code> 方法中接收的比较函数来比较两个数字。由于数字组成的新的数值可能溢出，所以比较的方法就是把数字组成字符串，然后比较字符串的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function PrintMinNumber(numbers)</span><br><span class="line">&#123;</span><br><span class="line">    if (numbers.length === 0) &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    var a = numbers.sort(compare);</span><br><span class="line">    return a.join(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function compare(a, b) &#123;</span><br><span class="line">    return a + &quot;&quot; + b &gt; b + &quot;&quot; + a ? 1 : -1 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p>在这道题上，每个丑数都是前一个丑数乘以 2、3、5 得到的，关键在于如何确保数组中的丑数是排好序的。</p>
<p><strong>我们没有必要把每个丑数都乘以 2、3、5，而是记录上一个被乘以 2、3、5的丑数即可。</strong></p>
<p><strong>所以，我们在迭代数组中的数据计算下一个数据的时候，可以保存上一次迭代的节点。这样既方便计算，又减少了时间复杂度。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function min(n1, n2, n3) &#123;</span><br><span class="line">    return n1 &lt; n2 ? (n1 &lt; n3 ? n1 : n3) : (n2 &lt; n3 ? n2 : n3);</span><br><span class="line">&#125;</span><br><span class="line">function GetUglyNumber_Solution(index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &lt; 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    var gulyNumber = [1];</span><br><span class="line">    var nextIndex = 0;</span><br><span class="line">    var T2index = 0, T3index = 0, T5index = 0;</span><br><span class="line">    </span><br><span class="line">    while (nextIndex + 1 &lt; index) &#123;</span><br><span class="line">        var minNum = min(gulyNumber[T2index] * 2, gulyNumber[T3index] * 3, gulyNumber[T5index] * 5);</span><br><span class="line">        gulyNumber.push(minNum);</span><br><span class="line">        ++nextIndex;</span><br><span class="line">        while(gulyNumber[T2index] * 2 &lt;= gulyNumber[nextIndex]) &#123;</span><br><span class="line">            ++ T2index;</span><br><span class="line">        &#125;</span><br><span class="line">        while(gulyNumber[T3index] * 3 &lt;= gulyNumber[nextIndex]) &#123;</span><br><span class="line">            ++ T3index;</span><br><span class="line">        &#125;</span><br><span class="line">        while(gulyNumber[T5index] * 5 &lt;= gulyNumber[nextIndex]) &#123;</span><br><span class="line">            ++ T5index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return gulyNumber[nextIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第一个只出现一次的字符位置"><a href="#第一个只出现一次的字符位置" class="headerlink" title="第一个只出现一次的字符位置"></a>第一个只出现一次的字符位置</h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>
<p>这个题的解法，是用 map 或者对象存储字符串出现的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function FirstNotRepeatingChar(str)</span><br><span class="line">&#123;</span><br><span class="line">    if (str.length === 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    var map = &#123;&#125;;</span><br><span class="line">    for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">        var x = str[i];</span><br><span class="line">        if (map[x]) &#123;</span><br><span class="line">           map[x] = -1; </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map[x] = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">    	if (map[str[i]] &gt;= 0) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><h3 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>输入描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">题目保证输入的数组中没有的相同的数字</span><br><span class="line">数据范围：</span><br><span class="line">	对于%50的数据,size&lt;=10^4</span><br><span class="line">	对于%75的数据,size&lt;=10^5</span><br><span class="line">	对于%100的数据,size&lt;=2*10^5</span><br></pre></td></tr></table></figure>
<p>输入例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,4,5,6,7,0</span><br></pre></td></tr></table></figure>
<p>输出例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<p><a href="https://www.nowcoder.com/profile/6050759/codeBookDetail?submissionId=12615137" target="_blank" rel="noopener">解答</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function InversePairs(data)</span><br><span class="line">&#123;</span><br><span class="line">    if (data === null || data.length &lt; 2) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; </span><br><span class="line">    var copy = data.slice();</span><br><span class="line">    return mergeSort(data, copy, 0, data.length - 1);</span><br><span class="line">&#125;</span><br><span class="line">function mergeSort(data, copy, start, end) &#123;</span><br><span class="line">    if (start === end) return 0;</span><br><span class="line">    var mid = Math.floor((start + end) / 2);</span><br><span class="line">    var left = mergeSort(data, copy, start, mid);</span><br><span class="line">    var right = mergeSort(data, copy, mid+1, end);    </span><br><span class="line">    var count = 0, p1 = mid, p2 = end , p3 = end;</span><br><span class="line">    while(p1 &gt;= start &amp;&amp; p2 &gt;= mid + 1) &#123;</span><br><span class="line">        if (copy[p1] &gt; copy[p2]) &#123;</span><br><span class="line">            count += p2 - mid;</span><br><span class="line">            data[p3--] = copy[p1--];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            data[p3--] = copy[p2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (p1 &gt;= start) &#123;</span><br><span class="line">        data[p3--] = copy[p1--];</span><br><span class="line">    &#125;</span><br><span class="line">    while (p2 &gt;= mid + 1) &#123;</span><br><span class="line">        data[p3--] = copy[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        copy[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return left + right + count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h2><h3 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function FindFirstCommonNode(pHead1, pHead2)</span><br><span class="line">&#123;</span><br><span class="line">    if (pHead1 === null || pHead2 === null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    var pNext1 = pHead1, pNext2 = pHead2;</span><br><span class="line">    var len = getlen(pHead1, pHead2);</span><br><span class="line">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        if (pNext1 === null) &#123;</span><br><span class="line">            pNext1 = pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pNext2 === null) &#123;</span><br><span class="line">            pNext2 = pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pNext1 === pNext2) &#123;</span><br><span class="line">            return pNext1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pNext1 = pNext1.next;</span><br><span class="line">            pNext2 = pNext2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getlen(pHead1, pHead2) &#123;</span><br><span class="line">    var len = 0;</span><br><span class="line">    while (pHead1 !== null) &#123;</span><br><span class="line">        ++len;</span><br><span class="line">        pHead1 = pHead1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (pHead2 !== null) &#123;</span><br><span class="line">        ++len;</span><br><span class="line">        pHead2 = pHead2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h2><h3 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计一个数字在排序数组中出现的次数。</p>
<p>因为是排序的数组，所以考虑使用二分查找法找到数组中第一个数字和最后一个数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">function GetNumberOfK(data, k)</span><br><span class="line">&#123;</span><br><span class="line">    if (data === null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if (data.length === 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    var start = getFirstK(data, 0, data.length - 1, k);</span><br><span class="line">    var end = getLastK(data, 0, data.length - 1, k);</span><br><span class="line">		if (start === -1) &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		return end - start + 1;</span><br><span class="line">&#125;</span><br><span class="line">function getFirstK(data, start, end, k) &#123;</span><br><span class="line">    if (data.length === 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if (start === end) &#123;</span><br><span class="line">			if (data[start] === k) &#123;</span><br><span class="line">				return start;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return -1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    var mid = Math.floor((start + end)/2);</span><br><span class="line">    if (data[mid] === k) &#123;</span><br><span class="line">        if (mid === 0) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else if (data[mid - 1] !== k) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">					return getFirstK(data, start, mid - 1, k);</span><br><span class="line">				&#125;</span><br><span class="line">    &#125; else if (data[mid] &lt; k) &#123;</span><br><span class="line">        return getFirstK(data, mid + 1, end, k)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return getFirstK(data, start, mid - 1, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function getLastK(data, start, end, k) &#123;</span><br><span class="line">    if (data.length === 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if (start === end) &#123;</span><br><span class="line">			if (data[start] === k) &#123;</span><br><span class="line">				return start;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return -1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    var mid = Math.floor((start + end)/2);</span><br><span class="line">    if (data[mid] === k) &#123;</span><br><span class="line">        if (mid === data.length - 1) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else if (data[mid + 1] !== k) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">					return getLastK(data, mid + 1, end, k);</span><br><span class="line">				&#125;</span><br><span class="line">    &#125; else if (data[mid] &lt; k) &#123;</span><br><span class="line">        return getLastK(data, mid + 1, end, k);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return getLastK(data, start, end - 1, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><h3 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function TreeDepth(pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    if (pRoot === null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else if (pRoot.left === null &amp;&amp; pRoot.right === null) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    var len = 0, stack = [[pRoot]];</span><br><span class="line">    while(stack.length !== 0) &#123;</span><br><span class="line">        var tmp = stack.pop(), nextStack = [];</span><br><span class="line">        tmp.forEach(function(node) &#123;</span><br><span class="line">            if (node.left !== null) &#123;</span><br><span class="line">                nextStack.push(node.left)</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right !== null) &#123;</span><br><span class="line">                nextStack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        if (nextStack.length &gt; 0) &#123;</span><br><span class="line">            stack.push(nextStack);</span><br><span class="line">        &#125;</span><br><span class="line">        ++len;</span><br><span class="line">    &#125; </span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题还可以使用递归的方法来求解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function TreeDepth(pRoot)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    if(pRoot == null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    var left = TreeDepth(pRoot.left)+1;</span><br><span class="line">    var right = TreeDepth(pRoot.right)+1;</span><br><span class="line">    return Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>使用后序遍历来解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function IsBalanced_Solution(pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    var result = isBalanced(pRoot);</span><br><span class="line">    return result[0];</span><br><span class="line">&#125;</span><br><span class="line">function isBalanced(root) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return [true, 0];</span><br><span class="line">    &#125;</span><br><span class="line">    var left = isBalanced(root.left);</span><br><span class="line">    var right = isBalanced(root.right);</span><br><span class="line">    if (left[0] &amp;&amp; right[0]) &#123;</span><br><span class="line">        if (Math.abs(left[1] - right[1]) &gt; 1) &#123;</span><br><span class="line">            return [false, 0];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return [true, left[1] &gt; right[1] ? left[1] + 1: right[1] + 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [left[0] &amp;&amp; right[0], 0]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h2><h3 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。时间复杂度 O(n)，空间复杂度 O(1)</p>
<p><strong>每个数字异或自己都等于 0</strong></p>
<p>可以用位运算实现，如果将所有所有数字相异或，则最后的结果肯定是那两个只出现一次的数字异或<br> 的结果，所以根据异或的结果1所在的最低位，把数字分成两半，每一半里都还有只出现一次的数据和成对出现的数据<br> 这样继续对每一半相异或则可以分别求出两个只出现一次的数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function FindNumsAppearOnce(array)</span><br><span class="line">&#123;</span><br><span class="line">    if (array === null || array.length &lt; 3) &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    var a = array.reduce(function(acc, val) &#123;</span><br><span class="line">        return acc ^ val;</span><br><span class="line">    &#125;, 1) ^ 1;</span><br><span class="line">    var pos = findFirst1(a);</span><br><span class="line">    var has1 = [], nothas1 = [];</span><br><span class="line">    array.forEach(function(num) &#123;</span><br><span class="line">        if (isBit1(num, pos)) &#123;</span><br><span class="line">            has1.push(num);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            nothas1.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    var first = has1.reduce(function(acc, val) &#123;</span><br><span class="line">        return acc ^ val;</span><br><span class="line">    &#125;, 1) ^ 1;</span><br><span class="line">    var second = nothas1.reduce(function(acc, val) &#123;</span><br><span class="line">        return acc ^ val;</span><br><span class="line">    &#125;, 1) ^ 1;</span><br><span class="line">    return [first, second]</span><br><span class="line">&#125;</span><br><span class="line">function findFirst1(num) &#123;</span><br><span class="line">    var index = 0;</span><br><span class="line">    while(!(num &amp; 1)) &#123;</span><br><span class="line">        num = num &gt;&gt; 1;</span><br><span class="line">        ++ index;</span><br><span class="line">    &#125;</span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br><span class="line">function isBit1(num, index) &#123;</span><br><span class="line">    num = num &gt;&gt; index;</span><br><span class="line">    return num &amp; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h2><h3 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h3><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! </p>
<p>输出描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//根据数学公式计算:(a1+an)*n/2=s  n=an-a1+1</span><br><span class="line"></span><br><span class="line">//(an+a1)*(an-a1+1)=2*s=k*l(k&gt;l)</span><br><span class="line"></span><br><span class="line">//an=(k+l-1)/2 a1=(k-l+1)/2</span><br></pre></td></tr></table></figure>
<p>解答为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function FindContinuousSequence(sum)</span><br><span class="line">&#123;</span><br><span class="line">    if (sum &lt; 3) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum * 2;</span><br><span class="line">    var s = Math.floor(Math.sqrt(2 *sum)), result = [];</span><br><span class="line">    for (var i = s; i &gt;= 2; i--) &#123;</span><br><span class="line">        if (sum % i === 0) &#123;</span><br><span class="line">            var k = sum/i;</span><br><span class="line">            var list = [];</span><br><span class="line">            if ((i ^ k) &amp; 1 &amp;&amp; k &gt; i) &#123;  // k应该大于i，并且 k 和 i 应该一奇一偶</span><br><span class="line">                for (var j = (k - i + 1)/2; j &lt;= (k + i - 1)/2; j ++) &#123;</span><br><span class="line">                    list.push(j);</span><br><span class="line">                &#125;</span><br><span class="line">                result.push(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h2><h3 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。<br>输出描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应每个测试案例，输出两个数，小的先输出。</span><br></pre></td></tr></table></figure>
<p>一个指针指向头，一个指向尾，如果和小于 sum，则头指针后移，如果和大于 sum，则尾指针前移。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function FindNumbersWithSum(array, sum)</span><br><span class="line">&#123;</span><br><span class="line">    var result = []</span><br><span class="line">    if (array === null || array.length &lt; 2) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    var start = 0, end = array.length - 1;</span><br><span class="line">    while(start &lt; end) &#123;</span><br><span class="line">        var s = array[start] + array[end];</span><br><span class="line">        if ( s === sum ) &#123;</span><br><span class="line">            result.push(array[start]);</span><br><span class="line">            result.push(array[end]);</span><br><span class="line">            break;</span><br><span class="line">        &#125; else if (s &lt; sum) &#123;</span><br><span class="line">            ++start;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h2><h3 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h3><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><h3 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/22/mongodb-入门/" rel="next" title="mongodb 入门">
                <i class="fa fa-chevron-left"></i> mongodb 入门
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/08/JavaScript-与-JSON/" rel="prev" title="JavaScript 与 JSON">
                JavaScript 与 JSON <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/04/04/剑指offer题集/" data-title="剑指offer题集" data-url="https://shiningdan.github.io/2017/04/04/剑指offer题集/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://ofjjubwp5.bkt.clouddn.com/image/jpg/avatar.jpg" alt="ShiningDan">
          <p class="site-author-name" itemprop="name">ShiningDan</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">129</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">111</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#二维数组中的查找"><span class="nav-number">1.</span> <span class="nav-text">二维数组中的查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述"><span class="nav-number">1.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#替换空格"><span class="nav-number">2.</span> <span class="nav-text">替换空格</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-1"><span class="nav-number">2.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从头到尾打印链表"><span class="nav-number">3.</span> <span class="nav-text">从头到尾打印链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-2"><span class="nav-number">3.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重建二叉树"><span class="nav-number">4.</span> <span class="nav-text">重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-3"><span class="nav-number">4.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用两个栈实现队列"><span class="nav-number">5.</span> <span class="nav-text">使用两个栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-4"><span class="nav-number">5.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#旋转数组的最小数字"><span class="nav-number">6.</span> <span class="nav-text">旋转数组的最小数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-5"><span class="nav-number">6.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#斐波那契数"><span class="nav-number">7.</span> <span class="nav-text">斐波那契数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-6"><span class="nav-number">7.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳台阶"><span class="nav-number">8.</span> <span class="nav-text">跳台阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-7"><span class="nav-number">8.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变态跳台阶"><span class="nav-number">9.</span> <span class="nav-text">变态跳台阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-8"><span class="nav-number">9.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩形覆盖"><span class="nav-number">10.</span> <span class="nav-text">矩形覆盖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-9"><span class="nav-number">10.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制中-1-的个数"><span class="nav-number">11.</span> <span class="nav-text">二进制中 1 的个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-10"><span class="nav-number">11.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值的整数次方"><span class="nav-number">12.</span> <span class="nav-text">数值的整数次方</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-11"><span class="nav-number">12.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调整数组顺序使奇数位于偶数前面"><span class="nav-number">13.</span> <span class="nav-text">调整数组顺序使奇数位于偶数前面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-12"><span class="nav-number">13.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表中倒数第k个结点"><span class="nav-number">14.</span> <span class="nav-text">链表中倒数第k个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-13"><span class="nav-number">14.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#翻转链表"><span class="nav-number">15.</span> <span class="nav-text">翻转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-14"><span class="nav-number">15.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并两个排序的链表"><span class="nav-number">16.</span> <span class="nav-text">合并两个排序的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-15"><span class="nav-number">16.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树的子结构"><span class="nav-number">17.</span> <span class="nav-text">树的子结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-16"><span class="nav-number">17.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的镜像"><span class="nav-number">18.</span> <span class="nav-text">二叉树的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-17"><span class="nav-number">18.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺时针打印矩阵"><span class="nav-number">19.</span> <span class="nav-text">顺时针打印矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-18"><span class="nav-number">19.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包含-min-函数的栈"><span class="nav-number">20.</span> <span class="nav-text">包含 min 函数的栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-19"><span class="nav-number">20.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈的压入、弹出序列"><span class="nav-number">21.</span> <span class="nav-text">栈的压入、弹出序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-20"><span class="nav-number">21.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从上往下打印二叉树"><span class="nav-number">22.</span> <span class="nav-text">从上往下打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-21"><span class="nav-number">22.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉搜索树的后序遍历序列"><span class="nav-number">23.</span> <span class="nav-text">二叉搜索树的后序遍历序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-22"><span class="nav-number">23.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树中和为某一值的路径"><span class="nav-number">24.</span> <span class="nav-text">二叉树中和为某一值的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-23"><span class="nav-number">24.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复杂链表的复制"><span class="nav-number">25.</span> <span class="nav-text">复杂链表的复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-24"><span class="nav-number">25.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉搜索树与双向链表"><span class="nav-number">26.</span> <span class="nav-text">二叉搜索树与双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-25"><span class="nav-number">26.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的排列"><span class="nav-number">27.</span> <span class="nav-text">字符串的排列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-26"><span class="nav-number">27.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组中出现次数超过一半的数字"><span class="nav-number">28.</span> <span class="nav-text">数组中出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-27"><span class="nav-number">28.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小的K个数"><span class="nav-number">29.</span> <span class="nav-text">最小的K个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-28"><span class="nav-number">29.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连续子数组的最大和"><span class="nav-number">30.</span> <span class="nav-text">连续子数组的最大和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-29"><span class="nav-number">30.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整数中1出现的次数（从1到n整数中1出现的次数）"><span class="nav-number">31.</span> <span class="nav-text">整数中1出现的次数（从1到n整数中1出现的次数）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-30"><span class="nav-number">31.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#把数组排成最小的数"><span class="nav-number">32.</span> <span class="nav-text">把数组排成最小的数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-31"><span class="nav-number">32.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#丑数"><span class="nav-number">33.</span> <span class="nav-text">丑数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-32"><span class="nav-number">33.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一个只出现一次的字符位置"><span class="nav-number">34.</span> <span class="nav-text">第一个只出现一次的字符位置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-33"><span class="nav-number">34.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组中的逆序对"><span class="nav-number">35.</span> <span class="nav-text">数组中的逆序对</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-34"><span class="nav-number">35.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两个链表的第一个公共结点"><span class="nav-number">36.</span> <span class="nav-text">两个链表的第一个公共结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-35"><span class="nav-number">36.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数字在排序数组中出现的次数"><span class="nav-number">37.</span> <span class="nav-text">数字在排序数组中出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-36"><span class="nav-number">37.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的深度"><span class="nav-number">38.</span> <span class="nav-text">二叉树的深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-37"><span class="nav-number">38.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平衡二叉树"><span class="nav-number">39.</span> <span class="nav-text">平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-38"><span class="nav-number">39.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组中只出现一次的数字"><span class="nav-number">40.</span> <span class="nav-text">数组中只出现一次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-39"><span class="nav-number">40.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#和为S的连续正数序列"><span class="nav-number">41.</span> <span class="nav-text">和为S的连续正数序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-40"><span class="nav-number">41.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#和为S的两个数字"><span class="nav-number">42.</span> <span class="nav-text">和为S的两个数字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-41"><span class="nav-number">42.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#翻转单词顺序列"><span class="nav-number">43.</span> <span class="nav-text">翻转单词顺序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-42"><span class="nav-number">43.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#左旋转字符串"><span class="nav-number">44.</span> <span class="nav-text">左旋转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目描述-43"><span class="nav-number">44.1.</span> <span class="nav-text">题目描述</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShiningDan</span>
</div>



        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"shiningdan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js?v=5.1.0"></script>
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("nr3cyUXVpbTxQQRcqfMp5cHa-gzGzoHsz", "B1SG80mnbseYxv4C0vAjig8s");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
