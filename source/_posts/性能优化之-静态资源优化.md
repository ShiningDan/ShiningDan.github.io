---
title: 性能优化之 静态资源优化
date: 2017-05-16 15:52:35
tags:
  - JavaScript
  - CSS
---

在本博客中，对 JavaScript 代码和 CSS 代码进行了压缩，并且将压缩后的代码通过内联的信息放在了 HTML 中，用来节省多次 TCP 请求的时间。客户端在接收了 CSS 文件和 JS 文件以后，会存在本地的 LocalStorage 缓存里，在下一次使用的时候就不需要再次请求了。

<!--more-->

## CSS 静态资源优化

### 集成并压缩 CSS 文件

针对前一篇博客中提到的过多的 CSS 请求，会导致多次简历 TCP 连接，所以对网页的首屏渲染造成延迟的影响，所以我们要做的是，将不同的 CSS 文件合并成一个 CSS 文件，并且以内联的形式添加到 HTML 页面中。

我的博客自动化框架使用的是 Gulp，所以针对 Gulp，使用 PostCSS 框架，来进行 CSS 的自动添加前缀，CSS 文件的合并，CSS 文件的压缩和导出。

首先安装需要的插件：

```
npm install --save-deve gulp-postcss
npm install --save-deve autoprefixer
npm install --save-deve postcss-import
npm install --save-deve css-mqpacker
npm install --save-deve cssnano
```

并且在 `gulpfile.js` 中导入模块，创建 `css` 任务：

```
let postcss = require('gulp-postcss');
let autoprefixer = require('autoprefixer');
let atImport = require('postcss-import');
let mqpacker = require('css-mqpacker'); 
let cssnano = require('cssnano');

gulp.task('css', function () { 
  var processors = [autoprefixer, atImport, mqpacker, cssnano]; 
  return gulp.src('./view/output/*-combo.css')
    .pipe(postcss(processors))
    .pipe(gulp.dest('./www/static/css')); 
});
```

根据我们的 `css` 任务的定义，我们要在 `/view/output/` 中创建结尾为 `-combo.css` 的 CSS 文件，用来表示合成的 CSS 文件，我们以 `article-combo.css` 文件为例，其中的内容为：

```
@import '../layout/layout.css';
@import '../header/header.css';
@import '../page-nav/page-nav.css';
@import '../footer/footer.css';
@import '../article/article.css';
```

里面的内容很简单，就是使用 `@import` 将相关的 CSS 文件引入，然后 `postcss-import` 就可以根据 `@import` 进来的 CSS 文件路径来合成多个 `CSS` 文件。

除此以外，还需要创建的 CSS 文件有：

```
admin-login-combo.css
archives-combo.css
article-combo.css
home-combo.css
list-combo.css
series-combo.css
upload-combo.css
```

此时，可以删除 Pug 文件中原来的 CSS 文件，然后使用 `include` 来引入集成好的 CSS 文件。

最后删除原来 Pug 模板中的 CSS 文件，引入新的集成好的 CSS 文件。

我们可以对比一下 CSS 文件集成前后的区别：

**首页**：

因为首页传输的图片数量比较小，所以可以在 Chrome Network 里面设置网络的情况为：Regular 2G (250kb/s)，并且关闭所有的缓存。当 CSS 文件没有被集成之前：

![](http://ojt6zsxg2.bkt.clouddn.com/224b214c920050009c1d0ecb7eb392e1.png)

在 `Load` 事件被触发的时候，差不多用了 1s 的时间。

当我们设置使用集成的 CSS 文件以后，首页加载的情况如下：

![](http://ojt6zsxg2.bkt.clouddn.com/46adb266719dad63b145aa77ee728e0f.png)

从上图中，我们可以看到，网页中已经没有多余的 CSS 文件来影响首屏渲染速度，当 HTML 加载完成后，也就代表着 CSS 文件加载完成，此时的速度差不多为 `650ms`，几乎是前面加载多个 CSS 文件的一半！

所以，由此我们可以看出，将多个 CSS 文件合并成一个 CSS 文件，并且通过内联模式引入到 HTML 页面中，可以节省很大一部分时间。

## 图片优化

在之间的前端性能测试中，图像的加载耗费了很大的时间，在首页上，涉及到的图片有 `avatar.jpg` 和 `header-bg.jpg`，这两张图片的大小都是 `303KB`，在加载的时候会消耗太长的时间，首先，我们先对这两张图片的大小进行修改。

我们将着两张图片都进行压缩，其中，对 `avatar.jpg` 压缩成 PNG 格式，并且将大小修改成 `800px x 800px`，使用锐利压缩的方法，压缩后，`avatar.png` 的大小为 `65KB`，`header-bg.jpg` 的大小为 `37KB`。

下面我们进行测试：

**首页**：

![](http://ojt6zsxg2.bkt.clouddn.com/74fa86a4d31b6daad5994149983331e7.png)

在使用原有的图像的时候，我们看到，这两张图片的加载时间有 `3.58s`。对网页的加载速度影响很大。

当我们使用新的压缩后的图片，测试的结果如下：

![](http://ojt6zsxg2.bkt.clouddn.com/c8859fa9a8977858ac44e165ba350bcf.png)

我们可以看到，现在图片加载的时间大约 `170ms`，基本上没有图片慢慢加载出现的情况了。并且，为了让背景图片加载的时候，没有从白色到有色的“闪烁”情况出现，我们先对背景设定了一个相近的颜色，来缓冲图片加载时的效果：

```
background-color: #DAF0FE; background-image: url('/img/header-bg.jpg');
```

### 文章页

因为文章页中包含了很多图片，所以对文章页的图片也需要进行压缩优化。

我们将图片的源文件存储在 `/view/output/img` 下，压缩以后的图片存储在 `/www/static/img` 下面。

我们将使用 `gulp-imagemin` 来实现对图片的自动压缩。首先安装 `gulp-imagemin`

```
npm install --save-dev gulp-imagemin
```

然后在 `gulpfile.js` 中添加自动压缩图片的任务：

```
gulp.task('imagemin', function () {
    gulp.src('./view/output/img/*/*/*.{png,jpg,gif,ico}')
        .pipe(imagemin({
            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
            interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染
            multipass: true, //类型：Boolean 默认：false 多次优化svg直到完全优化
        }))
        .pipe(gulp.dest('./www/static/img'));
});
```

最后运行 `gulp`，我们就可以在 `/www/static/img/` 下面得到新的被压缩后的图片。

由于我的博客的图片文件大多数都是 PNG 文件，所以我主要对比 PNG 文件的压缩效果。在当前的设置下，一般的 PNG 文件大多数的压缩率有 50% 左右，并且在显示上看不出太多的区别。

除了使用 `gulp-imagemin` 直接压缩图片以外，针对 PNG 文件，还可以使用 `imagemin-pngquant` 来进行压缩，首先我们需要安装 `imagemin-pngquant`：

```
npm install --save-dev imagemin-pngquant
```

然后修改我们的 `gulpfile.js`：

```
gulp.task('imagemin', function () {
    gulp.src('./view/output/img/**/**/*.{png,jpg,gif,ico}')
        .pipe(imagemin({
            optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
            progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
            interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染
            multipass: true, //类型：Boolean 默认：false 多次优化svg直到完全优化
            use: [pngquant()] //使用pngquant深度压缩png图片的imagemin插件
        }))
        .pipe(gulp.dest('./www/static/img'));
});
```

由于 `imagemin` 不用每次构建都使用，一般只需要在发布或测试的时候一次性压缩就可以了。所以我将 `imagemin` 任务添加到 `browser-sync` 任务之前：

```
gulp.task('default', ['imagemin', 'browser-sync'], function() {
    ...
}
```

另外，使用 webp 格式，通常可以让图片文件大小大幅减小，所以，我也希望在自己的博客中添加对 webp 格式的支持。首先安装 `gulp-webp`：

```
npm install --save-dev gulp-webp
```

然后定义 `webp` 任务，并且将该任务添加到 `gulp` 流程中。

```
gulp.task('webp', function () {
    return gulp.src('./view/output/img/**/**/*.{png,jpg}')
        .pipe(webp())
        .pipe(gulp.dest('./www/static/img'));
});

gulp.task('default', ['imagemin', 'webp', 'browser-sync'], function() {
    ...
}
```

我们来看一下压缩的效果：

* 原图大小：145 KB
* 压缩后的 PNG 大小：70 KB
* 压缩后的 WebP 大小：10 KB

可以看到，压缩的效果是显著的。为什么我们有了 WebP 格式的图片后还需要使用 PNG 的图片呢？因为 WebP 并没有得到所有的浏览器的支持，所以我们还需要通过判断浏览器是否支持 WebP 来决定使用什么格式的图片。

### 检测 WebP 的支持

判断浏览器是否支持 webp 图片，可以检查请求头中的 `Accept` 字段是否包含 `image/webp`

如果包含 `image/webp` 字段，则选择图片格式为 `webp` 的文章内容发送给浏览器，如果不支持，则选择发送带有 `png` 格式图片的内容给浏览器。

下面我们可以测试一下：

使用不支持 `webp` 的 Safari 浏览器时，返回的 `img(src)` 的类型是 `.png`

![](http://ojt6zsxg2.bkt.clouddn.com/44b1399ad9ab641e24df18257a2e66c1.png)

使用支持 `webp` 的 Chrome 浏览器时，返回的 `img(src)` 的类型是 `.webp`

![](http://ojt6zsxg2.bkt.clouddn.com/d49a80eed7e54404b70a93e943990562.png)

