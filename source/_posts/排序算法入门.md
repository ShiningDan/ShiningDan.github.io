---
title: 排序算法入门
date: 2017-03-02 16:02:15
categories: coding
tags:
  - JavaScript
  - Sort
---

最近又整理了一下常用的排序算法，并且都用 JavaScript 实现了一次。

参考链接：

[八大排序算法](http://blog.csdn.net/hguisu/article/details/7776068)
[常见排序算法小结](http://blog.csdn.net/whuslei/article/details/6442755)

排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。

常用的内部排序如下：

![](http://my.csdn.net/uploads/201207/17/1342514529_5795.jpg)


## 插入排序-直接插入排序

将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。

![](http://my.csdn.net/uploads/201207/17/1342520948_8667.jpg)

### 算法的实现

```
function insertSort(arr) {
	for (let i = 1; i < arr.length; i++) {
		let val = arr[i];
		let j = i;
		while (arr[j-1] > val && j > 0) {
			arr[j] = arr[j-1];
			j--;
		}
		arr[j] = val;
	}
	return arr;
}

let a = [3,1,5,7,2,4,9,-4, -7, -5];
insertSort(a);
```
###时间复杂度

O(n^2)

## 插入排序-希尔排序

希尔排序又叫缩小增量排序

### 基本思想

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

先取定一个小于n的整数d1作为第一个增量,把表的全部记录分成d1个组,所有距离为d1的倍数的记录放在同一个组中,在各组内进行直接插入排序；然后,取第二个增量d2(＜d1),重复上述的分组和排序,直至所取的增量`dt=1(dt<dt-1<…<d2<d1)`,即所有记录放在同一组中进行直接插入排序为止。    

![](http://hi.csdn.net/attachment/201105/24/0_1306225546mbOy.gif)

一般增量的选择从 `n/2` 减少到 `1`

```
function shellInsertSort(arr) {
	let len = Math.floor(arr.length/2);
	while (len > 0) {
		for (let i = 0; i < len; i++) {
			let j = i+len;
			while(j < arr.length) {
				let k = j;
				while(k >= len && arr[k-len] > arr[k]) {
					let tmp = arr[k];
					arr[k] = arr[k-len];
					arr[k-len] = tmp;
					k -= len;
				}
				j += len;
			}
		}
		len = Math.floor(len/2);
	}
	return arr;
}
let a = [3,1,5,7,2,4,9,-4, -7, -5];
shellInsertSort(a);
```

### 时间复杂度

最好情况：由于希尔排序的好坏和步长d的选择有很多关系，因此，目前还没有得出最好的步长如何选择(现在有些比较好的选择了，但不确定是否是最好的)。所以，不知道最好的情况下的算法时间复杂度。 

最坏情况下：O(N*logN)，最坏的情况下和平均情况下差不多。  
     
平均情况下：O(N*logN)



























